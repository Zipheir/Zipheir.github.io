2023-05-01 10:03:37 -0400 < danisanti> which Scheme implementation can save a lisp image?
2023-05-01 10:09:53 -0400 < danisanti> none?
2023-05-01 11:09:41 -0400 < mdhughes> Wraith Scheme has world files.
2023-05-01 11:10:21 -0400 < mdhughes> I can't remember last time this came up, what others did. Not many.
2023-05-01 11:11:14 -0400 < mdhughes> rudybot, what do you know about world files?
2023-05-01 11:11:14 -0400 < rudybot> mdhughes: I know a lot of this is me coming from the vim world. The thing about buffers, windows, and files being very distinct things took me a while to wrap my head around, but now it's much better
2023-05-01 11:12:05 -0400 < gwatt> mit-scheme I think has images
2023-05-01 11:14:05 -0400 < mdhughes> rudybot, what do you know about images?
2023-05-01 11:14:05 -0400 < rudybot> mdhughes: many vendor images let disk encryption work correctly, even if you have to find and know about the setting. but disk encryption sadly doesn't do much good if the bootloader and recovery will accept anything you throw at them.
2023-05-01 11:14:43 -0400 < mdhughes> AI's not gonna threaten half-remembered facts this week, anyway.
2023-05-01 11:21:26 -0400 < acdw> apk has a world file
2023-05-01 11:43:39 -0400 < danisanti> what is world files?
2023-05-01 11:43:56 -0400 < danisanti> I am gonna try mit-scheme, gwatt
2023-05-01 12:19:42 -0400 < lockywolf> Has anyone written a FUSE module in Scheme?
2023-05-01 12:37:30 -0400 < danisanti> I have installed mit-scheme. How do I create a scheme image?
2023-05-01 12:38:15 -0400 < danisanti> or How do I save current state of my mt-scheme repl?
2023-05-01 12:38:17 -0400 < wasamasa> I'm sure they explain that somewhere in the manual
2023-05-01 12:38:33 -0400 < danisanti> man says nothing about image
2023-05-01 12:38:42 -0400 < wasamasa> info
2023-05-01 12:38:48 -0400 < danisanti> ok
2023-05-01 12:46:33 -0400 < danisanti> wasamasa: thanks you. It is (disk-save file)
2023-05-01 12:46:40 -0400 < danisanti> it works
2023-05-01 12:46:43 -0400 < wasamasa> cool
2023-05-01 12:47:23 -0400 < danisanti> it was not in the man. Now I am gonna try to find the same in guile info
2023-05-01 12:47:47 -0400 < wasamasa> yeah, GNU man pages tend to be bad
2023-05-01 13:04:55 -0400 < danisanti> guile does have lisp images
2023-05-01 13:05:05 -0400 < danisanti> what a shame.
2023-05-01 13:06:29 -0400 < danisanti> thank you
2023-05-01 13:12:25 -0400 < gwatt> gnu man pages seem to be intentionally bad, to convince you to use `info` instead
2023-05-01 13:13:02 -0400 < wasamasa> lol, it does feel like it
2023-05-01 13:26:06 -0400 < acdw> yes
2023-05-01 13:33:21 -0400 < sham1> Doesn't just feel like it. GNU explicitly encourages it in its coding standard
2023-05-01 13:34:29 -0400 < johnjaye> i use bsd man pages
2023-05-01 13:35:05 -0400 < sham1> > In the GNU project, man pages are secondary. It is not necessary or expected for every GNU program to have a man page, but some of them do. It’s your choice whether to include a man page in your program.
2023-05-01 13:35:20 -0400 < wasamasa> yeah, so debian people write very basic man pages based on them, lol
2023-05-01 13:35:44 -0400 < sham1> So yeah, they don't*explicitly* say to cripple the man-pages, but still
2023-05-01 13:36:02 -0400 < lechner> they really meant to encourage the use of Emacs
2023-05-01 13:36:47 -0400 < sham1> > When a program changes only a little, you may feel that the discrepancies are small enough that the man page remains useful without updating. If so, put a prominent note near the beginning of the man page stating that you don’t maintain it and that the Texinfo manual is more authoritative. The note should say how to access the Texinfo documentation.
2023-05-01 13:37:26 -0400 < wasamasa> info and pinfo can be used from the terminal
2023-05-01 13:37:51 -0400 < lechner> yes, but who does?
2023-05-01 13:38:08 -0400 < acdw> pee-info
2023-05-01 13:38:40 -0400 < acdw> wasamasa: oh damn i didn't realize that some of the gnu manpages were write by debian folkx
2023-05-01 13:38:51 -0400 < jcowan> lechner: I run "info" from the terminal and keep hitting the space bar, mostly
2023-05-01 13:39:00 -0400 < acdw> i like info but sometimes i want to read a manpage dammit
2023-05-01 13:39:34 -0400 < lechner> all of GNU Emacs's original aspirations are alive in Guix, which is what i use!
2023-05-01 13:40:24 -0400 < sham1> I don't like info. Feels too much like a kind of vendor lock-in and NIH
2023-05-01 13:40:38 -0400 < sham1> Nothing new for GNU I suppose, but still
2023-05-01 13:41:15 -0400 < acdw> well it's good for long manuals that are really in-depth about big systems
2023-05-01 13:41:22 -0400 < lechner> back then it was red mond or blue gnu
2023-05-01 13:41:34 -0400 < acdw> i prefer info emacs to say, man emacs-keys man emacs-display man emacs- ...
2023-05-01 13:41:52 -0400 < sham1> I suppose so
2023-05-01 13:41:55 -0400 < acdw> but man pages should exist for every text tool
2023-05-01 13:41:56 -0400 < acdw> imo
2023-05-01 13:42:14 -0400 < johnjaye> lechner: explain please. how is guix aspirational to emacs?
2023-05-01 13:42:16 -0400 < sham1> Of course Emacs also has the ability to just go to the next man-page
2023-05-01 13:42:18 -0400 < acdw> also emacs should /have/ a man page --- it should like, tell you what command line flags it takes, what environment variables it uses, etc.
2023-05-01 13:42:31 -0400 < acdw> they're both good
2023-05-01 13:42:36 -0400 < acdw> or can be, but people are lazy
2023-05-01 13:42:40 -0400 < sham1> johnjaye: one wants to be a lisp machine and the other is closer
2023-05-01 13:43:44 -0400 < johnjaye> the description for pinfo on the apt repository states it is for "docuemtation"
2023-05-01 13:44:41 -0400 < lechner> johnjaye / GNU Guix is like Nix, except with Scheme. Among Guileheads like me, Emacs Lisp is an early form of Scheme
2023-05-01 13:45:35 -0400 < lechner> so a Lisp machine as sham1 wrote, in common parlance, all around
2023-05-01 13:45:36 -0400 < johnjaye> lechner: we were just talking about this kind of thing in #emacs. someone told me about a site call breezewiki written in racket
2023-05-01 13:46:27 -0400 < sham1> One can get close to a system solely configured with the Lisp family by using Guix, Emacs for editing and then either Emacs or stumpwm for graphical interface
2023-05-01 13:46:52 -0400 < sham1> Not quite 100% because you still have parts in shell and whatnot, but close
2023-05-01 13:46:58 -0400 < Zipheir> It's unfortunate that they didn't just convert their TeXinfo manuals to HTML at some point.
2023-05-01 13:47:12 -0400 < sham1> Or, you know, actual tex
2023-05-01 13:47:50 -0400 < Zipheir> Hyperlinks were supposed to be the selling point of TeXinfo. I assume there was no way to get those in plain TeX back in the day.
2023-05-01 13:48:10 -0400 < sham1> Well nowadays we have hyperref
2023-05-01 13:48:26 -0400 < sham1> Although the conversion would be quite big nowadays
2023-05-01 13:48:35 -0400 < lechner> i discovered Guix a year ago after twenty-five years with Debian, and vowed never to write another shell script again. It's Guile (i.e. Scheme) for me, all around. It integrates seamlessly with Guix's config ttools everywhere, for example for mcron jobs
2023-05-01 13:48:42 -0400 < Zipheir> Yeah. There's no reason to maintain a whole other TeX dialect now.
2023-05-01 13:49:24 -0400 < Zipheir> After seeing some of Guix's system foundations recently, I'm not much happier with it than I am with the various Bourne flavors.
2023-05-01 13:49:29 -0400 < jcowan> Isn't Texinfo also supposed to be an easier-to-write markup language, analogous to Markdown?
2023-05-01 13:49:48 -0400 < lechner> Zipheir / will you please elaborate?
2023-05-01 13:50:18 -0400 < Zipheir> jcowan: True, that's another point.
2023-05-01 13:50:35 -0400 < sham1> I'd love a Guix without all the… baggage. While also being Scheme or even CL, so Nix is out
2023-05-01 13:50:59 -0400 < lechner> which baggage, please?
2023-05-01 13:51:20 -0400 < sham1> Well, it's mostly me not being the keenest person when it comes to GNU
2023-05-01 13:51:44 -0400 < lechner> politically?
2023-05-01 13:51:56 -0400 < sham1> I understand that it's a minor gripe with the project and that I also use many other GNU flagship projects like Emacs and such, but yeah
2023-05-01 13:52:04 -0400 < sham1> Basically, RMS for example annoys me
2023-05-01 13:52:40 -0400 < sham1> On one hand, it's good to have someone uncompromising like that. On the other hand, some of his views are unagreeable
2023-05-01 13:53:07 -0400 < Zipheir> lechner: I find the Guix source way too complicated, which is a rather common problem with GNU projects. The style is also rather odd. We had a long debate about the use of allow-other-keys to configure packages.
2023-05-01 13:53:25 -0400 < sham1> Oh yeah, politics aside, I also find GNU code to be… complicated
2023-05-01 13:53:50 -0400 < wasamasa> but according to random people on the internet, scheme is a ninja language
2023-05-01 13:54:14 -0400 < sham1> Nah, the real rockstar ninja language is JavaScript, which is just a Scheme anyway /s
2023-05-01 13:54:20 -0400 < wasamasa> gotem
2023-05-01 13:54:42 -0400 < lechner> i still remember calling the Microsoft 1-800 help line for another computer in my robotics lab while writing my first Linux device driver. GNU is a product of that time. Meanwhile, large corporations offered peace based on the Expat license, but they are milking the free software universe
2023-05-01 13:54:47 -0400 < sham1> But yeah, I sometimes wear my C hat, and if I for example look at glibc, I do shudder a bit just because of how convoluted it all is
2023-05-01 13:55:02 -0400 < lechner> all granted, but i prefer complicated source code to not having any
2023-05-01 13:55:24 -0400 < lechner> C is on the way out, though
2023-05-01 13:55:30 -0400 < sham1> Like I get it, it's legacy code, but still
2023-05-01 13:56:47 -0400 < Zipheir> It's going to take a long time to push C the rest of the way out the door.
2023-05-01 13:57:18 -0400 < lechner> you may be underestimating the zeal of the world's Rusters
2023-05-01 13:57:33 -0400 < Zipheir> Perhaps.
2023-05-01 13:57:49 -0400 < johnjaye> Zipheir: if you're dissatisfied with guix then i will take that into account. what did you try to use it for.
2023-05-01 13:58:17 -0400 < johnjaye> i assume you disagree with it being "a lisp machine"?
2023-05-01 13:59:21 -0400 < Zipheir> johnjaye: Take what I said with a grain of salt. I've looked through the source and haven't used it for much of anything.
2023-05-01 13:59:47 -0400 < Zipheir> I was interested in comparing with Nix at some point, but I don't have much use for either at  the moment.
2023-05-01 14:00:13 -0400 < Zipheir> I guess it's more like another scsh than a Lisp machine.
2023-05-01 14:01:38 -0400 < johnjaye> i didn't even use scsh
2023-05-01 14:01:48 -0400 < johnjaye> although i recall finding a scheme window manager that used circular menus. that was cool
2023-05-01 14:02:51 -0400 < Zipheir> A Scheme window manager? I didn't know there was one.
2023-05-01 14:03:30 -0400 < lechner> yeah, it's called guile-wm, but after a short love affair i was back at EXWM
2023-05-01 14:03:58 -0400 < lechner> In Guix, unprivileged users can install software using the normal package manager (i.e no Flatpak). Everyone can run different versions
2023-05-01 14:04:31 -0400 < lechner> Plus, losing a machine means another can be cloned in two minuts
2023-05-01 14:05:36 -0400 < lechner> And, "Guix Home" provides the same environment in all login shells
2023-05-01 14:05:52 -0400 < lechner> on any machine
2023-05-01 14:07:04 -0400 < johnjaye> Zipheir: i can't remember the name exactly but yes it had circular menus and was in scheme. i like circular menus. they're popular in bioware games like mass effect.
2023-05-01 14:08:10 -0400 < jcowan> Dr. Google tells me that as of 2000, Debian had 40 million SLOC in C, and it can only have gotten bigger (and probably more disproportionate) since then
2023-05-01 14:08:26 -0400 < jcowan> It will take a loooooong time to rewrite all that in Rust.
2023-05-01 14:09:54 -0400 < johnjaye> that's also assuming rust is just objectively better (TM)
2023-05-01 14:10:14 -0400 < johnjaye> which it might be. but that's not necessarily enough to mean something should be replaced with something else. the transition cost might be too massive
2023-05-01 14:10:44 -0400 < sham1> Besides, C has both a standard *and* an ABI
2023-05-01 14:11:05 -0400 < johnjaye> is that a reference to the article I posted about C being not a language but also an unstable ABI?
2023-05-01 14:11:33 -0400 < sham1> Of course, nothing is stopping Rust from getting an ABI of its own, but a problem with the language is that it only really has one implementor, who changes things with impunity
2023-05-01 14:11:57 -0400 < sham1> I mean, there was that whole debacle with trademarking the language
2023-05-01 14:12:20 -0400 < lechner> i'm not sure things are easier in the multi-homed world of Scheme
2023-05-01 14:12:59 -0400 < sham1> Well Scheme has multiple implementations. So does CL for example
2023-05-01 14:13:05 -0400 < Zipheir> ABI compatibility is a massive pain.
2023-05-01 14:13:09 -0400 < lechner> talking about costs (of being divided...)
2023-05-01 14:13:28 -0400 < nomagno> ABI and functional programming don't mix, as a rule of thumb
2023-05-01 14:13:38 -0400 < sham1> I'd say that the costs are outweighed by the benefits
2023-05-01 14:14:01 -0400 < Zipheir> e.g. LibreSSL is better™, but the OpenSSL ABI is highly Procrustean.
2023-05-01 14:14:06 -0400 < nomagno> Most operating systems and ISAs work within the bounds of the imperative paradigm, after all
2023-05-01 14:14:25 -0400 < Zipheir> nomagno: Why functional, specifically?
2023-05-01 14:14:58 -0400 < nomagno> Zipheir: The idea of functions as first-class objects runs extremely counter to the execution model of modern processors
2023-05-01 14:15:13 -0400 < nomagno> And of most processors ever produced
2023-05-01 14:15:19 -0400 < Zipheir> Really?
2023-05-01 14:15:23 -0400 < nomagno> And the ABI kind of works at the machine code level
2023-05-01 14:15:27 -0400 < nomagno> Zipheir: really.
2023-05-01 14:15:52 -0400 < Zipheir> I'd like to understand that better.
2023-05-01 14:16:30 -0400 < Zipheir> I can't see how first-class procedures even exist at the machine language level.
2023-05-01 14:16:46 -0400 < sham1> Well a lot of the effort of compiling functional languages is spent in lowering the functional language down to an imperative representation. With all kinds of tricks like lambda lifting and the like
2023-05-01 14:18:13 -0400 < johnjaye> i mean in a way that's true of everything right
2023-05-01 14:18:27 -0400 < johnjaye> everything has to be executed on a cpu. so everything is translated to imperative instructions
2023-05-01 14:18:43 -0400 < johnjaye> there is no FPU or Function Processing Unit
2023-05-01 14:18:56 -0400 < Zipheir> sham1: Right.
2023-05-01 14:18:57 -0400 < sham1> Like yeah, sure. C is a high level language after all, and it also has to be lowered. But for a FP language you do even more on average
2023-05-01 14:19:40 -0400 < sham1> For example, most if not all FP languages are made up of expressions, while machine code is blocks of instructions. Now, with imperative code you also get expressions, but you also do statements most of the time
2023-05-01 14:19:54 -0400 < Zipheir> I remember Wirth writing that "implementing stateless programming on a stateful machine is a strange idea, and there are heavy costs to be paid in hardware", but I rather thought that was FUD.
2023-05-01 14:20:05 -0400 < sham1> Even if the statements are represented as being technically expressions that return a unit type, like with Rust incidentally
2023-05-01 14:21:17 -0400 < Zipheir> If first-class procedures are hard for processors, then are function pointers?
2023-05-01 14:21:27 -0400 < Zipheir> I find that hard to believe.
2023-05-01 14:21:30 -0400 < johnjaye> if a machine was designed to execute lisp as efficiently as possible how different would it look?
2023-05-01 14:21:30 -0400 < lechner> hah
2023-05-01 14:21:34 -0400 < lechner> hah
2023-05-01 14:21:35 -0400 < Zipheir> Yet they are quite similar.
2023-05-01 14:21:37 -0400 < lechner> haha
2023-05-01 14:22:03 -0400 < nomagno> jounjaye: introducing THE 90s
2023-05-01 14:22:17 -0400 < johnjaye> i thought that was serenityOS. the 90s OS.
2023-05-01 14:22:30 -0400 < nomagno> I've actually not looked into lisp machines's architecture
2023-05-01 14:22:39 -0400 < nomagno> https://en.m.wikipedia.org/wiki/Lisp_machine
2023-05-01 14:22:42 -0400 < sham1> Well a function point is usually just an address, just like a memory address since we live in a von Neumann world
2023-05-01 14:22:46 -0400 < nomagno> I reckon they have some interesting stuff
2023-05-01 14:23:27 -0400 < Zipheir> johnjaye: The SICP lectures include a slide of a microcode LISP chip. I don't remember the details.
2023-05-01 14:23:28 -0400 < sham1> It's just not an immediate address within the instruction but it instead just gets loaded from the relevant register
2023-05-01 14:27:10 -0400 < Zipheir> johnjaye: The great hope of functional (and relational) programmers has always been that someone would build an architecture optimized for this kind of programming.
2023-05-01 14:27:43 -0400 < Zipheir> It did happen for Prolog: the Fifth Generation project.
2023-05-01 14:34:33 -0400 < johnjaye> what were the 1-4 generations? and why did prolog 4 time travel a thousand years into the past?
2023-05-01 14:35:53 -0400 < Zipheir> johnjaye: See the "Background" section of this. https://en.wikipedia.org/wiki/Fifth_Generation_Computer_Systems
2023-05-01 14:36:46 -0400 < Zipheir> ENIAC was a first-generation computer, by their reckoning. They took a very grand perspective.
2023-05-01 14:42:19 -0400 < johnjaye> interesting.
2023-05-01 14:42:39 -0400 < johnjaye> so vaccuum tubes, transistors, integrated circuits, and finally microprocessors
2023-05-01 20:31:08 -0400 < mdhughes> A function in ASM is just an address and convention of arguments to pass. When I wrote 6502 I mostly treated it as a stack language, since it only has 3 8-bit registers; 68000 I treated like C.
2023-05-01 20:31:51 -0400 < mdhughes> But if you write a few macros and a consistent calling convention, your ASM can be mostly functional.
2023-05-01 20:34:32 -0400 < mdhughes> I've been relearning Z80, and I haven't decided what style to use. Some of that'll depend on the macro assembler. It has a bunch of registers, so it can be procedural easily.
--- Log closed Mon May 01 22:22:54 2023
--- Log opened Mon May 01 23:15:17 2023
2023-05-01 23:15:17 -0400 -!- Irssi: #scheme: Total of 193 nicks [0 ops, 0 halfops, 0 voices, 193 normal]
2023-05-01 23:15:17 -0400 -!- Irssi: Join to #scheme was synced in 6 secs
--- Day changed Tue May 02 2023
--- Log closed Tue May 02 00:16:12 2023
--- Log opened Tue May 02 03:09:05 2023
2023-05-02 03:09:05 -0400 -!- Irssi: #scheme: Total of 195 nicks [0 ops, 0 halfops, 0 voices, 195 normal]
2023-05-02 03:09:05 -0400 -!- Irssi: Join to #scheme was synced in 6 secs
2023-05-02 04:43:31 -0400 < mdhughes> One thing I'd like to see in SRFIs is a practical example of use. There's usually unit tests in the repo, but often it's hard to see what it does, why you'd use it, and how.
2023-05-02 04:43:50 -0400 < mdhughes> Sometimes there's one in the mail thread, but nobody has time to dig thru that.
2023-05-02 04:46:09 -0400 < mdhughes> Doesn't have to be interesting, just feed some plausible data through it, not just ("a" "b" "q"), and display some results at the end. 80% code coverage would be fine, not every feature & switch.
2023-05-02 04:46:53 -0400 < mdhughes> Because I was just looking at https://srfi.schemers.org/srfi-153/srfi-153.html
2023-05-02 04:48:35 -0400 < mdhughes> And OK, it's a functional set builder, but A) have to go into another SRFI to figure out comparators, B) the accumulate example is preposterous. It's 10 lines to do an iota.
2023-05-02 04:48:48 -0400 < mdhughes> So surely that's not what it's for.
2023-05-02 08:50:44 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-02 12:54:03 -0400 < Zipheir> mdhughes: True, it's not a practical example, although it is fine a way to write a set-iota procedure. Can you suggest a short, more practical use? (It's an example I wrote for SRFI 224, in substance.)
2023-05-02 12:54:42 -0400 < Zipheir> I still think it's useful to have a very simple example of a complicated procuder.
2023-05-02 12:54:45 -0400 < Zipheir> *procedure
2023-05-02 12:55:41 -0400 < Zipheir> You can generalize from a trivial example, but you can't generalize from a long, concrete one.
2023-05-02 12:59:05 -0400 -!- dstein64- is now known as dstein64
2023-05-02 13:01:16 -0400 < Zipheir> Perhaps an example of building a free-variable set for a Scheme expression would be nice.
2023-05-02 13:03:14 -0400 < Zipheir> But those have no obvious ordering; you'd use vanilla sets.
2023-05-02 13:37:11 -0400 < cow_2001> groan. i thought it'd be trivial. something i'm doing is wrong.
2023-05-02 17:18:42 -0400 -!- Irssi: No bans in channel #scheme
2023-05-02 20:41:37 -0400 < johnjaye> do the regular expressions in scheme have features like set intersection which most other implementations do not have?
2023-05-02 20:41:47 -0400 < johnjaye> I recall vaguely someone telling me this.
2023-05-02 20:55:48 -0400 < jcowan> johnjaye: Not arbitrary intersection.  However, intersection of character sets is available.
2023-05-02 22:38:02 -0400 < mdhughes> A dictionary builder is a good use, take some text, put the words into an ordered set (of course in reality you'd use a hashtable for a histogram). Or I could use an ordered set to arrange sprites in draw order by point/Z-layer.
2023-05-02 22:58:02 -0400 < johnjaye> hmm. i'd have to look at the srfi again but i thought it was better than all the other ones in that it was more true to the mathematical formalism.
--- Day changed Wed May 03 2023
2023-05-03 00:08:07 -0400 -!- ns121 is now known as ns12
2023-05-03 13:05:29 -0400 -!- Netsplit *.net <-> *.split quits: buhman, Kooda, polyrob, kori, Spawns_Carpeting, Lulu
2023-05-03 13:06:00 -0400 -!- Netsplit over, joins: Kooda
2023-05-03 13:07:08 -0400 -!- polyrob_ is now known as polyrob
--- Day changed Thu May 04 2023
2023-05-04 03:51:10 -0400 -!- Netsplit *.net <-> *.split quits: madage, ec
2023-05-04 03:52:13 -0400 -!- Netsplit over, joins: madage, ec
2023-05-04 07:59:59 -0400 < seninha> Hi, i noticed that in some implementations, a pair is mutable while in other it isn't. what is the advantage of having immutable objects?
2023-05-04 08:00:11 -0400 < seninha> Like, in gambit, `(define a '(1 2)) (set-car! a 3)` runs fine
2023-05-04 08:00:39 -0400 < seninha> But in chibi-scheme it fails with "ERROR on line 1: set-car!: immutable pair: (1 2)"
2023-05-04 08:02:01 -0400 < seninha> Also, what are the practical consequences of having both mutable and immutable objects?
2023-05-04 08:06:45 -0400 < dpk> in all standard Schemes, pairs are mutable, but literals may be immutable
2023-05-04 08:07:04 -0400 < dpk> Racket and some other non-standard Schemes have made all pairs immutable
2023-05-04 08:07:56 -0400 < dpk> the practical consequences work out to this being a not particularly great decision on the part of Scheme’s designers, but we’re kind of stuck with it
2023-05-04 08:08:24 -0400 < dpk> you can’t safely call mutating procedures on unknown input because it might be an immutable literal
2023-05-04 08:08:38 -0400 < seninha> is there any advantage for a designer to chose to deal with literals differently?
2023-05-04 08:08:52 -0400 < seninha> i see
2023-05-04 08:08:56 -0400 < dpk> also there’s no way to find out if something is immutable without trying to mutate it
2023-05-04 08:09:28 -0400 < dpk> except even then there’s no way to actually tell that the immutability of the object is why the operation actually failed
2023-05-04 08:10:16 -0400 < dpk> allowing literals to be immutable makes certain compiler optimizations possible
2023-05-04 08:10:56 -0400 < seninha> i'm (for the third time) trying to continue working on my own scheme-like lisp implementation, and I'm pondering whether should i deal with mutability or keep pairs mutable.
2023-05-04 08:11:29 -0400 < dpk> if you don’t care about RnRS compatiblility, personally, i’d make all pairs immutable
2023-05-04 08:11:55 -0400 < seninha> I started this project 2 years ago and am often giving up
2023-05-04 08:13:54 -0400 < seninha> last time i gave up because of a bad premature optimization decision that complicated all the code
2023-05-04 08:14:30 -0400 < seninha> i tried to use tagged pointers to distinguish a pair from immediates (bool, integer, etc)
2023-05-04 08:14:56 -0400 < seninha> but things got too complex
2023-05-04 08:15:12 -0400 < seninha> (i'm implementing it in C btw)
2023-05-04 08:16:29 -0400 < seninha> well, i'll make everything mutable for now, since i do not expect to optimize the compilation prematurelly
2023-05-04 08:17:36 -0400 < seninha> either pairs, strings and vectors
2023-05-04 08:18:26 -0400 < seninha> in gambit even string literals are mutable: (define s "asdf")(string-set! s 0 #\z)(display s) => "zsdf"
2023-05-04 08:19:28 -0400 < seninha> weird: in chibi string literals are also mutable
2023-05-04 08:19:33 -0400 < seninha> but pair/list literals are not
2023-05-04 08:35:20 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-04 10:34:46 -0400 -!- yewscion is now known as Guest9223
2023-05-04 10:34:46 -0400 -!- yewscion_g is now known as yewscion
--- Log closed Thu May 04 13:00:37 2023
--- Log opened Thu May 04 13:01:32 2023
2023-05-04 13:01:32 -0400 -!- Irssi: #scheme: Total of 190 nicks [0 ops, 0 halfops, 0 voices, 190 normal]
2023-05-04 13:01:33 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
--- Day changed Fri May 05 2023
2023-05-05 15:05:49 -0400 < tomhg> Hey #scheme! Reading https://mnieper.github.io/scheme-macros/README.html#orgbd0169d . There he uses `(values)` (ch. 4.2) to - I guess - omit a return value. So I checked for `(equal?/eq? #!void (values)) ; => #false` and the R5RS spec what the return value would be without arguments. So what is the return value of `(values)`?
2023-05-05 15:07:02 -0400 < gwatt> tomhg: It's not specified how multiple values are to be implemented. The only meaningful answer is that it's `(values)`
2023-05-05 15:09:57 -0400 < tomhg> gwatt: I see. Mistery of an implementation I suppose! Thank you!
2023-05-05 15:11:07 -0400 < gwatt> I think several schemes implement values as list with a unique car.
2023-05-05 15:12:28 -0400 < tomhg> but probably not within the scheme-code of the implementation. Because then they would need to handle the "null"-case as well..
2023-05-05 15:13:02 -0400  * tomhg stops talking. He only used gambit for now.
2023-05-05 15:24:53 -0400 < edgar-rft> the purpose of having multiple-values is to avoid unneccessary consing, implementing multiple values by consing-up a list is umm... I don't know how to say this politely
2023-05-05 15:45:07 -0400 < dpk> the purpose of multiple values is to semantically correctly represent operations which have multiple results ;-)
2023-05-05 15:45:17 -0400 < dpk> like integer division which gives a quotient and remainder
2023-05-05 15:45:55 -0400 < dpk> or square roots which have a positive and negative part, though Scheme's sqrt doesn't bother with that
2023-05-05 15:48:19 -0400 < acdw> that's rude
2023-05-05 16:01:05 -0400 < gwatt> Doesn't every nth-root operation, where n is even have n results? So you don't just have multiple result sets, you have variadic result sets.
2023-05-05 16:05:43 -0400 < acdw> yes
2023-05-05 16:05:48 -0400 < acdw> just watched a utube vid on that
2023-05-05 16:12:49 -0400 < sham1> Doesn't need to be an even n
2023-05-05 16:13:52 -0400 < sham1> Since numbers in Scheme are complex, we can say that x^n = a has n solutions, and so an n-root returns n values
2023-05-05 16:15:19 -0400 < gwatt> What are the 3 cubic roots of 1?
2023-05-05 16:15:47 -0400 < acdw> 8
2023-05-05 16:16:00 -0400 < sham1> gwatt: three roots of unity
2023-05-05 16:16:25 -0400 < sham1> All 120° apart from each other on the unit circle such that one of them is 1
2023-05-05 16:18:27 -0400 < sham1> But since we usually only ever care about the principal root, the cubic root of 1 would return 1
2023-05-05 16:29:08 -0400 < gwatt> sham1: fair enough. I don't think I've heard of that before.
2023-05-05 16:33:12 -0400 < Zipheir> I think that's a corollary of the Fundamental Theorem of Algebra?
2023-05-05 16:34:44 -0400 < Zipheir> tomhg: gwatt already mentioned that (values) is just (values), but #!void isn't in any Scheme standard. Thus it's a matter of how Gambit interprets 'values'.
2023-05-05 16:35:08 -0400 < Zipheir> I think it would be odd for (values) to be equal to any object.
2023-05-05 16:35:41 -0400 < Zipheir> (Unless that's in the sense of eq?'s Wild-West semantics.)
2023-05-05 16:36:18 -0400 < Zipheir> Er, no. eq? can only deviate by saying things aren't equal.
2023-05-05 16:42:48 -0400 < tomhg> Zipheir: gwatt made clear that `(values` may be implemented outside the scheme-level of gambit. A quick search through gambit's source didn't prompt any result for `define-syntax values` either. So my "search" for the return value of `(values)` come to an end. Intersting usage/trick, though :o)
2023-05-05 16:43:33 -0400 < Zipheir> tomhg: Yes.
2023-05-05 16:43:53 -0400 < Zipheir> tomhg: Some people have suggested that returning no values is better than returning #f.
2023-05-05 16:44:13 -0400 < Zipheir> While that may be good semantics, it's clumsy to handle in current Scheme.
2023-05-05 16:44:46 -0400 < Zipheir> Oh, I mean returning no values instead of #f from a procedure that can fail.
2023-05-05 16:50:18 -0400 < tomhg> jupp. I did found it interesting that `(eq? #!void (if (> 1 2) #f)) ;=> #t` but replacing `(if ...)` with `(values)` wasn't working as expected. I do check sometimes for #!void; But this may not be necessary in the future for me. Don't know yet.
2023-05-05 16:51:46 -0400 < Zipheir> tomhg: It's because (if #f #f) is required to return just one value.
2023-05-05 16:52:11 -0400 < Zipheir> (Any value, but one value it must be.)
2023-05-05 16:57:25 -0400 < tomhg> I see. Don't understand why the expression has to return anything since I am not aware of a check for "expression executed successfully" from the read RnRS specs yet.
2023-05-05 16:58:45 -0400 < tomhg> But like you said: I had one occurence to check if the expression returned #!void or my exception-catcher inserted an #f, though. But that was probably bad code. Still undermining my Q2 tasks..
2023-05-05 17:00:47 -0400 < Zipheir> Most continuations in Scheme expect one value. If (if #f #f) evaluated to no values, then it would probably cause an error in normal contexts.
2023-05-05 17:02:09 -0400 < Zipheir> In practice, though, it doesn't seem to be a problem. Most implementations seem fine with zero-value expressions in odd places.
2023-05-05 17:02:27 -0400 < Zipheir> (I just ran (begin (values) 1) through a few different REPLs.)
2023-05-05 17:03:49 -0400 < sham1> Well it could be said that the non-tail expressions of begin are run with continuations that receive any number of arguments and just discard them
2023-05-05 17:05:38 -0400 < Zipheir> I suppose so.
2023-05-05 17:05:45 -0400  * Zipheir checks the report semantics.
2023-05-05 17:06:21 -0400 < sham1> I mean, that's how it's done in the "implementation" at the end of R7RS, where begin is implemented in terms of nested call-with-values
2023-05-05 17:07:24 -0400 < tomhg> Why? a begin inherits the continuation and the only important value is the return value at tail position. How does call-with-values get relevant here?
2023-05-05 17:08:19 -0400 < sham1> By the induction that (begin a rest ...) <=> (call-with-values a (lambda ignored (begin rest ...)))
2023-05-05 17:08:35 -0400 < sham1> With the base case that (begin a) <=> a
2023-05-05 17:09:09 -0400 < Zipheir> tomhg: Every expression in a (begin ...) except the last has a continuation that discards the values it receives.
2023-05-05 17:09:25 -0400 < Zipheir> Bah, I am out of shape for the R7RS denotational semantics.
2023-05-05 17:09:34 -0400 < gwatt> How does that transformation work with definitions?
2023-05-05 17:11:09 -0400 < tomhg> `(begin a rest ...) <=> `(lambda () a rest ...)` should be sufficient, shouldn't it?
2023-05-05 17:12:03 -0400 < tomhg> It would align with gwatt's question as well, I think.
2023-05-05 17:12:48 -0400 < Zipheir> sham1: You must be right about begin. The specs say nothing about the co-arity of the expressions in a begin, and the values of the last must be returned.
2023-05-05 17:13:06 -0400 < sham1> Sure, but that's a bit circular to use the lambda's body like that
2023-05-05 17:13:24 -0400 < Zipheir> (And it would be a major wart if only the last expression of a begin could have multiple values.)
2023-05-05 17:14:13 -0400 < Zipheir> You can implement lambda in terms of begin, or vice-versa.
2023-05-05 17:14:35 -0400 < Zipheir> Er, "using", not "in terms of".
2023-05-05 17:19:27 -0400 < tomhg> I think my initial, simple understanding is confused with thinks I read about normalization. Sorry. But what does "circular" mean here?
2023-05-05 17:19:33 -0400 < tomhg> *things
2023-05-05 17:20:36 -0400 < tomhg> to me a `(lambda` has become innocent :)
2023-05-05 17:21:40 -0400 < sham1> It means that when you're implementing begin with lambda like that, you still need to somehow do the behaviour of the non-tail expressions being in continuations that discard all the delivered values
2023-05-05 17:23:07 -0400 < Zipheir> No, because a lambda body has the same semantics as a begin.
2023-05-05 17:23:29 -0400 < tomhg> That relates to Zipheirs suggestion that begin can be implemented using lambda and vice versa. But I don't see how.
2023-05-05 17:23:33 -0400 -!- greaser|q is now known as GreaseMonkey
2023-05-05 17:23:35 -0400 < Zipheir> More or less. If you've implemented (lambda () e1 e2 ...) correctly, then you've already got begin figured out.
2023-05-05 17:24:48 -0400 < Zipheir> Conversely, you can implement the simple Church lambda whose body is one expression, and then insert an "implicit" begin.
2023-05-05 17:26:20 -0400 < tomhg> Zipheir: Where the implicit begin is the only position where definitions are allowed; Then a recuring to a "restricted" lambda, right?
2023-05-05 17:27:26 -0400 < Zipheir> I was ignoring definitions. That is a bit more complicated, but yes, I think you've got it.
2023-05-05 17:28:16 -0400  * tomhg is thankfully to have been allowed to participate.
2023-05-05 17:36:35 -0400 < sham1> Why would you be forbidden
2023-05-05 17:57:34 -0400 < Zipheir> You must be a member of the Knights of the Lambda Calculus or the Church of the Least Fixed Point to discuss Scheme here. :)
2023-05-05 18:01:17 -0400 < tomhg> my afk-message contains invalid grammar. And then there these topics which are bespicked with hard terms I do not research in time. Learned this today as well: Take my time to research unfamiliar terms!!
2023-05-05 18:11:23 -0400 < tomhg> English can be weird. It can be understood through tough thorough thought, though. (learned this meanwhile; and experienced much more.) *waveshands*
2023-05-05 18:23:41 -0400 < Zipheir> tomhg: English spelling is insane. The standard joke is that 'fish' can be spelled 'ghoti' in English.
--- Day changed Sat May 06 2023
2023-05-06 03:49:07 -0400 < cow_2001> i'm skipping some exercises
2023-05-06 04:12:45 -0400 < cow_2001> concurrency
2023-05-06 06:19:31 -0400 < tomhg> :D
2023-05-06 08:18:54 -0400 < cow_2001> The structure and interpretation of computer programs have been a disaster for the human race.
2023-05-06 08:20:08 -0400 < cow_2001> iuno. just thought it would be funny to put that in that unabomber manifesto template. sorry.
2023-05-06 08:55:00 -0400 < cow_2001> i think Paul is embezzling money from his shared Bank1 account with Peter, moving funds to his own Bank2 account.
2023-05-06 12:21:53 -0400 -!- mdhughes_ is now known as mdhughes
2023-05-06 13:27:58 -0400 < tomhg> unfortunately the macro system introduces me to a whole new level of complexity. And my implementation comes in the way as well. Anyhow - *continues*
2023-05-06 13:28:21 -0400 < Zipheir> tomhg: Which macro system are you using?
2023-05-06 13:29:45 -0400 < tomhg> Zipheir: Mniepers tutorial requires R6RS. But gambit is not fully compliant here. So I try to work around. Success is limited, though.
2023-05-06 13:29:59 -0400 < Zipheir> Ah. syntax-case, I guess.
2023-05-06 13:30:09 -0400 < tomhg> e.g.: I can not use quasisyntax; Besides beeing defined and used in the gambit source code.
2023-05-06 13:44:38 -0400 < Zipheir> tomhg: This is why I stay with syntax-rules unless I really have to use something stronger.
2023-05-06 13:46:51 -0400 < tomhg> I agree. I can not build on mniepers parser-generator anyway. So I may start from scratch :o). But first I will finish the read!
2023-05-06 13:48:13 -0400 < tomhg> But I am a little bit sad to not getting the fluid-let to run. This is exactly one part I was interested in the last year.
2023-05-06 15:38:21 -0400 < tomhg> I won't. I would create all CFGs on my own, create a lexer and a parser generator. I am just one person so I just decided on omitting this. My efforts prior were useless now. Hmpf.
2023-05-06 19:07:15 -0400 -!- Netsplit *.net <-> *.split quits: fadein, f8l, yosafbridge, wasamasa, _________, xelxebar, aeth, jurassic, deltab, gnomon,  (+2 more, use /NETSPLIT to show all of them)
2023-05-06 19:07:29 -0400 -!- Netsplit over, joins: hrberg, jurassic, deltab, fadein
2023-05-06 19:07:53 -0400 -!- Netsplit over, joins: gnomon, f8l
2023-05-06 21:20:34 -0400 < lockywolf> tomhg: are you writing your own Scheme now?
2023-05-06 23:53:48 -0400 < daviid> out of curiosity - never used cut (yet), but i thought i could, in this code - https://paste.debian.net/1279546/ - replacing the lambda using (cut string-drop str (1+ <>)), which we can't - i wonder [didn't look at the code] how difficult it would be to enhance cut to support 'slot-with-expr' ...
--- Day changed Sun May 07 2023
2023-05-07 01:43:37 -0400 < lockywolf> Has someone managed to use snow-chibi without an image?
2023-05-07 01:43:40 -0400 < lockywolf> hangs on my machine
2023-05-07 08:44:23 -0400 < tomhg> lockywolf: felt like it but no. I just want to parse and interpret multiple PL with Scheme.
2023-05-07 08:47:37 -0400 < lockywolf> tomhg: you want to write a #lang ?
2023-05-07 08:48:52 -0400 < tomhg> That's a Racket DSL, right?
2023-05-07 08:51:13 -0400 < tomhg> lockywolf: I currently parse Java, C, Python and Scheme via a library. It would be cool to replace this library but I am not capable of doing this yet. I could live with some missing features but it's too hard to parse the Syntax
2023-05-07 09:05:56 -0400 < tomhg> But yesterday I stumbled upon a paper which could be interesting in my future. Don't know yet. It is called "Packrat Parsing: Simple, Powerful, Lazy, Linear Time" by Bryan Ford.
2023-05-07 13:01:18 -0400 < Zipheir> tomhg: Packrat is overrated, in my humble opinion. Its memory use can explode, although there are tricks to get around that.
2023-05-07 13:05:19 -0400 < sham1> I'm personally a believer in the good old recursive descent and pratt parsing if I need infix
2023-05-07 13:07:50 -0400 < Zipheir> Pratt is interesting, and recursive descent is fine when you can use it. I also agree with Wirth that LL(k) languages are easiest for *human* parsers and thus better. But LALR(1) generators are still great tools; no other current approach provides ambiguity checking.
2023-05-07 13:14:05 -0400 < sham1> Recursive descent seems to have better error messages on average, from what I've noticed
2023-05-07 13:14:58 -0400 -!- Netsplit *.net <-> *.split quits: zwr, avocadoist, hugo, msavoritias
2023-05-07 13:14:58 -0400 -!- msavoritias_ is now known as msavoritias
2023-05-07 13:15:33 -0400 -!- Netsplit over, joins: avocadoist
2023-05-07 13:19:08 -0400 < Zipheir> tomhg: There is a Packrat parser entirely in CHICKEN Scheme. I hope your Lojban's pretty good. :) https://github.com/alanpost/genturfahi
2023-05-07 13:20:36 -0400 < sham1> why
2023-05-07 13:20:44 -0400 < sham1> Why is it in lojban
2023-05-07 13:21:11 -0400 < Zipheir> I believe the author was working on a full Lojban parser (and translator?) but didn't get around to it.
2023-05-07 13:21:36 -0400 < Zipheir> As to why it's *all* in lojban (including comments)...
2023-05-07 13:22:00 -0400 < Zipheir> I'm reminded of the Esperantists who refuse to speak "nationalist" natural languages.
2023-05-07 13:23:24 -0400 < Zipheir> OK, the comments are in English.
2023-05-07 13:48:14 -0400 < sham1> Estas tre stulta tio…
2023-05-07 13:49:38 -0400 < sham1> I get annoyed when I find ancient code at work which is in Finnish because that's just annoying. When I'm programming, identifiers and such just have to be in English. There's no other way
2023-05-07 13:50:41 -0400 < msavoritias> i wish i didnt have to use only english :/
2023-05-07 14:03:28 -0400 < Zipheir> I suspect people in the not-too-distant future are going to find ancient code in English and think "why??"
2023-05-07 14:04:13 -0400 < Zipheir> With Unicode support in programming languages becoming more common, I think people will use names that are most familiar for them.
2023-05-07 14:04:28 -0400 < msavoritias> i hope so too
2023-05-07 14:09:20 -0400 < sham1> Maybe
2023-05-07 14:16:13 -0400 < tomhg> My employer is Germany. Everything has to be written in German. Including variables.. So "private final AutomatischerMitteilungsaustauschFabrik;" is a thing... And German in particular is aweful for this.
2023-05-07 14:16:45 -0400 < tomhg> Funny gem: Obviously "StrafnachrichtVorabeintrag" und "VorabeintragStrafnachricht" are two completely different things.. Whatever :)
2023-05-07 14:17:39 -0400 < tomhg> REgarding parsing techniques... Gee, thanks. I append them together with the "dragon book" to my reading list. Any someday I may participate with my own opinions.
2023-05-07 14:28:42 -0400 < Zipheir> The Dragon Book loves LALR parsing. Or at least the first edition does. That's the one with a knight on the front cover whose lance is labelled "LALR parser generator". The dragon is, of course, labelled "complexity of compiler design".
2023-05-07 14:29:35 -0400 < Zipheir> Those German examples are amazingly verbose.
2023-05-07 14:29:51 -0400 < Zipheir> But English names get very long, too.
2023-05-07 14:36:05 -0400 < sham1> Two things that are famously difficult: naming things, cache invalidation and off-by-one errors
2023-05-07 14:41:40 -0400 < Zipheir> I'm still surprised that camel case remains popular. IIRC there have been many studies showing it less readable than the alternatives.
2023-05-07 14:43:05 -0400 < Zipheir> Hmm, the data looks less conclusive than I thought.
2023-05-07 14:47:49 -0400 < Guest5> any examples of syntax-case macros that uses rib-cages?
2023-05-07 14:56:44 -0400 < tomhg> I fall in love with naming-conventions-scheme. And decided i like `byte-start` over `start-byte`.. *confusedmumbling*
2023-05-07 15:20:13 -0400 < acdw> obviously the only fair thing is to only use emoji identifiers
2023-05-07 15:29:27 -0400 < sham1> I like `byte-start` since it's type-method like naming
2023-05-07 16:10:14 -0400  * dpk wonders what Guest5 meant by rib-cages in syntax-case
2023-05-07 16:10:41 -0400 < wasamasa> I dimly recall that being a thing
2023-05-07 16:51:16 -0400 < tomhg> sham1: took me a while
2023-05-07 21:26:25 -0400 -!- grettke_ is now known as grettke
2023-05-07 22:36:54 -0400 < lockywolf> Unicode is evil, but unicode in program code is eviler
2023-05-07 22:37:28 -0400 < lockywolf> ⚻🖤
2023-05-07 22:37:53 -0400 -!- grettke is now known as grettke_
2023-05-07 22:37:53 -0400 < lockywolf> everything should be in 7-bit ASCII
2023-05-07 22:38:34 -0400 < acdw> hmmmm
2023-05-07 22:39:12 -0400 < lockywolf> you can identify code written by Russian schoolkids with 100% accuracy, because it will have for(int schetchik = 0; schetchik < predel ; ++schetchik )
2023-05-07 22:39:36 -0400 < lockywolf> and various other Russian words written in translit
2023-05-07 22:40:05 -0400 < CodeSpelunker> :)
2023-05-07 22:41:19 -0400 < lockywolf> seeing the same thing, but written in actual cyrillic in the code would just make my eyes blow
2023-05-07 22:41:56 -0400 < CodeSpelunker> just the variables, or the syntax too?
2023-05-07 22:42:03 -0400 < lockywolf> for( int счётчик=0 ; счётчик < предел ; ++счётчик )
2023-05-07 22:42:35 -0400 < lockywolf> that is just horrible, not even mentioning the need to switch keyboard layout every ~8 characters
2023-05-07 22:43:09 -0400 < CodeSpelunker> I guess the compiler won't accept something like инт
2023-05-07 22:43:30 -0400 < CodeSpelunker> imagine writing everything in cyrillic lol
2023-05-07 22:43:36 -0400 < CodeSpelunker> wouldn't that be neat
2023-05-07 22:44:38 -0400 < lockywolf> CodeSpelunker: you can check the 1C language
2023-05-07 22:44:48 -0400 < lockywolf> it's basically Visual Basic translated into Cyrillic
2023-05-07 22:45:29 -0400 < CodeSpelunker> wow, interesting
2023-05-07 22:45:49 -0400 < lockywolf> https://buzzorange.com/techorange/wp-content/uploads/sites/2/2019/12/EL-k-zDW4AADGKD.jpg
2023-05-07 22:46:14 -0400 < lockywolf> CodeSpelunker: the "C" is a cyrillic "С", not a latin "C"
2023-05-07 22:46:42 -0400 < lockywolf> the fact that they look completely identical (pixel to pixel) doesn't help
2023-05-07 22:46:49 -0400 < CodeSpelunker> lol I see
2023-05-07 22:48:17 -0400 < lockywolf> ew, that guy, Huang, even made his Chinese to Javascript compiler obey the WenYan Chinese grammar, not BaiHua Chinese grammar
2023-05-07 22:49:07 -0400 < lockywolf> https://www.meme-arsenal.com/memes/57c9da99192c571647cf014d5b863585.jpg
2023-05-07 23:24:27 -0400 -!- grettke_ is now known as grettke
--- Day changed Mon May 08 2023
2023-05-08 00:21:41 -0400 -!- grettke is now known as grettke_
2023-05-08 11:48:32 -0400 -!- Inst_ is now known as Inst
2023-05-08 13:04:33 -0400 -!- seninha is now known as bignum_powermod
2023-05-08 13:06:13 -0400 -!- bignum_powermod is now known as seninha
2023-05-08 13:25:45 -0400 < tomhg> lockywolf: 35 written in chinese has more characters then their 700? Unexpected.
2023-05-08 14:40:05 -0400 < tomhg> So I had an idea a few weeks back I'm starting to explore. There may be the unspoken power of scheme which enables one to switch traversal-ordering by switching from CPS to tail-recursiveness. Maybe it needs seperate branching in one direction. Maybe it won't work with my stateful object; But I wanted to talk about (monologue) it for a few months.
2023-05-08 14:41:21 -0400  * tomhg started to get serious and bricked low to higher. After I read the first suggestion about A-normalization. This is the timeframe.
2023-05-08 14:44:24 -0400 < tomhg> If somebody feels that's obvious, one may supplement my brain with an example; Would be very much appreciated. I'm going for a longer walk.
2023-05-08 14:48:30 -0400 < sham1> Well, one of the points of CPS is that you're always tail-calling the next continuation, and that you "never return", which leads to a Charlie on the MTA reference, for example in the form of "Cheney on the MTA"
2023-05-08 14:57:32 -0400 < Zipheir> Of course, it's possible to use CPS without transforming *everything* to CPS.
2023-05-08 14:59:34 -0400 < Zipheir> It depends on whether tomhg is writing a compiler, an interpreter, or something else.
2023-05-08 15:01:08 -0400 < sham1> That is true, although I'd think that you lose some of the power if you don't do the full transform
2023-05-08 15:03:32 -0400 < Zipheir> What I mean is that I think the CPS transform is mainly a technique for writing interpreters & compilers, while CPS is, more generally, a way to look at algorithms.
2023-05-08 15:05:05 -0400 < Zipheir> You can see the latter trick in older Scheme programming, before 'values'. In order to write a recursive procedure returning multiple values, you'd CPS it.
2023-05-08 15:06:12 -0400 < Zipheir> (So that, where you'd now write (define (f ...) (values e1 e2)), you'd instead write (define (f ... k) (k e1 e2)).)
2023-05-08 15:06:49 -0400 < Zipheir> There's no reason to that now, but CPS still seems like good tool to pull out from time to time.
2023-05-08 15:07:42 -0400 < Zipheir> *to do that
2023-05-08 15:08:58 -0400 < Zipheir> Whereas the general CPS transform is quite detailed (https://matt.might.net/articles/cps-conversion/) and only occasionally needed.
2023-05-08 15:09:39 -0400 < Zipheir> (That complexity is, I guess, part of the recent move toward ANF.)
2023-05-08 15:43:45 -0400 < sham1> CPS is a useful pattern, although when used in code it can be sometimes a tad tricky
2023-05-08 15:59:24 -0400 < tomhg> sham1: Yes, I need to consider a secondary call-frame/continuation in order to proceed the initial recursion. Are you referring to this?
2023-05-08 16:01:53 -0400 < tomhg> Zipheir: I dont see any relevance to the origin of the program. Beeing a compiler, interpreter oder something at runtime: Why should it matter? I am seeing your comparsion to (values). Beeing not familiar to its implementation  I thought I may be able to "branch out" again into a post-order traversal. The result of the CPS application is added to the parent recursion but now "appending".
2023-05-08 16:03:54 -0400 < tomhg> The reason I am insepcting this now is that I need to update children-nodes with the parent-references while processing the tree. This would enable me to apply a lazy-stream to store everything within one transaction; Though I realized I am not able to apply CPS to stream. So I am back to a hand-written iteration.
2023-05-08 16:04:25 -0400 < Zipheir> I don't think I understand.
2023-05-08 16:05:06 -0400  * tomhg *spinspseudocode*
2023-05-08 16:05:47 -0400 < Zipheir> The reason it matters whether it's a compiler/interpreter or something else is that you only need the CPS *transform* if your program takes a program as input.
2023-05-08 16:06:18 -0400 < Zipheir> The CPS technique you can use anywhere.
2023-05-08 16:07:19 -0400 < Zipheir> For processing trees (which is what I think you're doing), you don't need the transform algorithm, of course.
2023-05-08 16:08:23 -0400 < tomhg> Okay. So marrying your two inputs is: While recursing I may switch to CPS but need to proceed normal recursion after the taken branch (by CPS). Within the CPS-application I may again start a normal recursion. That shouldn't matter because it's end is a sub-result
2023-05-08 16:09:45 -0400 < tomhg> Sorry to flood. You are right; I don't need the transformation. Though you provided me with the essence of CPS.
2023-05-08 16:16:16 -0400 < Zipheir> Don't worry about it. That sounds a bit complicated. I'll have to look at your implementation when it's ready.
2023-05-08 16:16:27 -0400 < tomhg> `(java) Member.variable.function()` is one AST-node. In order to get the correct reference to variable I have to walk upwards: `(get-procedure-from (variable (living-in Member))`. Contrary Scheme: `(procedure (variable-procedure Member))` I can already determine the declaration of `(procedure`.
2023-05-08 16:16:40 -0400 < Zipheir> Maybe I made things more confusing with all this talk of the CPS transform.
2023-05-08 16:16:41 -0400 < tomhg> I would like that. I will come here again in a few months.
2023-05-08 16:17:13 -0400 < Zipheir> Ah, OK.
2023-05-08 16:17:52 -0400 < tomhg> Thank you for your hands, honestly.
2023-05-08 16:22:22 -0400 < tomhg> one last thing. I think the algorithm whould be best written with streams; So I implemented a iterator with it before realizing I can not apply CPS to a stream when its origin is a stateful-cursor. *confusedpainting*
2023-05-08 16:23:39 -0400 < tomhg> ; that may be the reason why a lexer+parser-generator within scheme would be neat. Unable to judge yet (though I think it would aid my suffering a big-time)
2023-05-08 16:29:38 -0400 < tomhg> Oh ffs, Thanks. Regardless of recursion or CPS I am able to keep the processing-order of the stateful object in sync. I just have to write smaller procedures. *leavesandthinks*
2023-05-08 16:43:43 -0400 < sham1> Please don't leave
2023-05-08 16:43:59 -0400 < sham1> These are fascinating topics
2023-05-08 16:54:01 -0400 < tomhg> I am just not able to elaborate on my own thoughts. Won't leave ever. I own #scheme =)
2023-05-08 16:54:27 -0400 < tomhg> ... I am owning #scheme (weird language)
2023-05-08 21:22:18 -0400 < lockywolf> tomhg: is it similarly baffling that (< (length "thousand") (length "thirty five")) ?
2023-05-08 21:23:23 -0400 < flatwhatson> In procedure length: Wrong type argument in position 1: "thousand"
2023-05-08 22:21:36 -0400 < lockywolf> ah, string-length
--- Day changed Tue May 09 2023
2023-05-09 10:23:36 -0400 -!- lockywolf is now known as iockywolf
2023-05-09 10:35:35 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-09 15:11:35 -0400 < tomhg> no, not really. Guess I just assumed that Chinese is using arabic digits as well.
2023-05-09 15:11:58 -0400  * tomhg everydaylearning
2023-05-09 15:18:51 -0400 < acdw> "four" is the only number with its number of letters
2023-05-09 15:18:53 -0400 < acdw> in english
2023-05-09 15:26:06 -0400 < tomhg> the hardest number I learned written is 99 in Polish.
2023-05-09 15:26:18 -0400 < tomhg> dziewięćdziesiąt dziewięć its a tongue twister.
2023-05-09 15:28:28 -0400 < Zipheir> It's amazing to me that 95 is still "four twenties, fifteen" in French.
2023-05-09 15:29:20 -0400 < wasamasa> it's a mystery to me how mathematicians didn't let that deter them
2023-05-09 15:30:06 -0400 < acdw> you know, one is the loneliest number
2023-05-09 15:30:11 -0400 < tomhg> The pronounciation is just too good to drop.
2023-05-09 15:31:37 -0400 < wasamasa> I guess growing up with it helps
2023-05-09 15:32:40 -0400 < johnjaye> wasamasa: i once spoke to a man who read the Principia Mathematica. He said to do all of formal mathematics you don't need to count higher than 5 iirc. Looks like the Piraha were vindicated when they said they do not count above 3.
2023-05-09 15:33:49 -0400 < sham1> Zipheir: Swiss and Belgian French apparently do the ninety-five thing with nonante-cinq
2023-05-09 15:34:45 -0400 < sham1> And eighty has two "alternative" forms of huitante and octante
2023-05-09 15:37:28 -0400 < sham1> Danish also apparently has a weird way of doing those kinds of numbers
2023-05-09 15:38:28 -0400 < Zipheir> sham1: Interesting, I didn't know that.
2023-05-09 15:38:39 -0400 < tomhg> In German you change the order. 999 would be written as 900 9 and 90.
2023-05-09 15:39:12 -0400 < sham1> For example the Danish word for 50 is "halvtreds" which comes from "halvtredje-sinde-tyve" which would translate to something like "half to 3 times 20"
2023-05-09 15:39:12 -0400 < tomhg> s/written/read (when spelled)
2023-05-09 15:39:43 -0400 < tomhg> sham1: wow.
2023-05-09 15:39:43 -0400 < sham1> So it's 2.5 * 20
2023-05-09 15:40:12 -0400 < sham1> And yes, for some reason the "half to three" is 2 and a half
2023-05-09 15:42:58 -0400 < sham1> But it's interesting it's like this, because in related languages it's different. Swedish for example just uses "femtio" which is just fifty like one might expect, five ten
2023-05-09 15:44:35 -0400 < acdw> let's talk about how phone numbers are actually strings
2023-05-09 15:45:59 -0400 < tomhg> acdw: only for people how used the t9 dictionary!!
2023-05-09 15:46:04 -0400 < tomhg> like 0800 / volkswagen
2023-05-09 15:46:19 -0400 < sham1> Yes, and it annoys me that some people try to store phone numbers as integers
2023-05-09 15:46:35 -0400 < sham1> They are clearly not. They have significant leading zeros, no way that is an integer
2023-05-09 15:47:05 -0400 < acdw> yes
2023-05-09 15:47:08 -0400 < acdw> same w zip codes
2023-05-09 15:47:14 -0400 < acdw> it "looks" like a number i guess
2023-05-09 15:47:36 -0400 < acdw> tomhg: 1877kars4kids
2023-05-09 15:47:51 -0400 < acdw> oh and DL #'s and SSNs/state ids too
2023-05-09 15:47:56 -0400 < acdw> honeslty should just make all those letters
2023-05-09 15:50:38 -0400 < tomhg> acdw: *Frommemory* 1877527745537 ?
2023-05-09 15:58:50 -0400 < acdw> lol no idea
2023-05-09 16:42:11 -0400 < seninha> hi, in some places i hear the expression "to signal an error" on scheme texts and (i'm learning common lisp) in common lisp as well. What does that mean in practice? Is an "error" an object that can be somehow passed to and returned from functions like numbers or continuations?
2023-05-09 16:42:46 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-09 16:42:51 -0400 < acdw> afaik yes
2023-05-09 16:46:22 -0400 < sham1> Could be thrown at you
2023-05-09 16:46:26 -0400 < sham1> Like with raise
2023-05-09 16:57:12 -0400 < Zipheir> seninha: It depends on the report.
2023-05-09 16:57:38 -0400 < Zipheir> "It is an error" and similar language in RnRS, n ≠ 6, can mean just about anything.
2023-05-09 16:58:26 -0400 < seninha> Zipheir: i'm checking R7RS now, and it has a sction about errors and exceptions. Being introduced to scheme by sicp and restricted to r5rs implementation made me unaware of such stuff
2023-05-09 16:58:36 -0400 < Zipheir> seninha: The object that can be "passed to and returned from functions" would be a condition.
2023-05-09 16:59:06 -0400 < Zipheir> seninha: Yeah, there's very little to go on in R5 and earlier.
2023-05-09 16:59:31 -0400 < edgar-rft> in Common Lisp an error *is* a special kind of condition, not sure about Scheme
2023-05-09 16:59:37 -0400 < Zipheir> Whereas R6RS has a comprehensive condition hierarchy.
2023-05-09 17:01:06 -0400 < Zipheir> That could be true in Scheme, too. (R7RS error-object?)
2023-05-09 17:01:22 -0400 < tomhg> So what's the difference between an error and an error-condition within <r5rs (abortion of the program vs a condition?)?
2023-05-09 17:02:05 -0400 < Zipheir> In R5RS and earlier reports, there were no conditions. There wasn't even an 'error' procedure.
2023-05-09 17:02:50 -0400 < tomhg> :o)
2023-05-09 17:03:24 -0400 < Zipheir> seninha: I'm off a bit about R5.
2023-05-09 17:03:40 -0400 < Zipheir> https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs-Z-H-2.html#%_toc_%_sec_1.3.2
2023-05-09 17:04:01 -0400 < Zipheir> If "an error is signaled", it *must* be reported.
2023-05-09 17:04:19 -0400 < Zipheir> I still love R5RS.
2023-05-09 17:04:25 -0400 < acdw> it loves u
2023-05-09 17:04:55 -0400 < sham1> Is an error is essentially just how Scheme might say "is undefined behaviour"
2023-05-09 17:05:11 -0400 < Zipheir> For some reason I thought that R7 added the "is signaled" distinction to R5, but I was wrong.
2023-05-09 17:05:51 -0400 < sham1> R6 will throw stuff like assertion violations, which I like more, but at the same time I don't know whether it might make sense to instead have those checks be only for debug builds
2023-05-09 17:06:01 -0400 < tomhg> So an error is, within r7rs, a reported condition. an exception is a typed error-condition?
2023-05-09 17:07:03 -0400 < edgar-rft> I think the "is signaled" wording is copied from Common Lisp, because in Common Lisp a condition (like an error) is a signal that can be dispatched, introspected, and reacted upon
2023-05-09 17:07:20 -0400 < Zipheir> tomhg: Post-R5RS, an error *is* a kind of exception.
2023-05-09 17:08:14 -0400 < Zipheir> error-object? provides some kind of distinction between conditions raised by 'error' and everything else--maybe.
2023-05-09 17:08:17 -0400 < sham1> Well a CL condition is recoverable, no? Something that could be emulated with raise-continuable after one takes the appropriate action with the condition handler
2023-05-09 17:09:05 -0400 < Zipheir> Are all CL exceptions continuable?
2023-05-09 17:09:15 -0400 < sham1> I don't think so
2023-05-09 17:09:20 -0400 < Zipheir> OK.
2023-05-09 17:09:27 -0400 < tomhg> hehe.
2023-05-09 17:09:29 -0400 < sham1> Then again, I haven't looked at it too hard
2023-05-09 17:09:44 -0400 < edgar-rft> In CL a condition is only recoverable if a handler is provided, either builtin or user-programmed.
2023-05-09 17:10:39 -0400 < tomhg> ^ that would align with my prompt when run _not_ within a REPL (i know of)
2023-05-09 17:10:55 -0400 < edgar-rft> same is true for continueability - if such a word exists in english :-)
2023-05-09 17:13:47 -0400 < Zipheir> "Presumably this form has a pretentious mathematical name. Anyone who knows it should tell the author." (Olin Shivers in SRFI 1)
2023-05-09 17:14:17 -0400 < Zipheir> (The form was 'unfold', and the complicated name was "anamorphism".)
2023-05-09 17:16:40 -0400 < seninha> Thanks :)
2023-05-09 17:17:32 -0400 < seninha> I'm reviving my old make-your-own-lisp project and i want to deal with errors now, the REPL just abort on a parsing error for example
2023-05-09 17:21:24 -0400  * tomhg is a scheme rookie and rocks-offline..
2023-05-09 17:21:25 -0400 < Zipheir> seninha: Sounds fun.
2023-05-09 17:21:59 -0400 < Zipheir> seninha: Essentials of Programming Languages has some tips on implementing continuable exceptions.
2023-05-09 17:23:39 -0400 < seninha> Previous time i was working on it (last year) i got tangled myself with premature optimization and all the additional complexity that came with it
2023-05-09 17:23:56 -0400 < Zipheir> That can certainly happen.
2023-05-09 17:23:57 -0400 < seninha> Zipheir: thanks i'm going to look for it
2023-05-09 17:24:25 -0400 < Zipheir> It is, of course, much easier to add continuable exceptions to a CPSing interpreter.
2023-05-09 17:24:56 -0400 < seninha> I tried to do like guile and use pointer tagging to fit fixnums and pointers and booleans and all sort of stuff into a single integer value
2023-05-09 17:25:23 -0400 < Zipheir> OK, maybe not "easier". I haven't tried exceptions with other interpreter designs. But it is very easy with CPS.
2023-05-09 17:26:23 -0400 < Zipheir> seninha: Sounds almost like NaN-boxing.
2023-05-09 17:27:28 -0400 < seninha> yeah, it's similar
2023-05-09 17:28:10 -0400 < seninha> it based on memory alignmnt and the fact that the few least significant bits of a pointer are always 0
2023-05-09 17:31:03 -0400 < seninha> Zipheir: here's how it is now (almost nothing changed since last year): https://github.com/phillbush/simp
2023-05-09 17:49:18 -0400 < Zipheir> seninha: Looks good so far.
--- Day changed Wed May 10 2023
2023-05-10 00:11:13 -0400 < sham1> Do note that with tagged pointers, you can have many "kinds" of tags, for example that the least significant bit tells you whether you have a fixnum or not which can help with getting as many bits for the fixnum as possible
2023-05-10 00:11:47 -0400 < sham1> While if it's not a fixnum, you can use more bits to say whether it's an other kind of an immediate like a boolean, the EOF object or whatever, vs a pointer
2023-05-10 09:26:12 -0400 -!- iockywolf is now known as lockywolf
2023-05-10 16:18:58 -0400 < tomhg> Hey. I created a stream upon a stateful object. I did guard the stateful object within a procedure and free! the object after successful iteration.
2023-05-10 16:19:35 -0400 < tomhg> But I am wondering how I should guard freeing, if there was not an error while iterating but in user code.
2023-05-10 16:20:22 -0400 < tomhg> talking helps. Nvm.
--- Day changed Thu May 11 2023
2023-05-11 04:38:10 -0400 -!- lockywolf_ is now known as lockywolf
2023-05-11 10:31:44 -0400 < Guest17> Hello. I'm trying to write a function that takes 3 numbers and sums the square of the two largest numbers. However I'm getting an error when I call it. What is causing the error?
2023-05-11 10:31:44 -0400 < Guest17> ```
2023-05-11 10:31:45 -0400 < Guest17> stklos> (define (sumTwoLargest x y z)
2023-05-11 10:31:45 -0400 < Guest17> ((cond ((< x y z) (+(square y) (square z)))
2023-05-11 10:31:46 -0400 < Guest17> ((< y x z) (+(square x) (square z)))
2023-05-11 10:31:46 -0400 < Guest17> ((< z x y) (+(square x) (square y)))))
2023-05-11 10:31:47 -0400 < Guest17> )
2023-05-11 10:31:47 -0400 < Guest17> ;; sumTwoLargest
2023-05-11 10:31:48 -0400 < Guest17> stklos> (sumTwoLargest 1 2 3)
2023-05-11 10:31:48 -0400 < Guest17> **** Error:
2023-05-11 10:31:49 -0400 < Guest17> sumTwoLargest: bad function `13'. Cannot be applied
2023-05-11 10:31:49 -0400 < Guest17>     (type ",help" for more information)
2023-05-11 10:31:50 -0400 < Guest17> ```
2023-05-11 10:36:08 -0400 < dpk> you have an extra pair of parentheses around your cond
2023-05-11 10:36:34 -0400 < dpk> also, your function is not total (what happens if two or more of x, y, and z are equal to one another?)
2023-05-11 10:57:30 -0400 < Guest17> @dpk thanks, I removed the opening parenthesis and it now works.
2023-05-11 10:57:45 -0400 < Guest17> >also, your function is not total (what happens if two or more of x, y, and z are equal to one another?)
2023-05-11 10:57:45 -0400 < Guest17> You're right
2023-05-11 10:59:22 -0400 < Guest17> But I'm not sure how to make it total
2023-05-11 11:14:20 -0400 < Zipheir> Guest17: You can specify it to return x + y if x = y and x, y > z. But there is more.
2023-05-11 11:29:47 -0400 < Guest17> Thanks. So cond predicates can be combined using `and`?
2023-05-11 11:30:50 -0400 < Zipheir> What's a 'cond predicate'?
2023-05-11 11:31:45 -0400 < Zipheir> (and e1 e2) is true iff e1 and e2 both evaluate to true values. That's all 'and' does.
2023-05-11 11:31:51 -0400 < Guest17> The expression that follows cond. In my example it's (x y z)
2023-05-11 11:32:24 -0400 < Zipheir> I don't see that in your example.
2023-05-11 11:32:37 -0400 < Zipheir> Also, no expression follows cond. cond clauses follow cond.
2023-05-11 11:33:50 -0400 < Zipheir> I guess you mean can you write something like (and (< x y z) (not (= x y))) as a cond test. Yes, you can.
2023-05-11 11:34:07 -0400 < Zipheir> It's not programming magic, though; it's just logic.
2023-05-11 11:54:25 -0400 < Guest17> Zipheir the expression that follows cond is the predicate (< x y z)
2023-05-11 11:55:18 -0400 < Guest17> >I guess you mean can you write something like (and (< x y z) (not (= x y))) as a cond test. Yes, you can.
2023-05-11 11:55:19 -0400 < Guest17> This is good to know. Thanks.
2023-05-11 11:55:54 -0400 < Guest17> > as a cond test
2023-05-11 11:55:54 -0400 < Guest17> As a cond clause, right?
2023-05-11 11:56:17 -0400 < Zipheir> Guest17: I think your terms are a little confused. The predicate is <; (< x y z) is an expression, and ((< x y z) ...) is a cond clause.
2023-05-11 11:56:41 -0400 < Zipheir> "predicate" is just a name for a boolean-valued procedure in Scheme.
2023-05-11 11:58:04 -0400 < Zipheir> The reports are nice and clear about this. https://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.4.5
2023-05-11 11:59:22 -0400 < Guest17> Zipheir `<` is the procedure. `(< x y z)` is the predicate.
2023-05-11 12:00:42 -0400 < Guest17> Chapter 1.1.6 in SICP https://sarabander.github.io/sicp/html/1_002e1.xhtml#g_t1_002e1 is clear about this.
2023-05-11 12:01:18 -0400 < Zipheir> Wow, I guess that's what SICP calls it.
2023-05-11 12:01:29 -0400 < Zipheir> That's unconventional, both in Scheme and in logic.
2023-05-11 12:02:11 -0400 < Guest17> SICP is the gold standard
2023-05-11 12:02:38 -0400 < Zipheir> SICP is idiosyncratic. R5, R6, and R7 all say "A predicate is a procedure that always returns a boolean value (#t or #f).".
2023-05-11 12:03:12 -0400 < Zipheir> Guest17: But I understand what you mean, now. Sorry for the confusion.
2023-05-11 12:04:44 -0400 < Zipheir> So the forms that follow 'cond' are always either (<test> <exp> ...), (else <exp> ...), or (<test> => <exp> ...).
2023-05-11 12:04:53 -0400 < Zipheir> And there can be any number of those.
2023-05-11 12:05:07 -0400 < sham1> And in the last form, the exp has to evaluate to a procedure
2023-05-11 12:05:16 -0400 < sham1> Or maybe it's just the last exp
2023-05-11 12:05:37 -0400 < Guest17> > But I understand what you mean, now. Sorry for the confusion.
2023-05-11 12:05:37 -0400 < Guest17> I didn't post this, what gives?
2023-05-11 12:05:59 -0400 < sham1> He didn't say that you posted it
2023-05-11 12:06:01 -0400 < Zipheir> That was a reply. :)
2023-05-11 12:06:57 -0400 < Zipheir> IRC uses <name>: <message> to direct messages to users (instead of, say, @name syntax).
2023-05-11 12:07:29 -0400 < Guest17> Oh, my bad.
2023-05-11 12:07:53 -0400 < Guest17> Thought I was going crazy
2023-05-11 12:58:24 -0400 < acdw> what do yall think about when to specify ports and when not in scheme procedures?
2023-05-11 12:58:50 -0400 < acdw> like when to (define (foo port)) and when to just (define (foo)) to be run with, say, (with-input-from-file ...)
2023-05-11 13:12:28 -0400 < Zipheir> You can always add an optional port argument.
2023-05-11 13:12:49 -0400 < acdw> afaict in r7rs the only way to really do optional arguments is case-lambda, correct?
2023-05-11 13:12:51 -0400 < Zipheir> I prefer this for library procedures. Stand-alone tools can use current-input/output.
2023-05-11 13:13:07 -0400 < Zipheir> Yes.
2023-05-11 13:13:24 -0400 < acdw> that makes sense ... have a port argument in everything but the end-user-facing procedure basically
2023-05-11 13:13:30 -0400 < acdw> then have an optional port argument
2023-05-11 13:13:58 -0400 < Zipheir> That's how read, display, and other standard I/O procedures do it.
2023-05-11 13:14:03 -0400 < gwatt> When in doubt, accept a port. If there's only ever going to be one input/output that makes sense, then you can exclude the port. And as Zipheir pointed out, optional arguments exist, though are kind of clunky after a few
2023-05-11 13:14:25 -0400 < acdw> yes indeed lol
2023-05-11 13:14:46 -0400 < acdw> okay awesome, thanks yall
2023-05-11 13:15:07 -0400 < Zipheir> You can use let-optionals, if you have it.
2023-05-11 13:15:47 -0400 < acdw> i'm trying to stay w/in the r7rs spec
2023-05-11 13:15:58 -0400 < johnjaye> some lisp code goes really crazy with optional args
2023-05-11 13:16:25 -0400 < johnjaye> it's like foo adds 2 to x. unless optional argument a is specified, in which case it divides by 2. optional arg b means it mods by 14. arg c means it restarts your computer
2023-05-11 13:16:35 -0400 < Zipheir> acdw: Well, syntax-rules is in R7RS... :)
2023-05-11 13:16:44 -0400 < acdw> yeah i was pro-optional-arg, but then thinking more about it realized that it's really just there for ease-of-use. so if it's an internal procedure then putting in all args makes sense
2023-05-11 13:16:56 -0400 < acdw> Zipheir: you're saying i could write my own define* with optional args? :P
2023-05-11 13:17:11 -0400 < acdw> johnjaye: i use arg c all the time
2023-05-11 13:18:01 -0400 < Zipheir> acdw: Sure. I can't remember if you can implement let-optionals or Guile-style define* with syntax-rules, though.
2023-05-11 13:18:26 -0400 < acdw> aha right.
2023-05-11 13:18:36 -0400 < acdw> i'm not quite to syntax-rules /yet/
2023-05-11 13:18:37 -0400 < Zipheir> MNW has an R6 version at https://github.com/scheme-requests-for-implementation/srfi-227
2023-05-11 13:18:37 -0400 < mdhughes> (define foo (case-lambda (() (foo #f))  ((x) ...) ))
2023-05-11 13:18:51 -0400 < acdw> oo srfi 227
2023-05-11 13:19:21 -0400 < Zipheir> Marc Feeley's SRFI 89 implementation of define* uses define-macro. :-p
2023-05-11 13:20:15 -0400 < Zipheir> mdhughes: Yeah, self-tail-calls make writing with case-lambda much easier.
2023-05-11 13:21:10 -0400 < johnjaye> acdw: well i wasn't going to name and shame emacs but I have seen examples of this.
2023-05-11 13:21:21 -0400 < johnjaye> i think when optional args gets above 5 or 6 you're doing it wrong
2023-05-11 13:22:31 -0400 < mdhughes> Yeah, I only do a couple of optionals at most, after that I take an alist of properties.
2023-05-11 13:24:15 -0400 < mdhughes> Optional keywords in CHICKEN are nice, but it encourages too many options. More often if something needs a bunch of switches and options, it should be several functions.
2023-05-11 13:24:26 -0400 < acdw> johnjaye: lol no you absolutely should name and shame emacs
2023-05-11 13:24:55 -0400 < acdw> &optional [five args] &key [five more args] &rest rest
2023-05-11 13:25:06 -0400 < johnjaye> haha. basically
2023-05-11 13:25:12 -0400 < acdw> plus some custom argument parsing b/c that's still not enough
2023-05-11 13:25:15 -0400 < johnjaye> speaking of arguments, are you running emacs 28?
2023-05-11 13:25:19 -0400 < acdw> like maybe try some .. composing
2023-05-11 13:25:21 -0400 < acdw> johnjaye: i'm on 30
2023-05-11 13:25:27 -0400 < acdw> razor's edge
2023-05-11 13:25:36 -0400 < johnjaye> can you C-h f kill-emacs and tell me how many args it takes
2023-05-11 13:25:48 -0400 < acdw> (kill-emacs &optional ARG RESTART)
2023-05-11 13:26:01 -0400 < acdw> oh you can return ARG as the exit program cod
2023-05-11 13:26:03 -0400 < acdw> code*
2023-05-11 13:26:09 -0400 < johnjaye> as i suspected. i'm on 27 and only have ARG, not the second one. must have been introduced
2023-05-11 13:26:21 -0400 < acdw> oh yeah it's new ,  i thought for 29
2023-05-11 13:26:30 -0400 < acdw> see also restart-emacs
2023-05-11 13:26:43 -0400 < acdw> like, it's not /that/ useful, but i've used it a few times
2023-05-11 13:49:02 -0400 < sham1> I've shifted towards preferring let-optionals, but with keyword objects since those could be specified without explicit quoting (cf. symbols)
2023-05-11 13:49:31 -0400 < sham1> So something like (procedure-with-optional-port arg1 arg2 #:port explicit-port)
2023-05-11 13:49:45 -0400 < sham1> With the last two arguments going into a rest arg
2023-05-11 13:50:13 -0400 < sham1> Now, quoting would be shorter by one character, but meh
2023-05-11 13:51:01 -0400 < Zipheir> Provided you have real keyword objects, that's perfect.
2023-05-11 13:51:41 -0400 < sham1> Also, this syntax makes it so that there's a usage for plist specific stuff ;)
2023-05-11 13:51:45 -0400 < sham1> Put that into codeberg
2023-05-11 13:53:33 -0400 < sham1> One extra use for distinguishing keywords from symbols in this is that one could use it as a signal that the "regular" arguments have run out, and that keyword args have begun
2023-05-11 14:01:39 -0400 < acdw> oho i see what you're saying
2023-05-11 14:01:42 -0400 < acdw> that would be nice
2023-05-11 14:01:54 -0400 < acdw> plist-ref #:port, etc
2023-05-11 14:05:33 -0400 < sham1> Yeah
2023-05-11 14:06:14 -0400 < Zipheir> Until you want to pass keyword objects as arguments, I guess.
2023-05-11 14:06:26 -0400 < Zipheir> This is why keywords are syntactic in Racket.
2023-05-11 14:06:39 -0400 < sham1> Although I'd personally rather use let-optionals because that can have specific behaviour dealing with duplicates and the like
2023-05-11 14:07:04 -0400 < acdw> mmm
2023-05-11 14:07:50 -0400 < sham1> Doing this similar thing with alists would also work, but you'd have to do something like (foo `((port . ,explicit-port))) or something like that
2023-05-11 14:07:56 -0400 < gwatt> sham1: by "duplicates" you mean passing the same keyword argument twice?
2023-05-11 14:07:59 -0400 < sham1> Yes
2023-05-11 14:08:47 -0400 < sham1> If you want to have multiple items for an argument, you pass in a collection. IMO having duplicate keyword args is a programmer error
2023-05-11 14:10:55 -0400 < Zipheir> That's another reason why keyword syntax is a good idea. If keywords are values, you can't statically check for duplicates.
2023-05-11 14:11:02 -0400 < Zipheir> ... or invalid keywords.
2023-05-11 14:12:36 -0400 < Zipheir> Although perhaps you could, if keywords were sort of second-class values--if they could only be created by literal syntax.
2023-05-11 14:13:03 -0400 < Zipheir> If there's a string->keyword procedure or the like, you can't possible do static analysis.
2023-05-11 14:13:12 -0400 < Zipheir> s/possible/possibly/
2023-05-11 14:13:31 -0400 < sham1> Could also just do what CL does and make keywords a special kind of symbol :P
2023-05-11 14:14:08 -0400 < Zipheir> But then you're back to the same old problem.
2023-05-11 14:14:21 -0400 < Zipheir> And you still can't do static analysis.
2023-05-11 14:14:50 -0400 < sham1> Right
2023-05-11 14:15:39 -0400 < Zipheir> The keyword-args system I'd like would give you an error at compile time if you try to pass an invalid or duplicated keyword.
2023-05-11 14:16:00 -0400 < sham1> The nice thing with let-optionals would be that you can choose whether to treat these things as special
2023-05-11 14:16:39 -0400 < sham1> Procedures that don't treat keywords specially, like list, could then use them like any other values. Useful for apply and such
2023-05-11 14:16:55 -0400 < Zipheir> True.
2023-05-11 14:18:07 -0400 < Zipheir> But then, you could just use symbols in such a case.
2023-05-11 14:18:40 -0400 < Zipheir> Symbols are already a (non-foolproof) kind of keywords.
2023-05-11 14:18:49 -0400 < sham1> Yeah
2023-05-11 14:21:01 -0400 < Zipheir> There are a lot of details to consider. I don't care too much about the hygiene problems of keywords-as-symbols, but I do think you should be able to statically reject invalid keyword calls.
2023-05-11 14:21:26 -0400 < Zipheir> Should you want that kind of safety.
2023-05-11 14:22:54 -0400 < sham1> syntax-case could probably use let-optionals to see whether things are proper and good
2023-05-11 14:23:11 -0400 < sham1> Like using let-optionals or some other validator code
2023-05-11 14:24:23 -0400 < gwatt> I worked on something that did that by generating a macro facade to the procedure, but you lost the macro facade and keywords if you attempted to pass the procedure as an object
2023-05-11 14:24:37 -0400 < gwatt> "that" being the static verification of keywords
2023-05-11 14:25:09 -0400 < sham1> Yes, but you wouldn't need compile-time verification when passing the procedure ahead anywah
2023-05-11 14:25:55 -0400 < gwatt> right, but I more meant that you lost the keywords entirely, as those were only known about by the macro facade
2023-05-11 14:26:23 -0400 < Zipheir> sham1: I don't get it. Are there versions of let-optionals that handle keywords?
2023-05-11 14:26:49 -0400 < sham1> Well any implementation that has both should be able to combine their usage
2023-05-11 14:26:51 -0400 < Zipheir> The ones in chibi, CHICKEN, and SRFI 227 don't seem to.
2023-05-11 14:26:54 -0400 < sham1> Like Gauche
2023-05-11 14:27:00 -0400 < gwatt> in contrast to racket keyword procedures, which need separate `apply` mechanisms than non-kw procedures
2023-05-11 14:27:02 -0400 < Zipheir> Hmm, I guess the CHICKEN one must handle them.
2023-05-11 14:27:52 -0400 < Zipheir> gwatt: Yeah, that adds some complexity.
2023-05-11 14:28:24 -0400 < sham1> Which is why I prefer them to be real objects
2023-05-11 14:33:29 -0400 < Zipheir> As long as you can live with the strange loop of objects that are also syntax.
2023-05-11 14:34:18 -0400 < Zipheir> I'm sure there's some crazy macro solution to all of this.
2023-05-11 14:34:51 -0400 < sham1> We literally have objects that express syntax
2023-05-11 14:35:03 -0400 < sham1> I don't think this is any more difficult
2023-05-11 14:35:59 -0400 < Zipheir> I mean that you don't know, in general, how an unknown procedure will treat a keyword object.
2023-05-11 14:36:43 -0400 < Zipheir> They're values or "syntax" (for lack of a better term) depending on the context, so you'd better know the context.
2023-05-11 14:38:39 -0400 < Zipheir> Level-crossing is a Lisp tradition, though, so maybe it's best not to be too pedantic.
2023-05-11 14:40:38 -0400 < Zipheir> (If Riastradh were here, he'd say we should be pedantic in this case and that only Racket has gotten keywords right.)
2023-05-11 14:47:51 -0400 < Zipheir> sham1: "objects that express syntax": Did you mean the output of syntax-rules procedures?
2023-05-11 15:04:29 -0400 < sham1> I mean syntax objects
2023-05-11 22:49:13 -0400 -!- Cathrinus is now known as Lulu
--- Day changed Fri May 12 2023
--- Log closed Fri May 12 00:27:25 2023
--- Log opened Fri May 12 00:32:39 2023
2023-05-12 00:32:39 -0400 -!- Irssi: #scheme: Total of 195 nicks [0 ops, 0 halfops, 0 voices, 195 normal]
2023-05-12 00:32:40 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-05-12 08:57:29 -0400 < vcarvalho[m]> Hi everyone, I'm experimenting w/ Chez Scheme and I'm facing an issue with stdout with multiple threads. It seems that when I call the display function from the main thread, it flushes the output properly. However, when the same function is called from a different thread, the output doesn't get flushed.... (full message at <https://libera.ems.host/_matrix/media/v3/download/libera.chat/99c8d591618d8bbe527ebec1b4c7286d0e2bd2fa>)
2023-05-12 08:57:55 -0400 < vcarvalho[m]> I didn't find the Chez implementation channel on Libera so i'm trying my luck here :)
2023-05-12 09:22:20 -0400 < rgherdt> vcarvalho[m]: I'm not familiar with Chez, but the channel is called #chez
2023-05-12 09:46:37 -0400 < vcarvalho[m]> Oh thanks, that did not appear on the element client
--- Log closed Fri May 12 11:55:24 2023
--- Log opened Fri May 12 17:30:06 2023
2023-05-12 17:30:06 -0400 -!- Irssi: #scheme: Total of 200 nicks [0 ops, 0 halfops, 0 voices, 200 normal]
2023-05-12 17:30:07 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-05-12 18:11:10 -0400 < tomhg> `(define var (let ((var 1)) (lambda (var) 'none)))` gives me strong headache. I have two token streams at hand I can switch between: '(define var let var 1 lambda var 'none) vs '( ( define var ( let ( ( var 1 ) ) ( lambda ( var ) 'none ) ) ). But while switching I have to keep track of the relevant production rule currently interpreted. I stuggle to sketch it out at hand.
2023-05-12 18:12:05 -0400 < tomhg> Writing this to myself and in sincerly hope to maybe get some sketching advice. But I am sure this aids my night anyways.
2023-05-12 18:13:41 -0400 < tomhg> deciding between depth-first and breadth-first meanwhile as well as between recursion and tail-recursion. So I have six snakes I can put my head around *shrugs*.
2023-05-12 18:17:30 -0400  * tomhg prohibits anyone to write in order to look at my own things for a hour (:
2023-05-12 18:28:17 -0400 < tomhg> Traversing the AST breadth-first each node encountered starts a recursion. In order to determine that the top-level var is a lambda I have to look-ahead. Each look-ahead creates a recursion. The results are collected (*place error handling*). The correct recursion has to be elected. *sighs*
2023-05-12 18:29:42 -0400 < tomhg> I need some data structure that grows at runtime but is written as one line in code, I suppose.
2023-05-12 21:21:22 -0400 < mdhughes> I almost never use internal defines. Just letrec* if you need internal functions, or raise them to top level and name %obscure-function
--- Day changed Sat May 13 2023
2023-05-13 03:59:20 -0400 < wasamasa> seninha: BTW, I've checked the specification and internal defines are allowed at the beginning of let, see 5.3.2
2023-05-13 04:44:15 -0400 < cow_2001> i have… uh……… gotten Daniel Friedman's textbook
2023-05-13 04:44:37 -0400 < cow_2001> essentials something or another
2023-05-13 04:46:25 -0400 < cow_2001> first exercise is about defining sets recursively, inductively, and inductively using the horizontal line antecedent | consequent notation
2023-05-13 04:48:42 -0400 < cow_2001> Rules of Inference
2023-05-13 06:09:58 -0400 -!- greaser|q is now known as GreaseMonkey
2023-05-13 08:46:15 -0400 < cow_2001> S is the smallest set that follows the rules: | 0 in S; n in S | n+3 in S.
2023-05-13 08:46:55 -0400 < cow_2001> now, T follows the rules: | 0 in T; n in T | n+3 in T.
2023-05-13 08:47:18 -0400 < cow_2001> oh, also S and T are both subsets of Naturals
2023-05-13 08:47:36 -0400 < cow_2001> (the N with 0)
2023-05-13 08:48:27 -0400 < cow_2001> S = {3n | n in N}, clearly.
2023-05-13 08:48:46 -0400 < cow_2001> find T such that T ≠ S.
2023-05-13 08:49:28 -0400 < cow_2001> now, could i say T = S union {1} and it will be the right answer?
2023-05-13 08:53:11 -0400 < cow_2001> it only says which elements of N definitely exist in T, so maybe 1 is also a member? maybe 2? who knows!
2023-05-13 08:53:45 -0400 < cow_2001> there is no "smallest set" directive for T, but there is for S
2023-05-13 09:42:56 -0400 < cow_2001> S proper subset T subset Z+
2023-05-13 10:10:42 -0400 < cow_2001> someone explained to me why i was wrong
2023-05-13 10:11:07 -0400 < wasamasa> > GnuCash has a report-generation mechanism that has clearly had a lot of effort put into it; the system is designed to be extensible by end users. The unfortunate part is that the extension language is Scheme, and it is, for the most part, undocumented. Scheme looks like Lisp but isn't really Lisp; the number of people who know it well is sure to be small.
2023-05-13 10:11:17 -0400 < cow_2001> according to rule 2, if 1 in T, then 4 in T, which contradicts how i defined T.
2023-05-13 10:13:22 -0400 < cow_2001> T there can only be something like {3n + 1 | n in Z+} cup S or {3n + 2 | n in Z+} cup S or Z+ itself
2023-05-13 10:13:33 -0400 < cow_2001> therefore
2023-05-13 10:14:48 -0400 < cow_2001> or... it could start at any number
2023-05-13 10:55:21 -0400 < seninha> cow_2001, Essentials of Programming Languages?
2023-05-13 10:58:46 -0400 < cow_2001> seninha: yes!
2023-05-13 10:59:34 -0400 < seninha> I started reading it yesterday by recommendation of Zipheir.
2023-05-13 11:08:04 -0400 -!- mdhughes_ is now known as mdhughes
2023-05-13 11:16:26 -0400 -!- daviid` is now known as daviid
2023-05-13 11:18:11 -0400 < acdw> wasamasa: who said that i'll fight em
2023-05-13 12:13:46 -0400 < Zipheir> "Scheme looks like Lisp but isn't really Lisp"  What?
2023-05-13 12:23:43 -0400 < Zipheir> I suppose they mean it isn't Common or Elisp.
2023-05-13 12:24:47 -0400 < Zipheir> seninha: I'm glad to hear it.  I enjoyed that book a lot, although it could go deeper in some areas like types.
2023-05-13 12:32:55 -0400 < acdw> no true lisp fallacy
2023-05-13 12:39:45 -0400 < Zipheir> Indeed.
2023-05-13 13:19:47 -0400 < wasamasa> acdw: the LWN editor, Corbet
2023-05-13 13:21:43 -0400 < acdw> hmm
2023-05-13 13:27:24 -0400 < Zipheir> GIMP has had Scheme scripting for decades now. Of course, it's not a very nice embedding, and they're clearly more interested in the Python interface.
2023-05-13 13:27:35 -0400 < Zipheir> So Corbet must live under a rock.
2023-05-13 13:32:07 -0400 < wasamasa> the documentation of the extension API does need to be documented, maybe that's what he means
2023-05-13 13:32:15 -0400 < wasamasa> GIMP does suffer from that problem
2023-05-13 13:32:54 -0400 < Zipheir> Very much so.
2023-05-13 13:33:14 -0400 < Zipheir> I also find their lack of Scheme booleans disturbing.
2023-05-13 13:33:18 -0400 < wasamasa> I've figured out enough of it, but it does feel like quite the challenge
2023-05-13 13:35:10 -0400 < Zipheir> It would be nice to see a really idiomatic Scheme interface to GIMP, instead of the side-effecting (gimp-do-this!) (gimp-do-that!) imperative pattern.
2023-05-13 13:35:37 -0400 < Zipheir> But I think that would be a different program, something like the Henderson picture language.
2023-05-13 13:35:43 -0400 < seninha> Zipheir: Like if GNU Guile were actually used in GNU applications?
2023-05-13 13:36:19 -0400 < Zipheir> seninha: True, you'd think more GNU projects would use it.
2023-05-13 13:36:39 -0400 < Zipheir> People always think GIMP uses Guile, but it's actually TinyScheme.
2023-05-13 13:37:18 -0400 < seninha> My lispy implementation now has "define" and "quote" \o/ It is slowly taking form! I decided to do a kernel-like language, with fexprs and operatives.
2023-05-13 13:37:42 -0400 < Zipheir> Very cool.
2023-05-13 13:38:13 -0400 < seninha> however i am reconsidering my decision to not implement separate values for true, false and eof. Abusing nil for false/eof is a botch.
2023-05-13 13:38:39 -0400 < Zipheir> The CLers would have something to say about that. :)
2023-05-13 13:38:51 -0400 < Zipheir> But I agree.
2023-05-13 13:40:18 -0400 < Zipheir> nil = false does let you write list recursion in a very compact way.
2023-05-13 13:41:37 -0400 < seninha> eof as a proper value is also useful
2023-05-13 13:42:11 -0400 < Zipheir> What's an improper value?
2023-05-13 13:42:45 -0400 < seninha> "proper value" like in "separate value"
2023-05-13 13:42:53 -0400 < seninha> rather than just returning nil on EOF
2023-05-13 13:43:49 -0400 < Zipheir> Ah, disjoint from other objects.
2023-05-13 13:43:57 -0400 < seninha> yeah
2023-05-13 13:44:03 -0400 < Zipheir> Or something like that.
2023-05-13 13:44:48 -0400 < Zipheir> Yeah, that's very important. Otherwise 'read' can't unambiguously terminate.
2023-05-13 13:49:26 -0400 < seninha> it can if you have some kind of got-eof? procedure for ports
2023-05-13 13:49:53 -0400 < seninha> (that's what I was doing)
2023-05-13 13:50:23 -0400 < Zipheir> i.e. port-is-at-eof?
2023-05-13 13:59:11 -0400 < edgar-rft> there is a port at the end of my file
2023-05-13 14:10:00 -0400 < ManDay> proper semantics don't require EOF :P
2023-05-13 14:14:52 -0400 < Zipheir> Most semantics ignore I/O, anyway.
2023-05-13 14:15:04 -0400 < cow_2001> Zipheir: now reading eopl too
2023-05-13 14:15:28 -0400 < Zipheir> Great!
2023-05-13 14:15:38 -0400 < ManDay> what good is a computer without i/o
2023-05-13 14:15:41 -0400 < cow_2001> not as fun as the little books :|
2023-05-13 14:16:07 -0400 < ManDay> schroedinger's computer
2023-05-13 14:16:25 -0400 < Zipheir> No, but similar. EoPL also expects you to be good at learning from example.
2023-05-13 14:16:26 -0400 < ManDay> maybe it does something, maybe not
2023-05-13 14:16:55 -0400 < cow_2001> the computation result was inside you all along
2023-05-13 14:17:58 -0400 < Zipheir> ManDay: I've never seen a denotational description of I/O. I'm not sure if the operational R6RS semantics cover it; seems to me it could.
2023-05-13 14:18:01 -0400 < ManDay> as in: it's easy to get the right result, just remove all the wrong results
2023-05-13 14:18:51 -0400 < cow_2001> ever read Library of Babel?
2023-05-13 14:19:10 -0400 < cow_2001> by Louis Borges whatshisname
2023-05-13 14:19:19 -0400 < Zipheir> Denotationally, I/O procedures are all very, very simple functions that take a World to a World. The transformation isn't expressible, though.
2023-05-13 14:19:34 -0400 < ManDay> Zipheir: uhm ok, that sounds like an oversight? i/o should be a core principle to every language formalization for the very reason that everything is ueless without i/o, no?
2023-05-13 14:19:54 -0400 < ManDay> well i'm not strong on formal semantics
2023-05-13 14:19:57 -0400 < Zipheir> ManDay: Yes, but how do you formalize it?
2023-05-13 14:20:07 -0400 < ManDay> i don't know, someone clever would know, though :p
2023-05-13 14:20:59 -0400 < Zipheir> The R[57] semantics for Scheme, for example, say absolutely nothing about I/O.
2023-05-13 14:21:00 -0400 < ManDay> what does haskell do? they certainly have a functional formalism for i/o no?
2023-05-13 14:21:19 -0400 < ManDay> (one which doesn't involve eof, probably!)
2023-05-13 14:23:36 -0400 < ManDay> ah it's all monads... how surprising
2023-05-13 14:23:40 -0400 < Zipheir> They've got isEOFError, which is just about the same idea as port-is-at-eof?.
2023-05-13 14:24:21 -0400 < Zipheir> getChar :: IO Char raises a specific exception to indicate an EOF situation.
2023-05-13 14:24:30 -0400 < cow_2001> personally i don't like anything else than true and false to be true or false
2023-05-13 14:24:45 -0400 < cow_2001> it makes me remember more things
2023-05-13 14:24:53 -0400 < ManDay> well, yes, I didn't really think they could *practically* live without EOF, but I thought some beautiful concept could do without it...
2023-05-13 14:25:03 -0400 < Zipheir> But that type is really facetious; two getChar expressions can't be compared for equality.
2023-05-13 14:25:03 -0400 < cow_2001> i don't like to remember more arbitrary things
2023-05-13 14:26:11 -0400 < ManDay> sure, introduce something semantically ugly (EOF, monads, too?) and you get metastases sprouting everywhere
2023-05-13 14:26:21 -0400 < cow_2001> isn't the IO monad just a way of enforcing sequencing in a very specific context?
2023-05-13 14:26:34 -0400 < ManDay> seninha: Be beautiful, be without EOF :)
2023-05-13 14:26:51 -0400 < cow_2001> or... however someone who actually knows what they are talking about would say it
2023-05-13 14:27:09 -0400 < Zipheir> cow_2001: The IO pseudo-monad is there to segregate out "dirty" values.
2023-05-13 14:27:25 -0400 < cow_2001> in a sequence!
2023-05-13 14:27:55 -0400 < Zipheir> I'm not sure sequencing is special to IO.
2023-05-13 14:28:00 -0400 < cow_2001> oh
2023-05-13 14:28:12 -0400 < Zipheir> It's strict, though, which is the exception in Haskell.
2023-05-13 14:28:21 -0400 < cow_2001> strict?
2023-05-13 14:28:28 -0400 < Zipheir> As opposed to lazy.
2023-05-13 14:28:56 -0400 < Zipheir> getChar reads a character from standard input immediately, not when its value is needed.
2023-05-13 14:28:59 -0400 < cow_2001> i didn't realise that is the opposite of lazy.
2023-05-13 14:29:22 -0400 < cow_2001> so IO is strict. what about... hmm
2023-05-13 14:30:15 -0400 < cow_2001> there is a thing about chaining lambdas
2023-05-13 14:30:40 -0400 < Zipheir> It's sort of the classic Haskell joke: If IO were lazy, you could compile a Haskell program to the empty string.
2023-05-13 14:32:22 -0400 < ManDay> What if only I or O were lazy?
2023-05-13 14:32:35 -0400 < cow_2001> ghc is about 500 megabytes and i don't have that kind of storage on the phone ~_~
2023-05-13 14:32:40 -0400 < Zipheir> (Or, I guess, a promise to JIT the program when someone cares about its output.)
2023-05-13 14:32:46 -0400 < Zipheir> GHC is a monster.
2023-05-13 14:32:59 -0400 < cow_2001> 50megabytes
2023-05-13 14:33:02 -0400 < cow_2001> sorry
2023-05-13 14:33:24 -0400 < Zipheir> I had to compile GHC to run it on Slackware, and I never want to do that again.
2023-05-13 14:33:43 -0400 < cow_2001> i need to meditate. sorry. good bye for now.
2023-05-13 14:34:10 -0400 < Zipheir> Bye. :)
2023-05-13 14:34:54 -0400 < ManDay> Zipheir: i was considering compiling it since it looks like some deps were cleared out on gentoo, is it worse than gcc?
2023-05-13 14:34:57 -0400 < Zipheir> ManDay: The R6RS semantics also omit I/O. https://www.r6rs.org/final/html/r6rs/r6rs-Z-H-15.html#node_chap_A
2023-05-13 14:35:55 -0400 < Zipheir> ManDay: I've somehow managed to avoid compiling gcc over the years, so I can't say. GHC took over four hours on a 4.2 GHz x86_64.
2023-05-13 14:36:34 -0400 < Zipheir> Maybe having more than 8 GB of RAM would have made it faster. Compiling it consumed memory at an amazing rate.
2023-05-13 14:36:55 -0400 < ManDay> oh that sounds about a tad worse than gcc then :-/
2023-05-13 14:37:09 -0400 < seninha> done! true/false/eof implemented!
2023-05-13 14:37:10 -0400 < seninha> https://github.com/phillbush/simp/commit/ab78d9519d5e3d4b00b856be4298c8e68fd3ade6#diff-92194f057884b3287a3a6bf84e6e3b2bf433a556b68562799252a091744e7854
2023-05-13 14:37:11 -0400 < rudybot> https://teensy.info/cJP8MCfoL2
2023-05-13 14:39:24 -0400 < Zipheir> seninha: Nice; looks pretty simple to me.
2023-05-13 16:35:26 -0400 < Guest1234> hello, i think i have managed to figure out the y combinator, but i can't seem to apply it to get a factorial function.  Code here paste.debian.net/1280180
2023-05-13 16:36:59 -0400 < Guest1234> the code enters an infinite loop and nothing happends
2023-05-13 16:51:35 -0400 < edgar-rft> it loops infinitely, is that nothing?
--- Day changed Sun May 14 2023
2023-05-14 07:58:44 -0400 < cow_2001> i need your help with this mathy proofy thing in eopl
2023-05-14 07:59:08 -0400 < cow_2001> i've read it and i've despaired
2023-05-14 08:01:05 -0400 < cow_2001> it is 1.1.3. Induction
2023-05-14 08:01:50 -0400 < cow_2001> proof of theorem 1.1.1. Let t be a binary tree, as defined in definition 1.1.7. Then t contains odd number of nodes.
2023-05-14 08:03:05 -0400 < cow_2001> Bintree ::= Int | (Symbol Bintree Bintree)
2023-05-14 08:47:04 -0400 < sham1> You could try induction
2023-05-14 09:12:51 -0400 < pinoaffe> cow_2001: I would define the "height" of a bintree, such that (height (bintree 0)) is 0 and such that (height (bintree a b)) is (max (height a) (height b))
2023-05-14 09:13:44 -0400 < pinoaffe> then you can do natural induction over height
2023-05-14 09:17:21 -0400 < pinoaffe> alternatively, for a proof that is less mathy and more computer-sciency, just show that the property is preserved by all constructors of Bintree
2023-05-14 11:31:41 -0400 < Zipheir> cow_2001: What pinoaffe says. Most proofs on trees are going to contain some base cases and some inductive ones.
2023-05-14 11:32:01 -0400 < Zipheir> Your proof should exactly follow the type constructors.
2023-05-14 11:37:31 -0400 < cow_2001> who where what?
2023-05-14 11:38:14 -0400 < cow_2001> nonono it is an example they lay it all out. the problem is that i do not understand the explanation
2023-05-14 11:38:20 -0400 < cow_2001> wait a second.
2023-05-14 11:38:31 -0400 < cow_2001> i am reading the channel's backlog
2023-05-14 11:40:06 -0400 < cow_2001> i haven't done a lot of inductive proofs. maybe could count on a single hand.
2023-05-14 11:40:17 -0400 < Zipheir> If you are proving that all natural numbers have a certain property P, then it's enough to show that P(0) is true and that P(n) implies P(n + 1).
2023-05-14 11:40:51 -0400 < Zipheir> Lists and trees are just slightly more complex inductive data.
2023-05-14 11:44:48 -0400 < Zipheir> (e.g., switching to Scheme-like notation, to show that (P lis) for all lists lis, it's enough to show that (P '()), and then that (P xs) implies (P (cons x xs)).)
2023-05-14 11:46:27 -0400 < Zipheir> Maybe this is not helping very much.
2023-05-14 11:58:10 -0400 < cow_2001> hmmmmmm wouldn't i need to show it is true for.... hmmm... Int, which is the base case, and then to show that if it is true for Bintree some-bintree, which may be either an Int, or an (Symbol Bintree Bintree), then it is true for (Symbol some-bintree Bintree) and also for (Symbol Bintree some-bintree)
2023-05-14 12:03:06 -0400 < cow_2001> due to symmetry it is true for both
2023-05-14 12:04:27 -0400 < Zipheir> cow_2001: Just assume it is true of both subtrees.
2023-05-14 12:05:21 -0400 < Zipheir> It wouldn't make much sense to hypothesize about only one of them.
2023-05-14 12:06:58 -0400 < cow_2001> "the Induction Hypothesis, IH(k), is that any tree of size smaller or equal to k has an odd number of nodes"
2023-05-14 12:07:23 -0400 < cow_2001> that is the P(n), right?
2023-05-14 12:07:38 -0400 < cow_2001> we then must show that P(n+1) is also true
2023-05-14 12:08:04 -0400 < Zipheir> Right.
2023-05-14 12:08:11 -0400 < cow_2001> and if we show that the base case is true, all cases are true from the induction
2023-05-14 12:08:47 -0400 < Zipheir> But you don't want to take it too literally. Follow the constructors for the type.
2023-05-14 12:10:35 -0400 < cow_2001> why did they say smaller or equal to k? why not just k?
2023-05-14 12:12:45 -0400 < Zipheir> Because you're trying to write a general proof. Think of it as a function that's supposed to churn out an infinite number of true propositions.
2023-05-14 12:14:00 -0400 < cow_2001> so "assume that it is true for all trees smaller than k+1"
2023-05-14 12:15:20 -0400 < Zipheir> Yes.
2023-05-14 12:15:53 -0400 < Zipheir> The authors of Concrete Mathematics said it very well: "Mathematical induction proves that we can climb as high as we like on a ladder, by proving that we can climb onto the bottom rung (the basis) and that from each rung we can climb up to the next one (the step)."
2023-05-14 12:15:57 -0400 < cow_2001> why would IH(0) hold trivially? there are no trees with 0 nodes. it sounds like talking about trees with -1 nodes
2023-05-14 12:16:51 -0400 < cow_2001> it is neither odd nor even
2023-05-14 12:16:53 -0400 < Zipheir> I think they could have been clearer there.
2023-05-14 12:17:33 -0400 < Zipheir> That's why I said "don't take (the pattern) too literally". A 0-node tree can't be constructed, so you can eliminate that in the first line of your proof.
2023-05-14 12:17:53 -0400 < cow_2001> so we are left with IH(1)
2023-05-14 12:18:03 -0400 < Zipheir> "There are no 0-node trees. So every tree must have a positive number of nodes. Therefore..."
2023-05-14 12:18:16 -0400 < cow_2001> hmmmmmmm
2023-05-14 12:18:31 -0400 < cow_2001> i see
2023-05-14 12:20:06 -0400 < cow_2001> okay, so a tree of a single node is obviously odd.
2023-05-14 12:20:38 -0400 < Zipheir> There's your base case.
2023-05-14 12:21:34 -0400 < cow_2001> now, we assume that any tree of less or equal to k nodes is odd
2023-05-14 12:22:06 -0400 < cow_2001> that is, k=2n+1 where n in Z+
2023-05-14 12:24:48 -0400 < cow_2001> they say if t has less or equal than k+1 nodes, it is either a Bintree of the form Int (the base case), or of the compound form
2023-05-14 12:27:35 -0400 < Zipheir> You just need the proof for the compound constructor.
2023-05-14 12:27:37 -0400 < cow_2001> now, the compound form is (Sym t1 t2). that means that t1 and t2 each has less than or equal k nodes, because we peel away one node (how do you say that?)
2023-05-14 12:28:21 -0400 < Zipheir> More importantly, you've assumed they both have an odd number of nodes.
2023-05-14 12:28:50 -0400 < Zipheir> So the total number of nodes in t1 *and* t2 is the sum of two odd numbers.
2023-05-14 12:30:24 -0400 < cow_2001> t1 has k1 = 2 * n1 + 1 and t2 has k2 = 2 * n2 + 1 nodes
2023-05-14 12:31:11 -0400 < cow_2001> now, the total number of nodes in t is k1 + k2 + 1
2023-05-14 12:31:49 -0400 < cow_2001> which is (2 * n1 + 1) + (2 * n2 + 1) + 1
2023-05-14 12:31:59 -0400 < cow_2001> (sorry for the verbosity)
2023-05-14 12:32:45 -0400 < Zipheir> For this result, all you need to know is whether k1 + k2 + 1 is odd.
2023-05-14 12:32:55 -0400 < cow_2001> 2 * (n1 + n2 + 1) + 1
2023-05-14 12:33:10 -0400 < cow_2001> = k
2023-05-14 12:33:14 -0400 < cow_2001> QED
2023-05-14 12:33:20 -0400 < cow_2001> err
2023-05-14 12:33:24 -0400 < cow_2001> no wait
2023-05-14 12:33:55 -0400 < cow_2001> k+1
2023-05-14 12:34:02 -0400 < cow_2001> = k + 1
2023-05-14 12:34:13 -0400 < cow_2001> QED
2023-05-14 12:34:36 -0400 < cow_2001> and that was just an example i am backlight tracing
2023-05-14 12:35:43 -0400 < cow_2001> thank you!
2023-05-14 12:35:48 -0400 < Zipheir> You're welcome.
2023-05-14 12:36:03 -0400 < Zipheir> I think it can be a very simple proof.
2023-05-14 12:36:23 -0400 < Zipheir> But it relates to a lot of other properties of binary trees, so it's worth playing with.
2023-05-14 12:38:24 -0400 < cow_2001> what is the simplest you can think of?
2023-05-14 12:38:53 -0400 < cow_2001> they say the key is that t1 and t2 are always smaller than t
2023-05-14 12:42:05 -0400 < Zipheir> "A tree of the form Int contains an odd number of nodes, namely one. Assume that trees t1 and t2 each have an odd number of nodes. Then the tree (sym t1 t2) also has an odd number of nodes, since |t1| + |t2| is even and we have one more node connecting them."
2023-05-14 12:42:27 -0400 < Zipheir> Using |t| to mean the number of nodes in t.
2023-05-14 12:46:42 -0400 < cow_2001> dangit. that is so clear.
2023-05-14 12:51:25 -0400 < cow_2001> backlight tracing your proof for exercise 1.5: a LcExp of the form Identifier has no parenthesis, therefore its parenthesis are balanced. Assume that LcExp foo and bar each has balanced parentheses (also some-identifier is a LcExp of the form Identifier). then the parentheses in (lambda (some-identifier) foo) is obviously balanced and (foo bar) is also obviously balanced.
2023-05-14 12:51:59 -0400 < cow_2001> parentheses, not parenthesis
2023-05-14 12:53:43 -0400 < cow_2001> are not is
2023-05-14 12:56:19 -0400 < cow_2001> i should probably use a more formal proof with numbers and all?
2023-05-14 12:56:54 -0400 < cow_2001> moving my brain in unfamiliar ways
2023-05-14 12:57:09 -0400 < Zipheir> That seems about right.
2023-05-14 12:57:41 -0400 < Zipheir> Just don't over-use "obviously". :)
2023-05-14 12:57:53 -0400 < cow_2001> ~_~
2023-05-14 12:58:10 -0400 < Zipheir> https://en.wikipedia.org/wiki/Proof_by_intimidation
2023-05-14 12:58:21 -0400 < cow_2001> yeah, my "obvious" is not a mathematician's obvious
2023-05-14 12:58:27 -0400 < cow_2001> wait mo
2023-05-14 12:58:29 -0400 < cow_2001> no
2023-05-14 12:58:41 -0400 < cow_2001> the quotes should go on like this:
2023-05-14 12:58:58 -0400 < cow_2001> yeah, my obvious is not a mathematician's "obvious"
2023-05-14 12:59:56 -0400 < Zipheir> But yes, I think that reasoning is fine. There's no need to use numbers if you can get it from syntax alone.
2023-05-14 13:00:59 -0400 < sham1> You do enough proofs and you forget what numbers even are since they just stop being important
2023-05-14 13:04:13 -0400 < cow_2001> sham1: i don't believe you! you're a sham………1
2023-05-14 13:04:16 -0400 < cow_2001> <_<
2023-05-14 13:04:41 -0400 < cow_2001> horrendous patter. sorry
2023-05-14 13:13:01 -0400 < seninha> Behold! Lambda, The Ultimate! https://ttm.sh/Wmq.png
2023-05-14 13:15:05 -0400 < cow_2001> feels retro
2023-05-14 13:15:29 -0400 < cow_2001> and yet, here's that latest firefox icon
2023-05-14 13:16:03 -0400 < cow_2001> seninha: beautiful.
2023-05-14 13:18:34 -0400 < cow_2001> seninha: why is everything the same Simp type? (please forgive my ignorance. never wrote a big C program)
2023-05-14 13:18:47 -0400 < cow_2001> or even medium or small
2023-05-14 13:23:56 -0400 < Zipheir> Probably because "Scheme object" is a disjoint union type.
2023-05-14 13:24:03 -0400 < cow_2001> Zipheir: now i am thinking……… could you prove stuff recursively? if we have t, it is made of (Sym t1 t2). we count this node as 1, and the direct children's node is definitely 1 each, totalling to 3.
2023-05-14 13:24:51 -0400 < wasamasa> is that openstep?
2023-05-14 13:26:24 -0400 < Zipheir> cow_2001: Usually you use induction to build/prove things and recursion to tear them down.
2023-05-14 13:26:49 -0400 < cow_2001> it makes sense in my brain, but i don't know how to say it
2023-05-14 13:29:08 -0400 < Zipheir> If Marc were here he could give us the full mathematical background.
2023-05-14 13:29:18 -0400 < cow_2001> if a child is an int, you add 1, else, you add at least 3.
2023-05-14 13:29:34 -0400 < cow_2001> to the number of nodes
2023-05-14 13:31:00 -0400 < cow_2001> i shouldn't dwell
2023-05-14 13:31:50 -0400 < seninha> cow_2001: all objects i'm using are a union of different things, tagged with an enum
2023-05-14 13:32:06 -0400 < seninha> wasamasa: my desktop?
2023-05-14 13:32:31 -0400 < wasamasa> yes
2023-05-14 13:33:35 -0400 < seninha> no, it's OpenBSD with a window manager i wrote
2023-05-14 13:33:51 -0400 < seninha> https://github.com/phillbush/shod
2023-05-14 13:34:59 -0400 < seninha> i only implemented applicatives, still have to implement operatives (the other kind of closures in the Kernel lisp)
2023-05-14 13:35:50 -0400 < seninha> i also changed "define" to "let", my idea was to write (let ((a b) (c d)) (stuff)) as (begin (let a b) (let c d) (stuff)), but i'm not happy with that decision
2023-05-14 13:36:07 -0400 < cow_2001> seninha: who is the bird in your avatar? yours?
2023-05-14 13:36:44 -0400 < seninha> cow_2001: nope, it's a random image of cactus parakeet i found
2023-05-14 14:04:25 -0400 < cow_2001> imagine if stuff like list-ref returned either (list the-item) or 'some-failure-reason or somesuch :|
2023-05-14 14:05:24 -0400 < Zipheir> cow_2001: More like a Maybe. https://srfi.schemers.org/srfi-189/srfi-189.html
2023-05-14 14:05:45 -0400 < cow_2001> OF COURSE SOMEONE HAD SFRIed it
2023-05-14 14:06:59 -0400 < Zipheir> The nice thing about SRFI 189 Maybes and Eithers is that they can hold any number of values.
2023-05-14 14:08:22 -0400 < Zipheir> It's fairly nice for a procedure that returns multiple values or fails to give either (just v1 v2 ...) or (nothing), rather than some collection of bogus values--or, worse, a different number of values--on failure.
2023-05-14 14:08:51 -0400 < cow_2001> am i a weirdo that i think it should be the default? the default ones are dangerous
2023-05-14 14:09:35 -0400 < Zipheir> You mean the "value or false" pattern?
2023-05-14 14:09:40 -0400 < cow_2001> yes
2023-05-14 14:10:20 -0400 < seninha> i have work with option values on another language, coq, which features dependent types
2023-05-14 14:10:23 -0400 < Zipheir> The more recent SRFIs don't do that anymore, but they don't use SRFI 189. Usually, there's a failure continuation.
2023-05-14 14:10:34 -0400 < seninha> it completely changed my view on types
2023-05-14 14:10:46 -0400 < Zipheir> Yes, I had a similar experience with Agda.
2023-05-14 14:10:56 -0400 < cow_2001> i don't like exploding exceptions
2023-05-14 14:11:29 -0400 < seninha> Zipheir, is Agda emacs-only (or heavily dependent on it)?
2023-05-14 14:12:54 -0400 < seninha> btw, macros implemented. (quote my-symbol) can be easely defined as a Kernel-like macro: https://ttm.sh/WmI.png
2023-05-14 14:12:54 -0400 < Zipheir> seninha: I did try compiling some stuff with it outside of Emacs, with success. But I guess most people use it as a proof assistant through Emacs.
2023-05-14 14:13:14 -0400 < Zipheir> (How the hell do you type all those symbols outside of Emacs?)
2023-05-14 14:13:27 -0400 < seninha> Zipheir: i use X11 compose key
2023-05-14 14:13:31 -0400 < Zipheir> I kid. There is .Xcompose, of course.
2023-05-14 14:13:50 -0400 < Zipheir> Excellent.
2023-05-14 14:15:19 -0400 < seninha> one of my ideas in my lisp is to make everything possible first-class and bound in the same namespace (different of scheme, in which macros and record types are second-class citizens and defined on a separate namespace)
2023-05-14 14:16:05 -0400 < seninha> i also don't know wether i should add something like define-record-type
2023-05-14 14:16:15 -0400 < Zipheir> cow_2001: The old approach is shown by SRFI 1 'find', which can't find #f (since it returns that on failure) in a list. These days, you'd see (find obj lis failure), and 'find' would call failure if obj wasn't found.
2023-05-14 14:16:55 -0400 < Zipheir> (This is equivalent to a find that returns a Maybe.)
2023-05-14 14:17:15 -0400 < Zipheir> seninha: Interesting.
2023-05-14 14:18:00 -0400 < Zipheir> There are arguments against continuations as a design idea, however.
2023-05-14 14:18:40 -0400 < Zipheir> Especially tricky are the cases where the caller must tail-call something, since those procedures can go off the rails if the caller does something cute instead.
2023-05-14 14:24:21 -0400 < seninha> continuations can be useful when implementing a parser or a repl
2023-05-14 14:24:27 -0400 < seninha> idk, never used it for that
2023-05-14 14:26:26 -0400 < Zipheir> You can use them for just about anything. They're amazingly (in fact, too) powerful.
2023-05-14 14:52:43 -0400 < cow_2001> is eopl building towards an ml / haskell type signature thing?
2023-05-14 14:53:27 -0400 < cow_2001> remove-symbol : Symbol × ListOf(Symbol) -> ListOf(Symbol)?
2023-05-14 14:59:08 -0400 < Zipheir> They're just types.
2023-05-14 15:00:16 -0400 < Zipheir> They do eventually implement a statically-typed language, but I don't think they use anything that syntactically complex.
2023-05-14 15:01:19 -0400 < Zipheir> As for whether it's Haskell/ML-like, I think you'll see that same syntax in mathematics books (probably without the camel case).
2023-05-14 15:11:53 -0400 < dpk> seninha: macros and record types are in the same namespace in Scheme
2023-05-14 15:12:43 -0400 < dpk> together with variables
2023-05-14 15:13:09 -0400 < dpk> try e.g. (let-syntax ((foo (syntax-rules () ((_) 'syntax)) (let ((foo (lambda () 'procedure))) (foo)))
2023-05-14 15:13:27 -0400 < dpk> and compare with (let ((foo (lambda () 'procedure))) (let-syntax ((foo (syntax-rules () ((_) 'syntax)))) (foo)))
2023-05-14 15:14:05 -0400 < dpk> first-class macros can't be efficiently compiled and, empirically, don't seem that useful
2023-05-14 15:14:31 -0400 < dpk> first-class syntax extensions are better done by fexprs as in Kernel, but there has also still been no demonstration of an efficient implementation
2023-05-14 15:15:32 -0400 < dpk> (and since John Shutt passed away it's unlikely anyone is really spending much time on trying to make one)
2023-05-14 15:16:21 -0400 < dpk> first-class record types are also a reality in R6RS and in most Scheme implementations generally, but they aren't standardized in R7RS small
2023-05-14 15:33:46 -0400 -!- grettke_ is now known as grettke
2023-05-14 15:36:37 -0400 -!- grettke is now known as grettke_
2023-05-14 15:46:12 -0400 < seninha> at least from the implementing point of view, fexprs are easier to implement: you do not need to deal with several special forms in the evaluator
2023-05-14 15:46:22 -0400 < seninha> everything is an operator
2023-05-14 15:48:45 -0400 < dpk> sure, but if you want performance any better than My First Metacircular Evaluator, you're going to need to compile, which means static analysis of special forms, which isn't possible in the presence of fexprs
2023-05-14 15:49:43 -0400 < seninha> indeed, that's going to be My First Metacircular Evaluator™ :)
2023-05-14 16:04:48 -0400 < seninha> dpk, doesn't inline caching help with that?
2023-05-14 16:05:36 -0400 < seninha> wait, nvm. inline caching seems to have nothing to do with that
2023-05-14 16:15:51 -0400 -!- grettke_ is now known as grettke
2023-05-14 16:59:40 -0400 -!- grettke is now known as grettke_
2023-05-14 17:22:03 -0400 -!- grettke_ is now known as grettke
2023-05-14 18:12:40 -0400 -!- grettke is now known as grettke_
2023-05-14 18:13:11 -0400 -!- grettke_ is now known as grettke
2023-05-14 18:22:44 -0400 -!- grettke is now known as grettke_
2023-05-14 18:23:14 -0400 -!- grettke_ is now known as grettke
2023-05-14 19:33:10 -0400 -!- grettke is now known as grettke_
2023-05-14 19:33:40 -0400 -!- grettke_ is now known as grettke
2023-05-14 19:52:16 -0400 -!- grettke is now known as grettke_
2023-05-14 21:34:07 -0400 -!- grettke_ is now known as grettke
2023-05-14 22:33:00 -0400 -!- grettke is now known as grettke_
2023-05-14 23:33:44 -0400 -!- grettke_ is now known as grettke
2023-05-14 23:46:03 -0400 -!- grettke is now known as grettke_
--- Day changed Mon May 15 2023
2023-05-15 01:48:19 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-15 07:02:34 -0400 -!- qhong_ is now known as qhong
2023-05-15 16:07:47 -0400 < tomhg> Hey. I would like to receive some input about the following snippet: https://termbin.com/mgjlz
2023-05-15 16:09:47 -0400 < tomhg> I am not getting why the stream does not result in six lists grouping digits of five resulting in an output of `((30 29 28 27 26) ... (4 3 2 1 0))`. It works flawlessly in recursion but since I am working on an stateful emitter I am in desperate need to use a stream to aid constructing my algorithm.
2023-05-15 16:12:10 -0400 < tomhg> ;; the snippet is a prior increment from the weekend which is why the length of 9 is incorrect. The 8 should be replaced by a 4 but I was just trying and erroring.
2023-05-15 16:14:31 -0400 < tomhg> nvm. I revert to the initial state. This snippet is wrong.
2023-05-15 16:30:02 -0400 < tomhg> I'm out. That stream API is obnoxious in my _current_ experience.
2023-05-15 16:30:18 -0400 < Zipheir> It seems to me that using streams *and* a generator procedure is overkill. It might even lead to surprises.
2023-05-15 16:31:01 -0400 < Zipheir> Generators/Lazy sequences XOR streams, I say.
2023-05-15 16:32:10 -0400 < tomhg> I just did an accumulator where i skipped the cudder `(stream-cons _ (stream-cdr strm))`. But I still dont see my misconception.
2023-05-15 16:32:23 -0400 < tomhg> I would appreciate a small hint to be quite honest
2023-05-15 16:33:05 -0400 < tomhg> In terms of LOC.
2023-05-15 16:33:46 -0400 < Zipheir> tomhg: Maybe you've already looked at them, but can you use SRFI 158 generators and accumulators?
2023-05-15 16:34:21 -0400 < Zipheir> I don't mean to say "don't do that, then"; I just think it might save some wheel-reinvention.
2023-05-15 16:34:22 -0400 < tomhg> Zipheir: Thank you. I didn't thought about them. I will now compare them until I have some understanding.
2023-05-15 16:36:58 -0400 < Zipheir> Apropos of nothing, two of the R6RS wrote a really nice book with Felleisen https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/  (Too bad it's only available at the low, low price of $55)
2023-05-15 16:37:08 -0400 < Zipheir> *the R6RS authors
2023-05-15 16:42:49 -0400 < Zipheir> tomhg: I don't understand why you need to use set! to write a 'group' function on streams. It should be easy enough to write without mutation.
2023-05-15 16:43:52 -0400 < Zipheir> There's definitely something fishy about that 'accumulator!' procedure.
2023-05-15 16:44:46 -0400 < Zipheir> Or maybe it's just the weirdness of using it with stream-fold …
2023-05-15 16:49:52 -0400 < tomhg> Just now I thought you pointed me to my error that the last element of the iteration should be a new stream which would read as `(stream-of (cons ..buf.. new-stream-list))`; But it didn't. And while writing this I feel that this is wrong but I can not pinpoint my misconception. I want to iterate a stream which is reduced beforehand from a stream. The accumulator should reduce it by consuming X-elements.
2023-05-15 16:51:37 -0400 < tomhg> I take your input and put my experience/issues/success here.
2023-05-15 16:52:02 -0400 < Zipheir> "reduced beforehand"?
2023-05-15 16:52:26 -0400 < acdw> (stream-of (cons cious ness))
2023-05-15 16:52:42 -0400 < tomhg> yes. I want a stream of 6 lists where each lists contains the elements of five in order.
2023-05-15 16:53:19 -0400 < Zipheir> You can write that with stream-take and -drop.
2023-05-15 16:53:25 -0400 < tomhg> ^ that shows me that I am confused and should read up upon the entire specification of 41 and 158 with cautioness.
2023-05-15 16:54:27 -0400 < tomhg> Thanks, Zipheir, for taking your time.
2023-05-15 16:54:30 -0400 < Zipheir> In any case, mixing streams and set! is always asking for trouble.
2023-05-15 16:55:10 -0400 < tomhg> Thought I knew the implications and tried to make use of lexical scoping ...
2023-05-15 16:55:45 -0400 < Zipheir> It's a clever way to implement an accumulator, but it needs some refinement.
2023-05-15 16:56:27 -0400 < Zipheir> SRFI 158 accumulators use a magic cookie (EOF) as a signal to return their contents.
2023-05-15 16:58:54 -0400 < Zipheir> tomhg: I'll also mention that you can write the grouping function with stream-fold and no mutation.
2023-05-15 16:58:57 -0400 < tomhg> If I would have understood the implementation of streams 100% correctly could I make use of call/cc?
2023-05-15 16:59:33 -0400 < tomhg> Zipheir: I tried that but before you put more time into it, I will compare your links. You also answered my last question with that.
2023-05-15 16:59:45 -0400  * tomhg puts user-error
2023-05-15 17:00:15 -0400 < Zipheir> I'm not sure anyone understands streams 100%. (If Mary understood color 100%, she can probably predict her reactions to it.)
2023-05-15 17:01:00 -0400 < Zipheir> tomhg: You'd probably be better off using make-coroutine-generator from SRFI 158.
2023-05-15 17:02:14 -0400 < tomhg> I owe you and this channel; Like I said. Hopefully someday I can give back. Thanks for calming me down and point to some solutions. I have no mentor/rubberduck for such things.
2023-05-15 17:03:04 -0400 < Zipheir> tomhg: The idea of grouping with fold is to fold with multiple values (in a list, probably). One is a counter (how many elements in the current group?), another is a buffer, and one is the result stream.
2023-05-15 17:03:30 -0400 < Zipheir> tomhg: Of course. Feel free to keep asking questions.
2023-05-15 17:03:40 -0400 < tomhg> Zipheir: the second was my attempt.
2023-05-15 17:04:04 -0400 < Zipheir> Ah, OK.
2023-05-15 17:04:25 -0400 < tomhg> Anyhow. You are wasting time. I take your input and come back here prob. On Sunday at 22 p.m. GMT
2023-05-15 17:04:38 -0400 < Zipheir> That's rather specific.
2023-05-15 17:05:30 -0400 < tomhg> :o) My week is scheduled. On saturday at 5 p.m. GMT +1 the 24h of Nürnburgring starts.
2023-05-15 17:06:03 -0400 < Zipheir> Wow.
2023-05-15 17:08:48 -0400  * tomhg nods
2023-05-15 19:13:39 -0400 -!- qhong_ is now known as qhong
2023-05-15 23:27:49 -0400 -!- Andrew is now known as AndrewYu
--- Day changed Tue May 16 2023
2023-05-16 02:23:31 -0400 < lockywolf> Has anyone seen rrdtool bindings for Scheme?
2023-05-16 04:40:40 -0400 < lockywolf> Which Schemes work on Plan9? I remember Chibi, but do many features work?
2023-05-16 05:10:44 -0400 < dpk> i suspect it's only Chibi
--- Log closed Tue May 16 09:53:12 2023
--- Log opened Tue May 16 10:03:25 2023
2023-05-16 10:03:25 -0400 -!- Irssi: #scheme: Total of 197 nicks [0 ops, 0 halfops, 0 voices, 197 normal]
2023-05-16 10:03:25 -0400 -!- Irssi: Join to #scheme was synced in 6 secs
2023-05-16 11:37:27 -0400 < gwatt> scheme 9 from empty space
2023-05-16 13:01:01 -0400 < Zipheir> gwatt: I've never tried it on Plan 9, but it supposedly works. It has some of the best source-code quality among Scheme implementations.
2023-05-16 13:15:20 -0400 < sham1> Didn't the author literally write a book on it
2023-05-16 13:21:39 -0400 < Zipheir> Yes.
2023-05-16 13:22:30 -0400 < Zipheir> I guess nothing makes you simplify your program like having to explain it procedure by procedure.
2023-05-16 13:47:55 -0400 < gwatt> Zipheir: I have tried it on plan 9
2023-05-16 13:48:02 -0400 < gwatt> and it did work
2023-05-16 13:50:58 -0400 < acdw> i'm waiting for plan 10
2023-05-16 13:51:43 -0400 < gwatt> I hope you're prepared to wait for a while.
2023-05-16 13:51:53 -0400 < acdw> lol
2023-05-16 14:02:12 -0400 < Zipheir> "And remember my friends; future events such as these will affect you in the future."
2023-05-16 14:02:56 -0400 < Zipheir> If there's a Plan 10, it won't involve Rob Pike, who now calls OS research "irrelevant".
2023-05-16 14:03:02 -0400 < acdw> :O
2023-05-16 14:03:12 -0400 < acdw> he's stepped down a level
2023-05-16 14:05:35 -0400 < Zipheir> It may be sour grapes.
2023-05-16 14:20:15 -0400 < shawnw> Inferno is Plan 10.
2023-05-16 14:20:19 -0400 < acdw> oh yeah!
2023-05-16 14:46:01 -0400 < mdhughes> Inferno is Java, but irrelevant.
2023-05-16 16:45:32 -0400 < sham1> We go up to 11
2023-05-16 23:47:22 -0400 -!- greaser|q is now known as GreaseMonkey
--- Day changed Wed May 17 2023
2023-05-17 04:45:50 -0400 < lockywolf> Is there anything for which Plan9 is good?
2023-05-17 04:46:06 -0400 < lockywolf> Because it is generally hard to learn something for which there is no good use-case.
2023-05-17 04:46:32 -0400 < lockywolf> Scheme has SICP, a few other books, and it is an extension language for Gimp and GDB.
2023-05-17 04:46:43 -0400 < lockywolf> So you can jump into the story.
2023-05-17 04:46:47 -0400 < sham1> Plan9 has/had good ideas
2023-05-17 04:47:07 -0400 < sham1> For example the /proc in Linux was influenced by Plan9's /proc
2023-05-17 04:47:07 -0400 < lockywolf> But I am not aware of similarly cool things for plan9.
2023-05-17 04:47:49 -0400 < wasamasa> several good ideas from plan9 have been stolen
2023-05-17 04:48:17 -0400 < wasamasa> for example their rendering system made it into the x11 render extension (which seemingly everything uses)
2023-05-17 04:48:36 -0400 < wasamasa> plan9fs made it into windows for some VM stuff
2023-05-17 04:48:55 -0400 < wasamasa> the union mounts have been emulated poorly by GOPATH
2023-05-17 04:49:03 -0400 < lockywolf> I remember that in P9 you could "cat" remote files, and pipe graphical output into other programs
2023-05-17 04:49:08 -0400 < wasamasa> the sources are very easy to read
2023-05-17 04:49:51 -0400 < wasamasa> rc is like a sane version of sh
2023-05-17 04:50:06 -0400 < lockywolf> wasamasa: but wouldn't real schemers use scsh?
2023-05-17 04:50:13 -0400 < lockywolf> or (chibi shell)
2023-05-17 04:50:14 -0400 < wasamasa> scsh is not a command shell
2023-05-17 04:50:36 -0400 < wasamasa> similarly, scheme is not a command language
2023-05-17 04:50:37 -0400 < lockywolf> well, running (run (ls)) is not that much more code than ls
2023-05-17 04:50:58 -0400 < wasamasa> sure, but it's different
2023-05-17 04:51:22 -0400 < wasamasa> (run (ls)) is a very specific DSL
2023-05-17 04:51:31 -0400 < wasamasa> designed to work inside a scheme program
2023-05-17 04:51:47 -0400 < sham1> Having to do that for interactive shell work would be annoying
2023-05-17 04:52:15 -0400 < wasamasa> whereas the rc paper reads like someone tried to think how the design of sh could be simplified to the bare minimum required to do useful work
2023-05-17 04:52:19 -0400 < lockywolf> sham1: would you prefer (ls) ?
2023-05-17 04:52:29 -0400 < wasamasa> omitting all the stupid edge cases and duplicated features
2023-05-17 04:52:34 -0400 < sham1> I'd prefer ls franklyu
2023-05-17 04:52:54 -0400 < sham1> Like we can just take a look of eshell
2023-05-17 04:53:09 -0400 < lockywolf> that doesn't look sexpy...
2023-05-17 04:54:57 -0400 < sham1> Sure it does. It's symbols
2023-05-17 04:55:37 -0400 < dave0> what if instead of ls cat rm mv we changed the names to list type delete rename
2023-05-17 04:56:13 -0400 < wasamasa> ITYM concatenate
2023-05-17 04:56:36 -0400 < sham1> ITYM catenate
2023-05-17 04:57:06 -0400 < sham1> Well, at least it'd make the purpose of `cat` clearer
2023-05-17 04:57:23 -0400 < wasamasa> the sheer amount of useless use of cat would lessen, hopefully
2023-05-17 04:57:53 -0400 < lockywolf> that usage of cat is not useless
2023-05-17 04:58:12 -0400 < lockywolf> cat X | grep B is much more intuitive than grep B X
2023-05-17 04:58:18 -0400 < sham1> I swear most of that just comes from the fact that people don't know that `cat file | cmd` and `cmd < file` accomplish the same thing, except the former wastes a pipe and is a useless use of cat
2023-05-17 04:58:19 -0400 < lockywolf> and is a proper unix-way
2023-05-17 04:58:52 -0400 < lockywolf> sham1: you can do `cat < <(cat file)`
2023-05-17 04:58:59 -0400 < sham1> Hell, they probably don't even know that the latter is a thing
2023-05-17 04:59:06 -0400 < lockywolf> sorry  `cmd < <(cat file)`
2023-05-17 04:59:27 -0400 < sham1> I avoid bashisms if I can help it
2023-05-17 05:00:10 -0400 < dave0> not once did you use cat to catenate files :-)
2023-05-17 05:01:18 -0400 < mdhughes> cat really ought to be a builtin for < on the next command. But people type it because it expresses intent, efficiency isn't as important as readability.
2023-05-17 05:02:08 -0400 < sham1> I suppose, although I do find the stdin redirection to be more readable. To each their own I suppose
2023-05-17 05:02:15 -0400 < mdhughes> I have a bunch of shell commands rebuilt in my library, for use in build scripts and such. It's a fine way to work, just more verbose than shell.
2023-05-17 05:03:28 -0400 < sham1> If poweshell wasn't so silly, it might just be the answer
2023-05-17 05:03:50 -0400 < wasamasa> I regularly use `cat *.log | less` because using less on multiple files sucks
2023-05-17 05:04:03 -0400 < wasamasa> it do be funny when people ask how to combine files
2023-05-17 05:04:37 -0400 < wasamasa> you can almost sense the "I've always used it wrong?" in their eyes
2023-05-17 05:04:42 -0400 < mdhughes> For that use, I have a catfiles script, which echoes filename & divider between files.
2023-05-17 05:05:59 -0400 -!- msavoritias_ is now known as msavoritias
2023-05-17 05:09:01 -0400 < sham1> `cat *.log | less` at least makes sense. At least then you're actually using it for what it is meant for and even if you have only one .log-file then at least the intention is clear
2023-05-17 05:09:13 -0400 < sham1> But as said, most people seem to hold it wrong
2023-05-17 05:09:37 -0400 < mdhughes> So they should shift to a completely different syntax when it's one item?
2023-05-17 05:09:55 -0400 < wasamasa> if you want to display a file in an interactive terminal, pagers exist
2023-05-17 05:11:08 -0400 < wasamasa> FWIW, you can redirect multiple files
2023-05-17 05:12:03 -0400 -!- msavoritias_ is now known as msavoritias
2023-05-17 05:14:30 -0400 < flatwhatson> i guess you could say that cats are bad for the environment
2023-05-17 05:15:04 -0400 < mdhughes> cats are user friendly, and an essential part of your shell workflow.
2023-05-17 05:15:27 -0400 < mdhughes> This "cat abuse" meme is a thought-terminating cliche.
2023-05-17 05:36:33 -0400 < lockywolf> dogs can't operate MRI machines, but CATSCAN
2023-05-17 05:36:43 -0400 < dTal> maybe if people keep using the user interface "wrong", the interface is bad and should be fixed instead of shaming the users for decades
2023-05-17 05:38:20 -0400 < dTal> (frankly the entire user interface of modern unix and especially linux is a giant steaming pile and the whole thing should be rewritten from the ground up)
2023-05-17 05:38:37 -0400 < lockywolf> dTal: if people sin, we should just make sinning impossible, rather than try and educate people
2023-05-17 06:03:56 -0400 < cow_2001> exercise 1.6 is badly written. i do not know what they mean by reverse, as i can think of a bunch of ways to reverse these ifs.
2023-05-17 06:19:21 -0400 < cow_2001> in eopl3
2023-05-17 08:03:32 -0400 < lockywolf> cow_2001: have you finished SICP?
2023-05-17 08:15:15 -0400 < cow_2001> lockywolf: no <_<
2023-05-17 08:27:29 -0400 < cow_2001> lockywolf: should i stay with it without trying other stuff? i skipped a bit of chapter 3
2023-05-17 09:35:54 -0400 < lockywolf> 🤷
2023-05-17 11:08:35 -0400 < Zipheir> cow_2001: I don't understand why you think it's badly written. nth-element tests (null? lst), then tests (zero? n), in that order. So, what happens with the opposite order?
2023-05-17 11:09:43 -0400 < Zipheir> There are a few possible answers, but it makes sense to talk of swapping the tests.
2023-05-17 11:31:34 -0400 < cow_2001> Zipheir: do you swap the test themselves alone or also what you do after?
2023-05-17 11:32:00 -0400 < cow_2001> you could swap the two and still get the right answer if you duplicate one of them
2023-05-17 11:32:05 -0400 < cow_2001> err the inner one
2023-05-17 11:33:15 -0400 < Zipheir> Yeah, there are still several possible answers.
2023-05-17 11:34:03 -0400 < Zipheir> I think they want you to realize that, if you do swap them, you also have to duplicate one of them; as you say.
2023-05-17 11:35:54 -0400 < cow_2001> oh no. someone resurrected jesus on twitch using bozo's bazilisk
2023-05-17 11:36:01 -0400 < acdw> lmao
2023-05-17 12:16:14 -0400 < cow_2001> i'm writing my eopl3 solutions into a single org file
2023-05-17 14:15:53 -0400 < tomhg> cow_2001: I am exiting about your write up!! Though *.org is discrimating to me :)
2023-05-17 14:26:24 -0400 < acdw> eopl3?
2023-05-17 14:28:24 -0400 < tomhg> essentials of programming languages, edition three
2023-05-17 14:29:47 -0400 < acdw> ohhh fun
2023-05-17 14:38:22 -0400 < tomhg> acdw: It is a important read. Within this channel there are people understanding every essence. I suggest reading it on your own or - if beeing an inconvenient read - ask for some substition regarding a specific topic. Myself is a newbie and I have things already suggested to aid my lackings
2023-05-17 14:43:26 -0400 < acdw> oo
2023-05-17 14:43:32 -0400 < acdw> link? or library
2023-05-17 14:43:46 -0400 < tomhg> It is a book.
2023-05-17 14:43:55 -0400 < acdw> nice
2023-05-17 14:43:59 -0400 < acdw> i'll have to try and find it
2023-05-17 14:45:09 -0400 < tomhg> I may have realized that mnieper did provide me with aid. Maybe I can do my own tokenization. So I can apply mniepers library. Just wanted to note that I have been wrong and spotted it.
2023-05-17 14:45:29 -0400 < tomhg> acdw: May I ask whats your current efforts are for, regarding scheme?
2023-05-17 14:45:40 -0400 < acdw> having fun mostly
2023-05-17 14:46:03 -0400 < acdw> maybe One Day I'll git gud and like, get a job, lol
2023-05-17 14:46:38 -0400 < tomhg> acdw: Then try to deduce a lexer-generator from mniepers parser-generator. That sounds fun!
2023-05-17 14:47:13 -0400 < acdw> hm
2023-05-17 14:47:16 -0400 < acdw> i might!
2023-05-17 14:48:24 -0400  * tomhg *nods*
2023-05-17 14:56:13 -0400 < cow_2001> tomhg: writeup? more than half of the time i am not sure if i have a sufficient answer
2023-05-17 15:08:07 -0400 < Zipheir> acdw: You can find it on LibGen. You can also find copies of the second edition for next to nothing.
2023-05-17 15:09:50 -0400 < Zipheir> In some ways the second edition is more elegant.
2023-05-17 15:15:55 -0400 < acdw> owo
2023-05-17 15:18:42 -0400 < cow_2001> <_<
2023-05-17 15:19:24 -0400 < cow_2001> Zipheir: 1. you don't talk about fight club. 2. you don't talk about fight club.
2023-05-17 15:20:01 -0400 < cow_2001> 1. you don't talk about the internet reading club. 2. you don't talk about the internet reading club. ?!?
2023-05-17 15:25:39 -0400 < Zipheir> It's not illegal, at least in my current jurisdiction. In any case, reading for personal education *should* be fair use.
2023-05-17 15:25:55 -0400 < acdw> >_>
2023-05-17 15:28:21 -0400 < Zipheir> Hey, I recommend books on the Internet Archive all the time, and they're being sued by publishers for their "controlled lending". Who's to say who's legitimate?
2023-05-17 15:29:09 -0400 < Zipheir> Sorry, that's quite off topic. I do recommend EoPL. It is lots of fun.
2023-05-17 15:30:03 -0400 < acdw> i'd say that the endless corporate creeping into every aspect of modern life is on topic everywhere
2023-05-17 15:30:15 -0400 < acdw> hm should i visit libgen at work
2023-05-17 16:29:39 -0400 < sham1> Probably not
2023-05-17 16:30:42 -0400 < acdw> lol
2023-05-17 17:55:57 -0400 -!- greaser|q is now known as GreaseMonkey
2023-05-17 18:36:49 -0400 < cow_2001> when are we going to get scheme on the browser? impatient.
2023-05-17 19:53:31 -0400 < acdw> guile has wasm doesn't it
2023-05-17 19:55:48 -0400 < Zipheir> Or maybe it was hasm.
2023-05-17 19:56:03 -0400 < flatwhatson> a wasm compiler is in development: https://gitlab.com/spritely/guile-hoot-updates
2023-05-17 21:39:26 -0400 < acdw> that looks a+
2023-05-17 21:43:10 -0400 < lockywolf> acdw: where is that "endless corporate creeping"? because I see none of that, besides in leftist propaganda.
2023-05-17 21:43:37 -0400 < lockywolf> cow_2001: chibi works in the browser
2023-05-17 21:43:42 -0400 < lockywolf> with emscripten
2023-05-17 21:44:20 -0400 < lockywolf> cow_2001: https://lockywolf.net/chibi-js/
2023-05-17 21:47:50 -0400 < flatwhatson> "endless corporate creeping" could be interpreted as perpetual growth, which is an integral part of our economic system, or increasing invasions of privacy (consensual or otherwise)
2023-05-17 21:48:04 -0400 < flatwhatson> i don't think you need "leftist propaganda" to acknowledge either of those things
2023-05-17 21:49:22 -0400 < flatwhatson> in the case of books, it's probably referring to the issue of eternal copyright vs public domain
2023-05-17 21:49:34 -0400 < lockywolf> Well, I rather like perpetual growth, I call it "progress". I see no connection with "corporate" here.
2023-05-17 21:49:53 -0400 < lockywolf> flatwhatson: "eternal copyright" has nothing to do with "corporate" either.
2023-05-17 21:51:32 -0400 < lockywolf> "copyright" is a law. A law is established by the state authorities via institutionalised violence, not by firms by trying to make money by doing what the state is telling them to do.
2023-05-17 21:51:35 -0400 < Zipheir> lockywolf: Movie, media, and publishing conglomerates are undoubtedly the biggest pushers of copyright extension.
2023-05-17 21:51:39 -0400 < flatwhatson> i think it's safe to say that corporations are the largest beneficiaries of all of the above.  arguably consumers benefit from the privacy vs convenience tradeoff.
2023-05-17 21:52:22 -0400 < flatwhatson> and you could say that the others benefit everyone indirectly via progress etc.
2023-05-17 21:52:54 -0400 < lockywolf> Zipheir: the biggest beneficiary is the government, which has a few large entities to control and threaten, rather than thousands of small entities, which are as easy to grab as water in the ocean.
2023-05-17 21:53:20 -0400 < flatwhatson> my point is simply that we can discuss these things honestly without partisan nonsense like "leftist propaganda"
2023-05-17 21:53:34 -0400 < Zipheir> Yeah, that's just silly.
2023-05-17 21:53:50 -0400 < lockywolf> "leftist propaganda" is an objective fact.
2023-05-17 21:54:40 -0400 < lockywolf> People who are repeatedly trying to victim-blame productive forces into submission to the institutionalised violence cannot be called otherwise.
2023-05-17 21:54:45 -0400 < Zipheir> Well, this isn't really relevant to Scheme at all.
2023-05-17 21:55:02 -0400 < flatwhatson> it's a non-sequitur reflecting your personal political bias, which is quite irrelevant
2023-05-17 21:55:26 -0400 < lockywolf> Zipheir: you see, when the discussion is about what is convenient to you, it is "just discussing copyright", when it is something you dislike, it is "not relevant to Scheme at all".
2023-05-17 21:55:51 -0400 < lockywolf> flatwhatson: no, it is your political bias being presented as on-topic
2023-05-17 21:55:51 -0400 < Zipheir> lockywolf: If you look at the scrollback, I admitted it was an off-topic remark.
2023-05-17 21:56:22 -0400 < lockywolf> Zipheir: you are right in this respect.
2023-05-17 21:56:28 -0400 < acdw> it's hilarious you're calling giant multinational conglomerates controlling literal trillions of dollars the victims in this situation
2023-05-17 21:56:46 -0400 < acdw> the power is increasingly flowing from corporate interests to government
2023-05-17 21:57:13 -0400 < acdw> I mean I am also a leftist so ymmv
2023-05-17 21:57:23 -0400 < Zipheir> I just want the tone here to stay respectful.
2023-05-17 21:57:53 -0400 < lockywolf> Zipheir: I agree, I am sorry for the tone.
2023-05-17 21:58:48 -0400 < acdw> heard
2023-05-17 21:59:14 -0400 < lockywolf> acdw: the existence of "conglomerates" is at the pleasure of the governments
2023-05-17 21:59:48 -0400 < Zipheir> They are doing their best to change that.
2023-05-17 22:00:18 -0400 < flatwhatson> there's a hilarious scandal here where PwC consultants to government wrote anti-tax-avoidance policy, and then advised their corporate clients on how to bypass that policy
2023-05-17 22:00:20 -0400 < lockywolf> Yukos used to be a "large multinational conglomerate", until its president was thrown in jail, and the lawsuit of the rest of the shareholders against the government is still ongoing, 20 years after the event.,
2023-05-17 22:00:53 -0400 < lockywolf> Can literally happen to any "multinational congolmerate" overnight.
2023-05-17 22:01:07 -0400 < lockywolf> Huawei used to be big in the USA, where is that Huawei now?
2023-05-17 22:01:26 -0400 < lockywolf> Not a single piece of Huawei products sold in the US last year.
2023-05-17 22:01:51 -0400 < acdw> apple, alphabet, meta, ...?
2023-05-17 22:02:04 -0400 < acdw> like okay there are counterexamples but there are far more examples
2023-05-17 22:02:04 -0400 < lockywolf> yes, can happen to them just easily
2023-05-17 22:02:08 -0400 < acdw> disney
2023-05-17 22:02:36 -0400 < Zipheir> Especially with multinationals like Huawei, it's very hard for any one government to "decapitate" them.
2023-05-17 22:02:42 -0400 < lockywolf> Those are not "counterexamples", those are "showcases"
2023-05-17 22:02:56 -0400 < acdw> I mean anything can happen. my point is it won't. because they've done the work to buy the government. which is possible because of the broken premise of the capitalistic system
2023-05-17 22:02:58 -0400 < acdw> ok
2023-05-17 22:02:59 -0400 < lockywolf> "Do as we say, or you will meet that destiny"
2023-05-17 22:03:45 -0400 < acdw> I think we're in agreement that corpos and govt are working together to enrich the already wealthy at the hurt of everyone else
2023-05-17 22:03:53 -0400 < acdw> we disagree on the direction of that power flow
2023-05-17 22:03:57 -0400 < lockywolf> of course
2023-05-17 22:04:41 -0400 < lockywolf> Well, no doubt there is some power flowing in the reverse direction, from the corpos into the government.
2023-05-17 22:06:31 -0400 < lockywolf> But just comparing the scale makes it all very obvious. Getting a politician displaced or a policy changed, it significant work for a corpo. Lots of money, lots of lobbying, years of getting in touch with the officials. Whereas in the other direction, it is extremely easy.
2023-05-17 22:07:00 -0400 < lockywolf> Overnight, your CEO is in jail, and that's it.
2023-05-17 22:07:18 -0400 < acdw> I see precisely the opposite. look at how little money it takes to have a politician vote in any way you wish
2023-05-17 22:07:25 -0400 < acdw> lol that's not at all the end of the story
2023-05-17 22:07:45 -0400 < flatwhatson> that depends greatly on how good your system of government is
2023-05-17 22:07:47 -0400 < acdw> CEO in jail = install a new one, pay a pallet fine, pretend it never happened
2023-05-17 22:08:03 -0400 < lockywolf> I have yet to see that.
2023-05-17 22:08:08 -0400 < acdw> I mean I'm in America, the land where corporations are people but done people apparently aren't
2023-05-17 22:08:12 -0400 < Zipheir> lockywolf: This is simply not true in some places. Take a look at the hobbled, gridlocked US FCC. It's been under the thumb of US telecoms to such an extent that the last head FCC commissioner was, in fact, a Verizon lawyer.
2023-05-17 22:08:31 -0400 < acdw> I can find the news stories
2023-05-17 22:08:45 -0400 < lockywolf> Zipheir: why there even is an FCC?
2023-05-17 22:09:06 -0400 < acdw> they happen all the time. hell, the morning church was just found doing massive securities fraud and they were fined something like half a percent of what they made
2023-05-17 22:09:12 -0400 < lockywolf> To restrict the market and make providing a service to the people only viable for giant, controllable firms.
2023-05-17 22:09:35 -0400 < acdw> mmm no
2023-05-17 22:09:42 -0400 < lockywolf> Whoever is heading that FCC is irrelevant, the thing is that FCC exists.
2023-05-17 22:09:57 -0400 < acdw> restrict the market yes. otherwise no radio would get thru at all
2023-05-17 22:10:08 -0400 < lockywolf> lols
2023-05-17 22:10:16 -0400 < flatwhatson> i think the original idea is they're there to stop everyone getting microwaved
2023-05-17 22:10:20 -0400 < lockywolf> radiowaves would just suddenly cease to exist
2023-05-17 22:10:22 -0400 < acdw> isn't that how electromagnetic radiation works?
2023-05-17 22:10:39 -0400 < Zipheir> lockywolf: Among other things, the FCC is supposed to prevent the situation we have in the US: internet and telecom being controlled by several regional monopolies.
2023-05-17 22:10:45 -0400 < acdw> you can jam the frequency. it happens when too many devices are on wifi
2023-05-17 22:10:48 -0400 < lockywolf> yeah, it only works if FCC permits it to work
2023-05-17 22:10:55 -0400 < acdw> but it doesn't because of regulatory captur
2023-05-17 22:11:05 -0400 < acdw> which fcc does permit it because it's owned by telecons
2023-05-17 22:11:21 -0400 < lockywolf> acdw: it happens with wifi anyway
2023-05-17 22:11:52 -0400 < acdw> because there is only one or two frequencies that everything communicates on
2023-05-17 22:11:55 -0400 < lockywolf> and we don't know how much of it is happening with GSM/CDMA, because most of us don't have precise equipment
2023-05-17 22:11:55 -0400 < Zipheir> acdw: At the moment it's gridlocked between actual regulators and former telecom lobbiests.
2023-05-17 22:12:03 -0400 < acdw> ah
2023-05-17 22:12:43 -0400 < lockywolf> if your phone doesn't have coverage, you actually have no idea why
2023-05-17 22:12:47 -0400 < Zipheir> lockywolf: Anyway, I don't think there's a big conspiracy here.
2023-05-17 22:12:57 -0400 < lockywolf> What is "conspiracy"?
2023-05-17 22:13:14 -0400 < lockywolf> The desire of the government to control everything is not a conspiracy.
2023-05-17 22:13:36 -0400 < lockywolf> It's just how it behaves, often even openly announcing its intentions.
2023-05-17 22:13:40 -0400 < lockywolf> (not always)
2023-05-17 22:14:48 -0400 < Zipheir> Perhaps.
2023-05-17 22:15:39 -0400 < acdw> I'm curious what country you're in
2023-05-17 22:16:46 -0400 < Zipheir> lockywolf: But important regulatory parts of the US government, at least, have very limited ability to act, in part because of what *other* parts of the government do to them.
2023-05-17 22:16:57 -0400 < Zipheir> So it is a bit more complicated.
2023-05-17 22:17:57 -0400 < lockywolf> Well, I agree that it is not always easy.
2023-05-17 22:18:38 -0400 < lockywolf> acdw: you can google for Yukos, obviously :)
2023-05-17 22:18:47 -0400 < lockywolf> or Huawei :)
2023-05-17 22:19:29 -0400 < lockywolf> Zipheir: let me say it like this -- large companies cannot exist without government affinity
2023-05-17 22:19:55 -0400 < lockywolf> if your company is >300 people, it loses efficiency and loses the competition
2023-05-17 22:20:26 -0400 < lockywolf> of these 300, 50 are engineers, 50 are managers, 100 are field stuff, and 100 do nothing
2023-05-17 22:21:11 -0400 < lockywolf> if you have anything larger than that in your country, that's because there is some loophole in the regulation which it is exploiting
2023-05-17 22:21:41 -0400 < lockywolf> (such as copyright)
2023-05-17 22:21:54 -0400 < Zipheir> Good luck operating a mail system for a large company with 300 employees. :)
2023-05-17 22:22:00 -0400 < Zipheir> *large country
2023-05-17 22:22:39 -0400 < acdw> I know Huawei is Chinese. is that where you are or are you being coy
2023-05-17 22:22:46 -0400 < lockywolf> I had no problem sending a postcard from Luxembourg to Latvia.
2023-05-17 22:22:58 -0400 < Zipheir> Although I suppose mail services are public organizations in many countries.
2023-05-17 22:23:30 -0400 < lockywolf> Not sure how many LX or LV mail systems have employees, but there is no problem getting mail delivered between small countries.
2023-05-17 22:23:37 -0400 < acdw> I ask because I think the political situations can be extremely different country to country and you might be looking at things from a different view. in America corporations are far too big and too powerful
2023-05-17 22:23:42 -0400 < lockywolf> acdw: I do work in China
2023-05-17 22:24:15 -0400 < Zipheir> lockywolf: Oh, sure. But try serving a country the size of China with 300 mail personnel.
2023-05-17 22:24:20 -0400 < acdw> yeah I can totally believe that there, the government owns the corps. here it's utterly the opposite sadly
2023-05-17 22:24:36 -0400 < acdw> it's all authoritarianism just of different types
2023-05-17 22:24:38 -0400 < lockywolf> well, the government doesn't _entirely_ own Huawei.
2023-05-17 22:24:50 -0400 < lockywolf> in fact, Huawei can demand quite a lot from the government in response
2023-05-17 22:25:19 -0400 < acdw> oh so now I'm agreeing with you you're backing off your argument, intersting
2023-05-17 22:25:22 -0400 < acdw> ;)
2023-05-17 22:25:33 -0400 < lockywolf> acdw: :D
2023-05-17 22:25:49 -0400 < lockywolf> Haven't I already said that it is complicated :)?
2023-05-17 22:26:29 -0400 < lockywolf> Zipheir: can I has a Latvia-sized mail company in Hubei, and a Luxembourd-sized mail company in Hunan, please?
2023-05-17 22:26:58 -0400 < lockywolf> Seriously, I see no problem.
2023-05-17 22:27:19 -0400 < lockywolf> The international mail system exists. The world is _not_ served mail by a single company.
2023-05-17 22:27:42 -0400 < lockywolf> China has about 20 functioning mail companies besides "China Post".
2023-05-17 22:28:00 -0400 < lockywolf> I would have preferred 200, but 20 is much better than 1.
2023-05-17 22:28:35 -0400 < lockywolf> And they cooperate. Like, my quarter has a post office from ShunFeng, but other mail companies can leave their parcels there too.
2023-05-17 22:29:09 -0400 < lockywolf> not joking
2023-05-17 22:30:00 -0400 < lockywolf> Moreover, my district has three post offices from three competing mail companies.
2023-05-17 22:30:42 -0400 < lockywolf> The ShunFeng one is the nearest, so companies usually drop their parcels there, but if there is overload, or many complaints, they can choose one of the other two.
2023-05-17 22:32:09 -0400 < lockywolf> So I like it Zipheir that you have mentioned mail, because it is a living example that mail _can_ be very market-efficient, competitive, and privately run.
2023-05-17 22:33:09 -0400 < Zipheir> It's a nice theory, but then you get regional monopolies and companies charging extra to serve poor areas.
2023-05-17 22:33:21 -0400 < lockywolf> 🤷
2023-05-17 22:33:28 -0400 < lockywolf> the world is not ideal
2023-05-17 22:33:45 -0400 < Zipheir> The Invisible Hand is not a panacea.
2023-05-17 22:34:22 -0400 < acdw> let's just all live in communes of 200
2023-05-17 22:34:28 -0400 < lockywolf> Well, I believe that this vibrant system can only exist with the Taobao levels of postal deliveries.
2023-05-17 22:34:50 -0400 < lockywolf> With the amount of mail from the 20th century, it wouldn't have enough cash flow to be so convenient.
2023-05-17 22:35:32 -0400 < lockywolf> I believe, most mail systems in the 20th century were not profitable.
2023-05-17 22:36:15 -0400 < Zipheir> There's no reason for public mail systems to be profitable.
2023-05-17 22:36:49 -0400 < andydude> I just learned about mes
2023-05-17 22:37:55 -0400 < Zipheir> mes?
2023-05-17 22:40:51 -0400 < Zipheir> Oh well, back to Alexander Jablokov's Soviet dolphin supersoldiers.
2023-05-17 22:57:32 -0400 < acdw> it's a thing that costs money. that's why the government should do it
2023-05-17 22:57:54 -0400 < acdw> like healthcare or education. things that are good for society but that don't have a profit motive
2023-05-17 22:58:09 -0400 < acdw> but nobody listens to me
2023-05-17 23:03:05 -0400 < lockywolf> Well, I am quite happy with the profitable mail system where I live :).
2023-05-17 23:03:41 -0400 < lockywolf> acdw: but how exactly do you decide what is and what is not good for society?
2023-05-17 23:04:03 -0400 < andydude> Zipheir: https://www.gnu.org/software/mes/
2023-05-17 23:04:13 -0400 < lockywolf> and I also see nothing wrong with wanting to do things that are good for society due to a profit motive
2023-05-17 23:04:39 -0400 < lockywolf> opening a shop brings me profit, but also serves people who want to buy something
2023-05-17 23:05:33 -0400 < lockywolf> Zipheir: I think you would enjoy the story about the Soviet moose cavalry
2023-05-17 23:05:41 -0400 < lockywolf> (mooselry?)
2023-05-17 23:10:06 -0400 < Zipheir> andydude: Ah right, the third GNU Scheme implementation that everyone forgets about.
2023-05-17 23:10:48 -0400 < Zipheir> lockywolf: It seems to have been a hoax... https://en.wikipedia.org/wiki/Moose_cavalry#Russian_April_Fools'_Day_hoax
2023-05-17 23:10:56 -0400 < andydude> Zipheir: in addition to mit and guile?
2023-05-17 23:11:01 -0400 < Zipheir> Yes.
2023-05-17 23:14:12 -0400 < lockywolf> Zipheir: yeah, a hoax. But a hilarious hoax.
2023-05-17 23:33:59 -0400 < flatwhatson> don't forget kawa
2023-05-17 23:37:22 -0400 < acdw> lockywolf: to your question that's what the democratic process is for. to the other, a shop owner is not a capitalist
2023-05-17 23:39:25 -0400 < lockywolf> acdw: I don't believe that this is what a democratic process can decide. People are different, and what someone considers good, might not be considered good by someone else. I think that democratic process can really only more or less reliably decide what is bad, not what is good.
2023-05-17 23:40:25 -0400 < lockywolf> Well, to me, a shop owner is a capitalist. A multinational company CEO might not actually be a capitalist, because he is influenced by off-market forces too much.
2023-05-17 23:40:30 -0400 < lockywolf> (or she)
2023-05-17 23:40:32 -0400 < acdw> all that society is is an agreement between a group to live together. the only way to operate fairly is democratically
2023-05-17 23:40:50 -0400 < acdw> lockywolf: literally a one person shop owner doesn't match the definition of capitalist
2023-05-17 23:41:05 -0400 < lockywolf> there is a difference between "living together" and "working together" is substantial
2023-05-17 23:41:38 -0400 < lockywolf> acdw: where is your reference definition of a "capitalist" coming from?
2023-05-17 23:42:11 -0400 < lockywolf> Mine is, as far as I understand, Marx (?) "the owner of the productive assets".
2023-05-17 23:42:46 -0400 < lockywolf> I mean, a small shop owner might be renting his shop building, and leasing his wares, so this is also a bit blurry.
2023-05-17 23:43:18 -0400 < lockywolf> But I have to admit, I have read Marx, but I haven't read Adam Smith, so I am perhaps missing something.
2023-05-17 23:43:49 -0400 < lockywolf> But, afair, Smith is also using an "owner of a small bakery" as a reference model of a capitalist.
2023-05-17 23:48:12 -0400 < acdw> a capitalist is someone who owns capital, that is, instruments designed solely to generate income
--- Day changed Thu May 18 2023
2023-05-18 00:02:01 -0400 < lockywolf> Well, a shop is designed to generate income...
2023-05-18 00:35:08 -0400 < acdw> idk. agree to disagree?
2023-05-18 00:39:28 -0400 < lockywolf> sure
2023-05-18 00:39:34 -0400 < lockywolf> I have to work anyway.
2023-05-18 00:39:51 -0400 < lockywolf> And I need to read Adam Smith attentively before having such discussions.
2023-05-18 05:58:28 -0400 < cow_2001> oh boy
2023-05-18 05:59:52 -0400 < cow_2001> i just watched The Russians Are Coming!
2023-05-18 06:00:28 -0400 < cow_2001> yesterday and the day before
2023-05-18 06:00:56 -0400 < cow_2001> will watch the one with the precious bodily fluids next
2023-05-18 06:01:30 -0400 < cow_2001> peter sellers is the president of the united states
2023-05-18 06:29:46 -0400 < wasamasa> I've seen the precious bodily fluids reference a bunch of times, didn't think it originate from a movie
2023-05-18 09:39:46 -0400 < acdw> isn't that ... Dr Strangelove?
2023-05-18 12:07:05 -0400 < Zipheir> Yes, it's Strangelove.
2023-05-18 12:08:49 -0400 < acdw> nice
2023-05-18 12:11:55 -0400 < Zipheir> "I can no longer sit back and allow Communist infiltration, Communist indoctrination, Communist subversion, and the international Communist conspiracy to sap and impurify all of our precious bodily fluids." https://en.wikiquote.org/wiki/Dr._Strangelove
2023-05-18 12:12:03 -0400 < Zipheir> Nice quotes page, actually.
2023-05-18 12:12:42 -0400 < acdw> haha, that movie's got a lot of em
2023-05-18 13:30:17 -0400 < sham1> You can't fight in here. This is the War room!
2023-05-18 15:57:33 -0400 < cow_2001> omgomgomgomg it orgmode now runs geiser guile on C-c C-c
2023-05-18 15:58:54 -0400 < acdw> oh shittttt
2023-05-18 16:47:07 -0400 < lechner> Hi, does Scheme (I'm on Guile) have anything resembling Perl's || operator, please? I'd like to pick a value unless it evaluates to #false.
2023-05-18 16:48:35 -0400 < acdw> (or value default)
2023-05-18 16:48:48 -0400 < lechner> acdw / thanks!
2023-05-18 16:48:57 -0400 < acdw> what do you want it to be if it's #f? #f ?
2023-05-18 16:49:00 -0400 < acdw> or something else
2023-05-18 16:49:23 -0400 < lechner> then i would not need an operator, would i?
2023-05-18 16:52:08 -0400 < acdw> if you want it to pick a value unless it evaluates to false, in which case you want it to evaluate to false, you can just have it evaluate the value
2023-05-18 16:52:44 -0400 < lechner> right
2023-05-18 16:53:32 -0400 < acdw> i'll use or when like, i want to use a value that might be a string or #f as an argument to a procedure that expects a string. so like, (foo (or bar "")) so it defaults to ""
2023-05-18 16:54:07 -0400 < lechner> yeah, that's exactly what i need. thanks so much!
2023-05-18 16:55:23 -0400 < acdw> :D
2023-05-18 16:58:33 -0400 < Zipheir> That's idiomatic for values that use #f as their "nothing value". The more general version is (if (<pred?> <val>) <val> <default>).
2023-05-18 16:58:59 -0400 < lechner> right. i was hoping to avoid the let to get to <val>
2023-05-18 17:00:09 -0400 < Zipheir> Cond arrow and "bodyless cond" are also useful in these situations.
2023-05-18 17:00:23 -0400 < acdw> coming from elisp, at first i was annoyed at the lack of nil-punning. but using scheme more and more, i enjoy the fact tht #f basically serves as a Nothing value from languages like Haskell without having to wrap everything in a Maybe
2023-05-18 17:00:51 -0400 < Zipheir> It's still a kludge.
2023-05-18 17:00:52 -0400 < lechner> Zipheir / yeah, i have seen those but wanted to keep it safe for now. i am still kind of green behind the ears
2023-05-18 17:01:47 -0400 < Zipheir> acdw: We've probably discussed this already, but how do you return #f as a value? Scheme has been playing around the lack of Maybe for a long time.
2023-05-18 17:01:48 -0400 < acdw> but a slightly better kludge!
2023-05-18 17:02:08 -0400 < acdw> oh like you have a meaningful falsy thing
2023-05-18 17:02:44 -0400 < acdw> like you could have true, or false, or error
2023-05-18 17:02:45 -0400 < acdw> ?
2023-05-18 17:03:10 -0400 < lechner> i wrapped mine false-if-exception
2023-05-18 17:03:13 -0400 < lechner> in
2023-05-18 17:06:41 -0400 < Zipheir> acdw: Yes, a meaningful falsy thing. 'find' from SRFI 1 is a classic example of the problem. You can't find #f.
2023-05-18 17:07:09 -0400 < Zipheir> (Incidentally, if you want Maybe or Either, they're in SRFI 189.)
2023-05-18 17:08:43 -0400 < acdw> aha got ya
2023-05-18 17:09:18 -0400 < acdw> I guess a way to almost solve it is to have the function return an empty value dependent on the expected return. but that isn't ideal
2023-05-18 17:09:25 -0400 < Zipheir> We've got a similar problem with (eof-object), which is another magic object.
2023-05-18 17:10:04 -0400 < acdw> I was having an issue with that the other day. had to look for eof and "" to break out of the loop
2023-05-18 17:11:07 -0400 < Zipheir> acdw: The way that recent SRFIs have solved it is to require an error continuation. So you'd have (find obj lis failure), and find calls the thunk failure if obj isn't found.
2023-05-18 17:11:17 -0400 < Zipheir> This is pretty idiomatic for Scheme.
2023-05-18 17:11:49 -0400 < Zipheir> It's also equivalent to returning a Maybe.
2023-05-18 17:13:16 -0400 < acdw> ooo that's interesting
2023-05-18 17:15:16 -0400 < Zipheir> If you want to see further extensions of that kind of continuation passing, check out mapping-search from SRFI 146 or fxmapping-alter from SRFI 224.
2023-05-18 17:19:34 -0400 < acdw> is there like, an easier way of navigating srfi.schemers.org? rn i'm doing a bunch of clicking
2023-05-18 17:19:53 -0400 < acdw> i could probably ... set up an emacs lookup function
2023-05-18 17:19:55 -0400 < Zipheir> The JS search works pretty well.
2023-05-18 17:20:15 -0400 < acdw> oh yeah duh, i 've been searching just for numbers and stuff
2023-05-18 17:20:16 -0400 < Zipheir> There's the CLI 'srfi' tool, but I haven't tried that.
2023-05-18 17:20:39 -0400 < acdw> oo
2023-05-18 17:20:54 -0400 < Zipheir> https://github.com/scheme-requests-for-implementation/srfi-common/tree/master/srfi-tools
2023-05-18 17:23:29 -0400 < acdw> oh thansk!
2023-05-18 17:28:20 -0400 < Zipheir> Let me know how it works if you try it.
2023-05-18 17:28:39 -0400 < acdw> will do! i'm working on an emacs thing rn
2023-05-18 17:56:35 -0400 < Zipheir> ISTR that Arthur, the SRFI editor, is a big Emacs user. He may have some useful Elisp tools.
2023-05-18 17:58:30 -0400 < acdw> ooo
2023-05-18 18:10:05 -0400 < flatwhatson> some kind of srfi->info would be great
2023-05-18 18:11:31 -0400 < acdw> yeah that too! and r7rs->info while we're at it please
2023-05-18 18:17:58 -0400 < Zipheir> Texinfo?
2023-05-18 18:18:31 -0400 < Zipheir> Scribble's more likely.
2023-05-18 18:19:55 -0400 < flatwhatson> anything convertible to info for use with info-mode
2023-05-18 18:23:48 -0400 < acdw> yes!
2023-05-18 18:23:52 -0400 < Zipheir> I don't know if anyone's written a Texinfo converter for Scribble.
2023-05-18 18:24:06 -0400 < acdw> i tried to pandoc r7rs.tex to like, org, but it choked
2023-05-18 18:24:10 -0400 < Zipheir> IMHO Texinfo is too Emacs-dependent.
2023-05-18 18:24:16 -0400 < acdw> but i use emacs :(
2023-05-18 18:24:23 -0400 < Zipheir> We have at least a thousand alternatives.
2023-05-18 18:24:26 -0400 < acdw> hehehe
2023-05-18 18:25:18 -0400 < Zipheir> There still needs to be an HTML version of r7rs-small.
2023-05-18 18:27:13 -0400 < acdw> that would be really helpful honestly, maybe the most helpful
2023-05-18 18:27:19 -0400 < acdw> then you could convert that into whatever you want
2023-05-18 18:28:15 -0400 < Zipheir> I started converting the LaTeX a while ago, but I don't want to do the whole thing myself. I don't think autogeneration is likely to give us anything that looks nice, either.
2023-05-18 18:30:02 -0400 < acdw> do you have your current efforts up somewhere? i might be interested in helping out
2023-05-18 18:32:46 -0400 < Zipheir> Hmm, I can't find it.
2023-05-18 18:33:16 -0400 < Zipheir> amirouche did a rough draft of the whole thing. Maybe that's a good starting point.
2023-05-18 18:33:29 -0400 < Zipheir> No, he deleted the repo. Argh.
2023-05-18 18:33:33 -0400 < Zipheir> amirouche: STOP THAT
2023-05-18 18:35:45 -0400 < Zipheir> I have a backup of his draft at ftp://ftp.sigwinch.xyz/pub/r7rs.html
2023-05-18 18:36:31 -0400 < Zipheir> It's all one page and quite rough, but it's something.
2023-05-18 18:38:45 -0400 < Zipheir> Hmm, looks like it's just pandoc output.
2023-05-18 19:27:41 -0400 < acdw> I might could work w that
2023-05-18 19:28:01 -0400 < acdw> I couldn't even get pandoc to convert the pdf to html
2023-05-18 19:30:04 -0400 < acdw> are there any consensi on documentation strings or in source documentation w scheme? chicken has hahn style but that might not be standard
2023-05-18 19:42:58 -0400 < Zipheir> There's no consensus, AFAIK. jcowan wants magic-comment-style documentation, I think. Docstrings probably won't ever be standardized; Scheme's 'define' has been fixed too long to monkey with.
2023-05-18 19:45:36 -0400 < lechner> Hi, do Guile regexps have named matches?
2023-05-18 19:49:09 -0400 < Zipheir> I don't think so. Aren't they basically just POSIX regexps?
2023-05-18 19:50:14 -0400 < lechner> yeah, thanks. i think i'd have to go to irregex for that
2023-05-18 19:50:26 -0400 < Zipheir> SRFI 115/irregex has a lot more matching bells and whistles.
2023-05-18 19:50:43 -0400 < lechner> yeah, i just wish it were faster
2023-05-18 19:50:57 -0400 < acdw> Zipheir: ahh
2023-05-18 19:51:20 -0400 < acdw> makes sense re define I spose. magic comments like ;;;// this thing does whatever ?
2023-05-18 19:51:29 -0400 < acdw> type stuff. that's probably dumb syntax lol
2023-05-18 19:51:36 -0400 < Zipheir> Yeah. Guile's regexps are probably just wrappers for the POSIX functions in C. I doubt the Scheme implementation can beat it.
2023-05-18 19:52:13 -0400 < Zipheir> acdw: Right.
2023-05-18 19:52:31 -0400 < acdw> gotcha
2023-05-18 19:53:12 -0400 < acdw> I sometimes do almost like docstrings but doc comments. between the define var line and the definition line
2023-05-18 19:53:18 -0400 < Zipheir> Haddock for Haskell is a reasonably clear magic-comment syntax.
2023-05-18 19:54:38 -0400 < acdw> I think I know that one....I haven't really looked super into it to be honest. just realized I should start commenting my code better
2023-05-18 20:24:07 -0400 < link`> hello
2023-05-18 20:24:17 -0400 < lechner> hi
2023-05-18 20:24:55 -0400 < andydude> hi
2023-05-18 20:25:07 -0400 < link`> I saw this snippet in SICP for the differentiator (define (=number? exp num) (and (number? exp) (= exp num))). Why does he not use equal? instead.
2023-05-18 20:26:12 -0400 < andydude> equal? is defined as a bunch of type-checks and if it's a number then it reduces to (=)
2023-05-18 20:26:41 -0400 < link`> whats the difference between (=) and =?
2023-05-18 20:26:56 -0400 < andydude> I'm a wierdo and use parens around everything
2023-05-18 20:27:03 -0400 < link`> ah, lisp
2023-05-18 20:27:16 -0400 < link`> ah so then it wouldn't use too many type checks, got it
2023-05-18 20:27:19 -0400 < andydude> "equal?" is defined in terms of "="
2023-05-18 20:27:28 -0400 < Zipheir> link`: The odd thing about that snippet is (number? exp). This is redundant; = is only defined on numbers.
2023-05-18 20:27:30 -0400 < andydude> how about that for wrapping unsafe punctuation with something
2023-05-18 20:28:16 -0400 < lechner> i am such a noobie. i thought '=?' was another predicate!
2023-05-18 20:28:23 -0400 < Zipheir> It is, in SRFI 128.
2023-05-18 20:28:30 -0400 < andydude> Zipheir: the rest of equal is ((boolean? a) (boolean=? a b)) (bytevector? a) (bytevector=? a b)) etc.
2023-05-18 20:29:10 -0400 < link`> I think, the author doesn't want it to return an error if the function is not passed a number Zipheir. Which = would do
2023-05-18 20:29:15 -0400 < Zipheir> lechner: It's the generic equality predicate.
2023-05-18 20:29:48 -0400 < lechner> no i meant in the question about the parentheses immediately above
2023-05-18 20:29:49 -0400 < Zipheir> andydude: It could be. It's actually defined in terms of eqv? in the reports.
2023-05-18 20:30:22 -0400 < Zipheir> link`: But you still get an error if num isn't a number, of course.
2023-05-18 20:30:39 -0400 < Zipheir> lechner: Ah, sorry.
2023-05-18 20:31:35 -0400 < Zipheir> lechner: For this reason, I usually put a space between Scheme names and question marks when chatting.
2023-05-18 20:31:58 -0400 < link`> Zipheir i think the exp is supposed to have a possibility of not being a number. num is supposed to be definitely a number
2023-05-18 20:32:20 -0400 < Zipheir> That makes sense.
2023-05-18 20:40:35 -0400 < Zipheir> link`: I think you might as well use equal? in that. In fact, (define =number? equal?) gives pretty much the same semantics, since exp and num are equal? just when exp is a number (assuming, as you said, that num is always a number).
2023-05-18 20:48:11 -0400 < flatwhatson> aren't the typed comparisons more strict? eg. (char=? a b) errors if either a or b aren't characters
2023-05-18 20:49:04 -0400 < flatwhatson> =number? is a bit weird, because it's spelt backwards.  i'd expect number=? to be the same as =
2023-05-18 20:50:25 -0400 < Zipheir> It is a weird-looking name.
2023-05-18 20:51:48 -0400 < Zipheir> flatwhatson: Yes, they're more strict. But since that function was supposed to accept non-numbers in its first argument, I think equal? makes more sense. = is for strict number-number(-number...) comparison.
2023-05-18 22:38:14 -0400 < jcowan> re: cat abuse: if you like cat foo | sink, then surely cat foo | cat | cat | sink is even better
2023-05-18 22:47:52 -0400 < Zipheir> cat is a strange right unit of |.
--- Day changed Fri May 19 2023
2023-05-19 10:19:32 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-19 10:55:12 -0400 < mdhughes> jcowan: What would be the point of a cat with no input? The entire reason people use Prefix Cat is to put the inputs at the start instead of buried in a command.
2023-05-19 10:58:11 -0400 < gwatt> mdhughes: I believe the point was to abuse cats
2023-05-19 10:59:08 -0400 < mdhughes> Well stop it. A cat is very useful for putting file content into a pipe. That's not abuse. This "abuse" thing is a thought-terminating cliché, it's noxious.
2023-05-19 11:02:38 -0400 < gwatt> ... but you can just put the file(s) in the argument list of the actual command? And then commands like grep can include the actual file in the output
2023-05-19 11:25:57 -0400 < mdhughes> They're often buried behind a bunch of options. If I have an egrep or sed with regex and some options, the files are way at the end. Sometimes that's necessary, like `egrep -Hn` to report files, but then I'll usually f=(many files); command $f (zsh expands this as arguments)
2023-05-19 11:27:23 -0400 < mdhughes> Anyway. This should be in #unix or #zsh I guess
2023-05-19 11:44:43 -0400 < acdw> I just think dogs are left put
2023-05-19 11:44:44 -0400 < acdw> out
2023-05-19 12:12:14 -0400 < mdhughes> What should dog command do? Maybe collect multiple inputs, reverse of cat.
2023-05-19 12:25:41 -0400 < mdhughes> We also have ant, fish, python, what other animal commands are there?
2023-05-19 12:53:30 -0400 < Zipheir> There's cowsay.
2023-05-19 12:53:47 -0400 < acdw> lol mdhughes
2023-05-19 12:54:07 -0400 < Zipheir> If there were a 'gnu' command, it would just print rms quotes and the *entire* text of the GPLv3.
2023-05-19 12:54:18 -0400 < acdw> of course
2023-05-19 12:56:15 -0400 < mdhughes> On pre-unix systems, we had zoo archives. https://en.wikipedia.org/wiki/Zoo_(file_format)
2023-05-19 12:57:45 -0400 < mdhughes> (I was on Atari 8-bit & ST, where .arc was common, which I *guess* can be a boat full of animals christian myth thing, but I'd rather not)
2023-05-19 13:00:25 -0400 < gwatt> I think that's properly spelled ".ark" in that case
2023-05-19 13:01:01 -0400 < mdhughes> But then what about covenant.arc?
2023-05-19 13:01:34 -0400 < mdhughes> Don't unarc it or it'll melt your face off.
2023-05-19 13:01:58 -0400 < gwatt> But also, you don't need to think of The Ark as an Abrahamaic myth. It shows up in a bunch of cultures around the region.
2023-05-19 13:02:25 -0400 < mdhughes> Well, it's a Sumerian story originally, but the christfuckers are the ones building giant boats in landlocked states.
2023-05-19 13:02:55 -0400 < gwatt> I think it should still be "covenant.ark", not ".arc"
2023-05-19 13:05:51 -0400 < mdhughes> That might've saved Phil Katz from the SEA lawsuit.
2023-05-19 13:06:41 -0400 < mdhughes> When I watched BBS The Documentary, that shit still made me mad, 30+ years later.
2023-05-19 13:07:33 -0400 < mdhughes> https://archive.org/details/bbsdocumentary
2023-05-19 13:08:38 -0400 < mdhughes> Anyway. Time for sleep 21600 or so.
2023-05-19 13:27:56 -0400 < Zipheir> mdhughes: There's no need for religious slurs.
2023-05-19 16:07:18 -0400 < mwnaylor> mdhughes: don't be a scumbag.
2023-05-19 19:02:23 -0400 < mdhughes> You don't wanna know my real opinion of those… fine people… with the fake boat.
2023-05-19 19:03:02 -0400 < acdw> nope sure dont
2023-05-19 19:21:10 -0400 -!- Noisytoot is now known as [
2023-05-19 22:09:35 -0400 < acdw> scheme!
2023-05-19 22:27:16 -0400 < Zipheir> (scheme!)
2023-05-19 22:29:23 -0400 < lechner> (concur!)
2023-05-19 22:32:18 -0400 < acdw> lol
2023-05-19 23:14:30 -0400 < mdhughes> Sadly, nothing I'm doing in Scheme is that exciting right now. Implementing features in a methodical way. Chez just works.
--- Day changed Sat May 20 2023
2023-05-20 03:56:57 -0400 < shawnw> Are there any schemes besides Guile and Racket that implement continuation prompts/reset-shift operators?
2023-05-20 08:02:46 -0400 < jcowan> shawnw: Chez
2023-05-20 12:14:06 -0400 < Zipheir> It's unfortunate that delimited continuations aren't more widely implemented.
2023-05-20 12:16:03 -0400 < leah2> gauche, but iirc not super efficiently implemented
2023-05-20 12:18:42 -0400 < Zipheir> The other question is how many del. cont. implementations are just call/cc under the hood.
2023-05-20 12:45:06 -0400 < cow_2001> i am doing stupid eopl3 stuff on my phone using termux, emacs, hackers' virtual keyboard, and holding my hands up for too long joint pain
2023-05-20 12:47:38 -0400 < johnjaye> emacs in terminal mode?
2023-05-20 12:47:51 -0400 < Zipheir> Ouch.
2023-05-20 13:08:37 -0400 < cow_2001> johnjaye: yes
2023-05-20 13:09:11 -0400 < cow_2001> there is one using graphical mode in f-droid, but i like having it together with my rest of my command line tools
2023-05-20 13:09:24 -0400 < cow_2001> the rest
2023-05-20 13:10:38 -0400 < cow_2001> there are the up and down procedures which add or remove parentheses from items of a list
2023-05-20 13:10:56 -0400 < cow_2001> hmmm what am i asking
2023-05-20 13:11:05 -0400 < cow_2001> nevermind
2023-05-20 13:51:51 -0400 < cow_2001> okay
2023-05-20 13:52:04 -0400 < cow_2001> https://git.sr.ht/~kakafarm/eopl3
2023-05-20 13:53:35 -0400 < Zipheir> Regardless of which book you're reading, Dan Friedman will always make you write 'remove'.
2023-05-20 13:54:23 -0400 < tomhg> Hey jcowan. I am reading on the gambit mailing list. I don't unterstand if you guys talk about the internal-scheme data type or the essence of unicode. I wanted to - without any context - prompt two things:
2023-05-20 13:55:12 -0400 < cow_2001> i have a https://sr.ht/~kakafarm/learnings/
2023-05-20 13:55:27 -0400 < cow_2001> maybe i should also work on r&k
2023-05-20 13:55:35 -0400 < cow_2001> i get bored with one thing always have another
2023-05-20 13:55:54 -0400 < tomhg> Since the set of supported characters only grows, I think the commitee thought about a max size. And if a version in use does not support a certain symbol they may be allowed to prompt one of the two replacement characters. The second thing: Did we think about the normalization forms?
2023-05-20 13:56:25 -0400 < cow_2001> there's someone converting prescheme from scheme48 to guile. the lengths people go through in order to not write c…
2023-05-20 13:56:28 -0400 < tomhg> s/Did/Should/
2023-05-20 13:58:02 -0400 < Zipheir> cow_2001: It's a cool project. It's possible to implement Scheme on top of a very small core, so why not?
2023-05-20 13:58:18 -0400 < cow_2001> if i had some actual knowledge i would have looked into contributing :|
2023-05-20 13:59:38 -0400 < cow_2001> there are two things i would like to avoid: 1. writing js. 2. writing c. so i learned a bit of golang once just so i could write a stochastic cellular automata project for school and later learned a bit of rustlang just because.
2023-05-20 14:01:24 -0400 < cow_2001> but i should learn c anyway :|
2023-05-20 14:02:07 -0400 < cow_2001> it isn't a big language. i guess the bigger part of the language is what isn't defined in the language.
2023-05-20 14:02:33 -0400 < cow_2001> so it spooks me out
2023-05-20 14:02:38 -0400 < tomhg> Zipheir: I did implemented my intention via fold after reading srfi-41 and srfi-158. I think I see why you suggested stream-drop & stream-take. I tested it memorization with my stateful object and it did indeed make it tomhg (fool) proof. I am now researching about my next steps (stream-match vs macro) *listingspostedlater*
2023-05-20 14:02:53 -0400 < tomhg> *its
2023-05-20 14:02:58 -0400 < Zipheir> cow_2001: Learn Ada instead ;-)
2023-05-20 14:03:20 -0400 < cow_2001> Zipheir: yeah, but everything on *nix is c
2023-05-20 14:03:27 -0400 < Zipheir> Although, if you know Go, C should be pretty easy.
2023-05-20 14:03:41 -0400 < Zipheir> Er, as "easy" as C ever is, which is not very.
2023-05-20 14:03:46 -0400 < cow_2001> it's like a catwalk without guardrails
2023-05-20 14:04:20 -0400 < Zipheir> rudybot: bloody mess
2023-05-20 14:04:20 -0400 < rudybot> Zipheir: And of course it's a nightmare to try to catch all the random possible explosions in a C program. Even Rob Pike admitted "C is a razor-sharp tool. You can use it to create a highly efficient program or a bloody mess."
2023-05-20 14:04:47 -0400 < cow_2001> and like other similes involving lack of safety
2023-05-20 14:05:15 -0400 < Zipheir> tomhg: I'm glad fold worked for you!
2023-05-20 14:07:57 -0400 < Zipheir> cow_2001: There are lots of sane programs to write in C. But, at some point, you start passing around double void pointers or casting strings to int arrays and things go downhill quickly.
2023-05-20 14:09:15 -0400 < cow_2001> aren't there tools that detect such stuff?
2023-05-20 14:10:47 -0400 < Zipheir> You can turn up your compiler warnings and use Valgrind to look for leaks.
2023-05-20 14:48:18 -0400 < sham1> C is like UNIX. User friendly, but very picky about its friend
2023-05-20 15:12:29 -0400 < jcowan> tomhg: Yes, there is a maximum sise, about a million characters.  We are never going to reach that limit.
2023-05-20 15:13:15 -0400 < jcowan> Until we join the Galactic Empire, in which case we will adopt their coding scheme.
2023-05-20 15:15:37 -0400 < jcowan> At the moment, newly adopted characters represent any of these things: a) scripts used only for minority languages, (b) letters used only in minority languages (c) ultra-ultra-obscure Chinese characters, (d) novel emoji
2023-05-20 15:17:56 -0400 < jcowan> None of these things can be represented by sequences of characters.
2023-05-20 15:27:12 -0400 < sham1> Emoji can by describing the picture
2023-05-20 15:55:10 -0400 < tomhg> jcowan: Yes, that was my limited experience. So to understand the discussion I should defer between a character (ands its representation and therefore encoding) and a character set?
2023-05-20 15:56:10 -0400 < tomhg> And if so characters have different representations which I though about normalization without actually knowning what I am talking about *
2023-05-20 15:56:18 -0400 < tomhg> *rubberducks*
2023-05-20 15:56:54 -0400 < tomhg> *which is why I thought
2023-05-20 15:57:23 -0400 < jcowan> sham1: A description is not a character any more than "LL" and "hockey sticks" are the same thing.
2023-05-20 15:58:14 -0400 < jcowan> Some existing characters have canonically equivalent sequences, but the list of such characters is now closed.
2023-05-20 16:02:51 -0400 < tomhg> Okay. Just to clarify my own mind: A fixed code point for e.g. #\ä and #\a + xa4 - Or you mean things like a small letter + two graphenes in different orders resulting in the same?
2023-05-20 16:03:42 -0400 < tomhg> nvm. I should read the documentation. Sorry
2023-05-20 16:04:36 -0400 < Zipheir> Graphene clusters are good for drawing with.
2023-05-20 16:06:57 -0400 < tomhg> :o)
2023-05-20 16:31:50 -0400 < sham1> Very carbony though
2023-05-20 16:51:13 -0400 < tomhg> I intended something like this: https://termbin.com/037xj - anyhow I could use this with mniepers parser, possibly - So I looked at his source and found a literature suggestion :)
2023-05-20 20:44:57 -0400 < cow_2001> will we be replaced by gpt or whatever?
2023-05-20 20:45:02 -0400 < cow_2001> programmers
2023-05-20 20:45:52 -0400 < cow_2001> will i need to use these proprietary plagiarism machines in order to get work?
2023-05-20 20:48:04 -0400 < aeth> not Scheme
2023-05-20 20:48:16 -0400 < aeth> these models aren't trained on Scheme and there might not even be enough data because they require a lot of data to be correct
2023-05-20 20:57:37 -0400 < cow_2001> but nobody's using scheme
2023-05-20 20:57:49 -0400 < cow_2001> people use js and python
2023-05-20 20:58:14 -0400 < cow_2001> companies
2023-05-20 20:58:42 -0400 < cow_2001> for some strange reason
2023-05-20 21:00:51 -0400 < cow_2001> so i am afraid
2023-05-20 21:01:18 -0400 < cow_2001> what's the point to any of it
2023-05-20 21:27:05 -0400 < acdw> what's the point to anything
2023-05-20 21:38:13 -0400 < aeth> to build the LispOS
2023-05-20 21:38:16 -0400 < aeth> next question
2023-05-20 23:47:39 -0400 -!- mdhughes_ is now known as mdhughes
--- Day changed Sun May 21 2023
2023-05-21 01:41:39 -0400 < flatwhatson> humans won't be "replaced" by AI, but some jobs become easier to the point where less people are needed to do those jobs.
2023-05-21 01:43:32 -0400 < flatwhatson> programming is and will continue to be in high demand, because it's pre-requisite to building anything with software, and that doesn't really change with AI.
2023-05-21 01:44:10 -0400 < flatwhatson> it might become easier, but I'd argue that people using AI to build software are still programmers, just their job become easier.
2023-05-21 01:45:22 -0400 < flatwhatson> think about all those greybeards writing code on punch-cards.  all those computers (the pen and paper kind) doing accounts.
2023-05-21 01:45:47 -0400 < flatwhatson> but neither programming nor mathematics (even arithmetic) have been "replaced"
2023-05-21 03:15:24 -0400 < aeth> depends on what you're doing though
2023-05-21 03:15:44 -0400 < aeth> something tough and low level where performance matters will require skill no matter what
2023-05-21 03:16:24 -0400 < aeth> (low level relatively speaking... someone has to build the frameworks or whatever, no matter how high the level of abstraction is)
2023-05-21 03:16:36 -0400 < aeth> autocompleting boilerplate might get easier and easier
2023-05-21 03:43:35 -0400 < mdhughes> Java, C#, Go programmers are screwed.
2023-05-21 06:05:45 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-21 14:39:06 -0400 < tomhg> Just some apprecciation to this channel. I just decided to happily postpone my project another six months to learn about fundamentals :)
2023-05-21 14:40:07 -0400 < lechner> that sounds more like a stumbling block
2023-05-21 14:40:09 -0400 < lechner> Hi, what does the single dot mean here, please?     (define (with-mail-out action . user) ...)       https://git.savannah.gnu.org/cgit/mcron.git/tree/src/mcron/redirect.scm#n66
2023-05-21 14:41:44 -0400 < wasamasa> rest arguments basically
2023-05-21 14:41:59 -0400 < wasamasa> after the . comes the cdr of the cell
2023-05-21 14:43:10 -0400 < lechner> wasamasa / thanks! i remember now
2023-05-21 14:51:10 -0400 < tomhg> Kind of, but a good one. I read two paragraphs of a book and start to think about neater solutions which may be possible when using scheme (though I am not able to _just implement_ them, yet)! But there happend two things in my life this week: Our contractor contacted me if I am willing to participate in a start outside of the work environment. I am uncertain but we scheduled a kick-of informally within the
2023-05-21 14:51:16 -0400 < tomhg> next week. The second one is that my university course was judged and apparently I attended a rather good university :)) - Though I did not finish the required high school degree.
2023-05-21 14:51:31 -0400 < tomhg> Anyhow! I do appreciate beeing here *waveshands*
2023-05-21 15:00:05 -0400 < Zipheir> tomhg: We're glad you're here.
2023-05-21 15:00:32 -0400 < lechner> yeah
2023-05-21 15:01:10 -0400  * tomhg opens arms to hug (:
2023-05-21 15:01:29 -0400 < Zipheir> tomhg: I did think your language server (?) project looked quite difficult. It's probably a good idea to focus on fundamentals for a while.
2023-05-21 15:06:08 -0400 < tomhg> I see the bright side: I have a goal to implement it for my own environment
2023-05-21 15:26:31 -0400 < sham1> Any excuse to implement a scheme system is a good excuse, and putting an LSP implementation there would be an interesting one
2023-05-21 15:45:44 -0400 < lechner> Hi, is set-tm:min a defined variable in this line, please?    https://git.savannah.gnu.org/cgit/mcron.git/tree/src/mcron/job-specifier.scm#n144
2023-05-21 15:47:13 -0400 < wasamasa> you should take a look at the imports
2023-05-21 15:48:52 -0400 < lechner> ok, let's assume it was imported. does this local declaration that shadow an imported variable?    https://git.savannah.gnu.org/cgit/mcron.git/tree/src/mcron/job-specifier.scm#n120
2023-05-21 15:48:58 -0400 < lechner> then
2023-05-21 15:50:24 -0400 < wasamasa> https://www.gnu.org/software/guile/manual/html_node/Time.html
2023-05-21 15:50:39 -0400 < wasamasa> apparently a guile built-in
2023-05-21 15:50:54 -0400 < wasamasa> they are just procedures and procedure calls
2023-05-21 15:52:46 -0400 < lechner> oh, i get it now. wow, that's confusing for someone with poor vision. thanks!
2023-05-21 15:53:17 -0400 < wasamasa> I'm very used to this kinda functionality requiring an import
2023-05-21 15:53:24 -0400 < wasamasa> pretty wild how guile does just provide it as is
2023-05-21 15:53:36 -0400 < wasamasa> but at least they warn you when redefining something
2023-05-21 15:53:39 -0400 < lechner> i might have chosen different names for the local variables
2023-05-21 15:54:05 -0400 < wasamasa> there's just one local variable, time
2023-05-21 15:54:15 -0400 < lechner> actually, i am even more confised
2023-05-21 15:54:18 -0400 < wasamasa> the line after that is part of the let body
2023-05-21 15:54:32 -0400 < wasamasa> so the setter function is called on the time object
2023-05-21 15:54:36 -0400 < lechner> i better read up on records, if that's what that is
2023-05-21 15:54:43 -0400 < wasamasa> then the setter procedures are passed to another procedure
2023-05-21 15:56:01 -0400 < lechner> well, i am not sure if anyone here uses mcron, but i'd like to have functions that first check this hour before moving on to the next. at '02, i can't manually get a job to run at '15 in the same hour
2023-05-21 16:03:46 -0400 < tomhg> sham1: I couldn't put my disclaimer within a concise sentence but you may just helped me by structuring my thoughts of PL-percularties into words.. Boosts my motivation to read [A.W.Appel, 1998] by a lot. *resumesforgoodandleaves*
2023-05-21 16:07:34 -0400 < Zipheir> I was disappointed by Appel's book. It's very specific and hard to generalize from.
2023-05-21 16:09:59 -0400 < Zipheir> There are probably easier ways to learn compiling with CPS.
2023-05-21 16:17:51 -0400 < sham1> Yeah, it's very specifically about the exact kind of CPS it uses. Guile for example also does CPS but in a different way since it doesn't just compile every continuation into functions that are indistinguishable from each other
2023-05-21 16:22:09 -0400 < Zipheir> Exacty.
2023-05-21 16:22:18 -0400 < Zipheir> Argh. *Exactly.
2023-05-21 16:23:02 -0400 < tomhg> I was already thought about CPS by you guys. I am starting about compilation from scratch. I already deduced that mniepers macro-parser-grammar may be extended by a lexical generator..
2023-05-21 16:23:21 -0400 < tomhg> /s/thought/taught
2023-05-21 16:24:23 -0400 < tomhg> *resumes2brokegirls*
2023-05-21 16:24:53 -0400 < Zipheir> tomhg: I know you already have plenty to read, but this is a great, simple approach to compilers: http://www.cs.nott.ac.uk/~pszgmh/ccc.pdf  (If you like mathematics, that is.)
2023-05-21 16:25:45 -0400 < tomhg> I didn't have a graduation but I take you seriously (: Thanks :)
2023-05-21 16:26:20 -0400 < Zipheir> Oh, it doesn't take any advanced mathematics. Just the dreaded "mathematical maturity".
2023-05-21 16:26:20 -0400 < tomhg> s/have/had (i think)
2023-05-21 16:28:38 -0400 < tomhg> One last question; I want to track my read papers. I forget about authors and need to look them up within my ~/documents/* dump. Is there some strategy(/program) to make these reads queryable?
2023-05-21 16:30:05 -0400 < Zipheir> The core idea of CCC is that you can define a compiler by the equation 'exec (compile prog) = eval prog', given an interpreter-semantics function eval and a target machine 'exec'.
2023-05-21 16:31:10 -0400 < Zipheir> tomhg: I keep a CSV file of all my papers/books/etc. I have a little Scheme program to compile queries on it.
2023-05-21 16:31:35 -0400 < lechner> btw, degrees (and graduations) are overrated     https://www.quantamagazine.org/hobbyist-finds-maths-elusive-einstein-tile-20230404/
2023-05-21 16:31:38 -0400 < sham1> Could be interesting to generate Bibtex from that
2023-05-21 16:31:57 -0400 < Zipheir> Most of what I use is just a query like (and (author "Hutton") (title "Calculating"))
2023-05-21 16:33:09 -0400 < tomhg> Maybe a good task would be to transform such a *.csv-File to scheme-syntax?
2023-05-21 16:33:37 -0400 < Zipheir> CSV is very portable, though.
2023-05-21 16:33:55 -0400 < Zipheir> I also appreciate not having to quote every string field.
2023-05-21 16:34:46 -0400 < Zipheir> sham1: A BibTex tool would be fun.
2023-05-21 16:35:14 -0400 < sham1> A bibtex database to do the queries on
2023-05-21 16:35:23 -0400 < tomhg> one sentences; two lessons learned. Didn't know about the convenience of "not-quoting" by *.csv. And I will take that article to read myself into sleep :)
2023-05-21 16:35:33 -0400 < tomhg> -s
2023-05-21 16:35:50 -0400 < sham1> Good night
2023-05-21 16:35:57 -0400 < tomhg> *bows*
2023-05-21 16:36:14 -0400 < sham1> If I didn't have about a million other projects to work on, I'd probably make that kind of a bibtex database tool
2023-05-21 16:38:19 -0400 < Zipheir> It might be useful.
2023-05-21 16:38:59 -0400 < lechner> a bibtex parser would be nice
2023-05-21 16:41:27 -0400 < Zipheir> What I learned from the CSV experience is that, for thousands of entries, simple grep-style linear searching is plenty quick, even with slow Scheme CSV parsers.
2023-05-21 16:47:24 -0400 < tomhg> *retreats* Within my self-reading semesters I remember that *.csv is bad because it did not use the already-available ASCII separators. Maybe there is some Scheme CSV-parser buried I can take as a task..
2023-05-21 16:48:45 -0400 < tomhg> A semicolon is a very much important symbol; Even within English.
2023-05-21 16:50:58 -0400 < Zipheir> tomhg: This is what I've used on CHICKEN https://github.com/iraikov/chicken-csv-abnf
2023-05-21 16:51:47 -0400 < Zipheir> It's monadic-combinator-style parsing, which tends to be inefficient, but it's OK.
2023-05-21 16:52:05 -0400 < tomhg> Okay 10 years of development. I put this on my door to remember myself I am a know-it-all
2023-05-21 16:52:40 -0400 < Zipheir> I'm not claiming that CSV is a brilliant data format, but it *is* a simple, hand-writeable one.
2023-05-21 16:52:59 -0400 < tomhg> ineffiecienty doesn't matter; I was about the portability.
2023-05-21 16:53:11 -0400 < tomhg> *nods*
2023-05-21 16:53:43 -0400 < tomhg> s/ty/cy
--- Day changed Mon May 22 2023
2023-05-22 05:58:55 -0400 < dadinn[m]> hi all
2023-05-22 07:57:51 -0400 < amirouche> hi
2023-05-22 07:59:10 -0400 < amirouche> re language server, I stumbled upon https://github.com/Bogdanp/racket-review
2023-05-22 07:59:36 -0400 < amirouche> There is not much code, so it can be read and understood in afternoon
2023-05-22 08:00:04 -0400 < amirouche> it relies on racket machinery, hence not directly portable
2023-05-22 08:03:13 -0400 < amirouche> "We will never reach [the one million characters limit] until we join the Galactic Empure" :)
2023-05-22 08:29:45 -0400 < edgar-rft> I think it's only a matter of time until RnRS-huge will break the one-million-character limit :-)
2023-05-22 09:05:17 -0400 < rgherdt> amirouche: cool. I didn't look into implementing diagnostics to scheme-lsp-server yet, not sure what would be a good approach here. I wonder if typically language servers implement code analysis algorithms by themselves or rely on implementation support for it
2023-05-22 09:06:50 -0400 < rgherdt> someone started developing also a language server for r6rs, and tries to implement code analysis in it: https://github.com/ufo5260987423/scheme-langserver
2023-05-22 09:07:17 -0400 < rgherdt> I didn't have in mind going down that rabbit-hole for scheme-lsp-server
2023-05-22 09:08:01 -0400 < rgherdt> it's on my TODO list to check how slime/swank solves this
2023-05-22 09:53:14 -0400 < acdw> are they going to call the tenth revision R10RS or RXRS?
2023-05-22 09:53:19 -0400 < acdw> routh by routh sest
2023-05-22 09:57:25 -0400  * edgar-rft votes for RARX :-)
2023-05-22 09:57:48 -0400 < acdw> scheme 10 rawr XD
2023-05-22 09:58:53 -0400 < sham1> The boring answer is probably just R10RA
2023-05-22 09:58:57 -0400 < sham1> R10RS
2023-05-22 10:02:55 -0400 < acdw> let's make our own scheme with xXx~rawr~xXx
2023-05-22 15:46:33 -0400 < Zipheir> acdw: Maybe there will just be further R7RS sub-standards. We already have "small", "large", "batteries", ...
2023-05-22 15:47:24 -0400 < acdw> we have batteries?!
2023-05-22 15:47:29 -0400 < acdw> i didn't know that one
2023-05-22 15:48:17 -0400 < gwatt> You can presumably mix-n-match the chromatic dockets too, so you could theoretically have r7rs +yellow -red
2023-05-22 15:49:06 -0400 < gwatt> (idk if that pairing makes sense, I just threw out colors I thought matched dockets)
2023-05-22 15:49:20 -0400 < Zipheir> acdw: I'm not sure if it's still called that. I can't keep up with https://codeberg.org/scheme/r7rs/issues
2023-05-22 15:49:35 -0400 < Zipheir> gwatt: The colors were replaced by gods, it seems.
2023-05-22 15:50:01 -0400 < edgar-rft> I suggest every Scheme implementation to have their own R7RS that is incompatible to all others
2023-05-22 15:51:17 -0400 < gwatt> That's ridiculous! We can't have competing incompatible standards! We'll have to get together and come up with one unifying standard!
2023-05-22 15:51:36 -0400 < Zipheir> I'm positive something like that will happen, though only in dark corners.
2023-05-22 15:52:17 -0400 < Zipheir> "Who will actually implement R7RS-large?" is still a big question.
2023-05-22 16:01:36 -0400 < acdw> oof
2023-05-22 16:01:41 -0400 < acdw> big oof even
2023-05-22 16:01:45 -0400 < acdw> maybe i should just go w cl
2023-05-22 16:04:23 -0400 < Zipheir> Standards aren't languages. Scheme will go on regardless of what happens with the reports.
2023-05-22 16:04:57 -0400 < Zipheir> There are implementations that have never accepted R5RS!
2023-05-22 16:12:21 -0400 < Zipheir> I mean, it's good to see implementations start from a Scheme standard they like and then experiment from there.
2023-05-22 16:14:52 -0400 < acdw> r-1rs
2023-05-22 16:19:00 -0400 < Zipheir> "Scheme occupies a unique niche. A research niche and an educational niche. It is not a language. Not R6RS, not R5RS, not R4Rs. It is an idea. Or a collection of ideas. It is a framework. It is a way of thinking. It is a mindset. All of this is embodied in an ever growing family of languages or dialects, not a single language. It is a virus. It is the ultimate programming-language virus." --Jeff Siskind
2023-05-22 16:19:48 -0400 < acdw> oh nice quote
2023-05-22 16:19:57 -0400 < acdw> i'mmma send this to my coworker who's like "eugh, scheme"
2023-05-22 16:20:49 -0400 < Zipheir> The whole thing is quoted here https://wiki.call-cc.org/elevator-pitch  Siskind can write, whether it be prose or compilers.
2023-05-22 16:34:32 -0400 < aeth> CL's very capable, but it's hard for core functionality beyond the ancient spec to get refined to the point where it's usable cross-implementation. It has taken many years to get this[1] far and it's still lacking some notable features like a unicode library that would portably let you do things like case folding. And there's a strong culture around only doing portable things. [1] https://portability.cl/
2023-05-22 16:35:03 -0400 < aeth> On the other hand, Scheme's... fragmentation I guess. For better or for worse. Few things are portable, but you can use the whole implementation (which can be quite maximalist) and not worry.
2023-05-22 16:35:19 -0400 < aeth> That's the difference between the two languages on standards imo
2023-05-22 16:36:10 -0400 < aeth> Scheme's more of a language (sub)family than a language.
2023-05-22 16:47:51 -0400 < mwnaylor> acdw: re cl: How much elisp have you done?
2023-05-22 16:48:42 -0400 < wasamasa> JSCL sure looks like crap :D
2023-05-22 16:54:47 -0400 < acdw> mwnaylor: a decent amount ... https://codeberg.org/acdw
2023-05-22 16:55:59 -0400 -!- abraxas_ is now known as abraxas
2023-05-22 16:58:20 -0400 < anthk_> but sicp it's fun
2023-05-22 17:00:48 -0400 < mwnaylor> acdw: Just asking to see if you are committed to a lisp-2. I don't like lisp-2, which would tend to keep me away from cl. Also, iirc, tail call optimization not built in, but requires a library import.
2023-05-22 17:00:58 -0400 < cow_2001> i feel stupid especially now that i'm trying to write a flatten
2023-05-22 17:03:23 -0400 < cow_2001> http://0x0.st/Hqce.txt
2023-05-22 17:04:33 -0400 < mwnaylor> The only lisp-2 I'm willing to work with is elisp. Because I have no choice if I want to hack emacs. Clojure my first choice in lisp-1, but seems to be overkill for smaller projects. That puts me more in a scheme mindset, either guile or racket. The installed documentation for racket seemo to be better (for me) than guile.
2023-05-22 17:04:53 -0400 < cow_2001> http://0x0.st/Hqc2.txt
2023-05-22 17:05:00 -0400 < cow_2001> this is up
2023-05-22 17:08:26 -0400 < gwatt> cow_2001: what happens if (car lst) is itself a pair?
2023-05-22 17:10:06 -0400 < Zipheir> append will also cough if (car lst) isn't a pair.
2023-05-22 17:10:47 -0400 < cow_2001> this is a bit better, using the non-inlined sexp handling procedure http://0x0.st/Hqc_.txt
2023-05-22 17:10:50 -0400 < cow_2001> oh
2023-05-22 17:11:00 -0400 < cow_2001> oh wait
2023-05-22 17:12:02 -0400 < cow_2001> oh boy
2023-05-22 17:15:49 -0400 < cow_2001> okay, i should have (pair? (car lst)) and not (pair? lst)
2023-05-22 17:15:53 -0400 < cow_2001> in up
2023-05-22 17:17:34 -0400 < cow_2001> should probably use the test-equal? srfi instead of manually write a bunch of displays ~_~
2023-05-22 17:18:10 -0400 < cow_2001> don't know how to do that well with orgmode
2023-05-22 17:22:29 -0400 < acdw> mwnaylor: oh yeah, i forgot about TCO.
2023-05-22 17:22:33 -0400 < acdw> i like scheme tbh
2023-05-22 17:24:57 -0400 < mwnaylor> Scheme is more like the lisp I had in college. Some variant of maclisp, as it was running or the original Mac hardware.
2023-05-22 17:25:07 -0400 < acdw> fancy
2023-05-22 17:29:42 -0400 < mwnaylor> I don't like having to keep a mental map of the differences between a variable and a function, then having to use a (to me) kludge like funcall. I feel strongly that the item in an s-exp should be bound to something that is a function or a lambda form. The lisp should Do The Right Thing.
2023-05-22 17:30:30 -0400 < acdw> i still can't get over the fact that "kludge" is pronounced "klooj"
2023-05-22 17:30:34 -0400 < acdw> it's Not Ok
2023-05-22 17:34:18 -0400 < mwnaylor> I get that, in elisp, whitespace-mode is both a variable and function. The former describes the current state; the latter toggles to the state. I have made use of that in emacs, but that does not make it compelling enough to embrace funcall.
2023-05-22 17:34:48 -0400 < mwnaylor> Yes, "kludge" should rhyme w/ "fudge" or "judge".
2023-05-22 17:34:58 -0400 < acdw> yeah the main arg for lisp-2 seems to be "i can name a variable 'list'!" which like. meh
2023-05-22 17:34:59 -0400 < acdw> yes
2023-05-22 17:43:44 -0400 < mwnaylor> At least in elisp, the function/variable pair depends upon global variables. We (setq foo <..>), which (defun foo ...) will use to determine the code path. If I'm doing global in lisp-1, I'm ok w/ having the state stored in foo-, foo_, foo-state, etc.
2023-05-22 17:44:12 -0400 < wasamasa> in CL you have earmuffs
2023-05-22 17:46:55 -0400 < cow_2001> i always read it as k'lud'j... in lieu of IPA
2023-05-22 17:47:07 -0400 < acdw> mwnaylor: that's just a convention. you could name thos variables and functions all sorts of different things
2023-05-22 17:48:28 -0400 < cow_2001> the worst thing about not being a scheme is that you do not have tail recursion :(
2023-05-22 17:48:35 -0400 < mwnaylor> acdw: Agreed. Just curious, do any lisp-1 variants have a style guide to address that?
2023-05-22 17:48:41 -0400 < acdw> yeah tail recursion is the thing really
2023-05-22 17:48:47 -0400 < acdw> mwnaylor: i was talking about elisp
2023-05-22 17:49:07 -0400 < acdw> i mean ... idk about style guide. i couldn't find anything about structuring non-trivial libraries in somewhat-portable r7rs
2023-05-22 17:49:15 -0400 < Zipheir> Admittedly, required tail recursion makes Scheme harder to implement.
2023-05-22 17:49:30 -0400 < cow_2001> you could if you're not scheme, but if you are a scheme you definitely have it
2023-05-22 17:49:52 -0400 < Zipheir> I have a copy of Riastradh's style guide. Beware, it's highly opinionated. https://www.sigwinch.xyz/misc/riastradh-lisp-style.txt
2023-05-22 17:50:50 -0400 < acdw> Zipheir: but it's so nice
2023-05-22 17:51:11 -0400 < acdw> TIL 'd' in eww
2023-05-22 17:51:24 -0400 < Zipheir> You can cut corners. DEC's early Scheme-to-C compiler didn't do full TCO; it just optimized self-calls and letrec-bound mutually-recursive forms.
2023-05-22 17:51:53 -0400 < Zipheir> In practice, that's fine. State machines, e.g., can be done with letrec.
2023-05-22 17:51:54 -0400 < gwatt> Zipheir: I don't know if requiring TCO actually makes things more difficult.
2023-05-22 17:52:00 -0400  * mwnaylor pulls up Riastradh's in w3m
2023-05-22 17:52:46 -0400 < gwatt> Well, depending on what you're targeting. an IR/IL that provides no TCO method can make things trickier.
2023-05-22 17:52:55 -0400 < Zipheir> gwatt: Not very, but my impression is that mutually recursive procedures may be a pain unless you're doing CPS or something like it.
2023-05-22 17:54:24 -0400 < mwnaylor> As long as someone more experienced then me has done the implementation of TCO, I don't care how hard it is. Somebody has done the heavy work in implementations like Scheme and Clojure, which moves those to the top of my stack.
2023-05-22 17:55:03 -0400 < Zipheir> mwnaylor: That's often how I feel about garbage collection.
2023-05-22 17:55:54 -0400 < gwatt> In the compilers course I took, we did have to specially handle tail calls, but it was relatively simple to have that case. Honestly, IIRC, Non-tail calls were more effort to implement because there's more bookkeeping around them.
2023-05-22 17:55:55 -0400 < mwnaylor> Clojure has trampoline, which I /think/ handles mutual recursion.
2023-05-22 17:56:32 -0400 < gwatt> mwnaylor: Interesting. Do you have to explicitly trampoline the code or does it happen no matter what?
2023-05-22 17:59:20 -0400 < mwnaylor> gwatt: Don't know. I may have tried it once or twice in a Clojure tutorial or working through one of the Clojure books I found.
2023-05-22 18:00:03 -0400 < mwnaylor> Forgive me father, for I have sinned. trampoline
2023-05-22 18:00:03 -0400 < mwnaylor> function
2023-05-22 18:00:03 -0400 < mwnaylor> Usage: (trampoline f)
2023-05-22 18:00:03 -0400 < mwnaylor>        (trampoline f & args)
2023-05-22 18:00:07 -0400 < mwnaylor> trampoline can be used to convert algorithms requiring mutual
2023-05-22 18:00:10 -0400 < mwnaylor> recursion without stack consumption. Calls f with supplied args, if
2023-05-22 18:00:13 -0400 < mwnaylor> any. If f returns a fn, calls that fn with no arguments, and
2023-05-22 18:00:17 -0400 < mwnaylor> continues to repeat, until the return value is not a fn, then
2023-05-22 18:00:20 -0400 < mwnaylor> returns that non-fn value. Note that if you want to return a fn as a
2023-05-22 18:00:23 -0400 < mwnaylor> final value, you must wrap it in some data structure and unpack it
2023-05-22 18:00:24 -0400 < acdw> we stan a paste spam
2023-05-22 18:00:26 -0400 < mwnaylor> after trampoline returns.
2023-05-22 18:00:29 -0400 < mwnaylor> Added in Clojure version 1.0
2023-05-22 18:00:53 -0400 < Zipheir> Please use a pastebin in the future.
2023-05-22 18:01:26 -0400 < mwnaylor> Yes, forgive my violation. I was in a hurry.
2023-05-22 18:02:46 -0400 < rgherdt> acdw: regarding portable libraries, what has worked for me so far is having some internal compatibility library that includes implementation-specific .scm files through code-expands. The remaining code is portable scheme, and usually doesn't have cond-expands
2023-05-22 18:03:11 -0400 < acdw> yeah i think that's the thing to do
2023-05-22 18:03:25 -0400 < rgherdt> like this: https://codeberg.org/rgherdt/scheme-json-rpc/src/branch/master/json-rpc/private
2023-05-22 18:03:46 -0400 < rgherdt> I also avoid using code-expand in the remaining code
2023-05-22 18:04:31 -0400 < acdw> oh this is nice
2023-05-22 18:04:35 -0400 < acdw> thanks!
2023-05-22 18:04:38 -0400 < rgherdt> yw
2023-05-22 18:04:55 -0400 < acdw> of course. ... i end up just writing the chicken part, lol
2023-05-22 18:05:24 -0400 < mwnaylor> Does scheme have a way optimize mutual recursion to avoid blowing up the stack?
2023-05-22 18:05:47 -0400 < rgherdt> previously I had implementation specific modules, like (json-rpc chicken), (json-rpc guile) etc. But that doesn't play nich with tools like snow, which traverses all libraries found
2023-05-22 18:06:02 -0400 < Zipheir> Mutual tail-calls should be optimized as usual.
2023-05-22 18:06:04 -0400 < acdw> the installation of snow i have crashes on every invocation
2023-05-22 18:06:24 -0400 < acdw> maybe i should build from source....
2023-05-22 18:06:48 -0400 < rgherdt> yep, the tool is unfortunately not really mature.
2023-05-22 18:06:50 -0400 < Zipheir> So if you build a stack machine using mutually tail-calling procedures, it should *not* blow up in Scheme.
2023-05-22 18:07:20 -0400 < Zipheir> lambda is the ultimate goto, after all.
2023-05-22 18:15:59 -0400 < acdw> rgherdt: damn
2023-05-22 18:18:49 -0400  * tomhg read the CCC paper up until chapter 3. I had a similiar idea of accumulating my stack by returning a lambda but my statefulness got into the way. So I retreat to the appel in order to make a scheme-native AST *shurgs*
2023-05-22 18:33:34 -0400 < gwatt> :Q!
2023-05-22 18:33:57 -0400 < gwatt> this isn't my vim ...
2023-05-22 18:45:57 -0400 < mdhughes> Everything's vim if you work hard enough at it. Oh, wait, that's emacs.
2023-05-22 19:19:30 -0400 < mwnaylor> Even though elisp does not support TCO, I write my code in that style. Any of my other lisp code will be Clojure or Racket, both of which implent some version of TCO. Using tail recursion in elisp leverages my experience with other lisps. I'm betting on the stack blowing up. Even if not using TCO paradigm, I'd still be using recursion in elisp. I have 2 benefits. 1) Writing code in the same style across lisp varients. 2) If elisp
2023-05-22 19:19:30 -0400 < mwnaylor> eventually builds in TCO, my code will be ready.
2023-05-22 19:24:53 -0400 < aeth> Common Lisp probably has the worst TCO of Lisps
2023-05-22 19:25:14 -0400 < aeth> because it usually has it, except not all of the time, and it's not on a per-implementation basis but on a per-global-settings basis that e.g. (debug 3) can disable
2023-05-22 20:23:37 -0400 < mfiano> I was told I have been too quiet here, so (make-noise)
2023-05-22 20:42:51 -0400 < aeth> in fact, that's something that you can easily automate with programming!
2023-05-22 20:42:58 -0400 < aeth> rudybot: isn't that right?
2023-05-22 20:42:59 -0400 < rudybot> aeth: right, nounchh suggested the same thing. teamchat has good walls between instances so for single person "teams" I could run a bunch inside one emacs instance. as I say, that isn't the problem. the technical is not the problem. 1 person + default bot is not very compelling way to show it.
2023-05-22 21:27:00 -0400 < lechner> Hi, is the use-modules acceptable in this position (near the center, and in Guile)? Thanks!     https://paste.debian.net/1280915/
--- Day changed Tue May 23 2023
2023-05-23 01:32:50 -0400 < Zipheir> lechner: You might have to ask the Guile folks. I don't know whether use-modules respects lexical scope.
2023-05-23 01:36:19 -0400 < Zipheir> lechner: Importing mid-procedure would be invalid in standard Scheme. I would avoid it, personally.
2023-05-23 01:37:16 -0400 < Zipheir> It would be nice if there were something like first-class libraries that could be "opened" in the correctly-scoped way.
2023-05-23 01:40:49 -0400 < flatwhatson> lechner: Zipheir: use-modules this way is fine, it imports into the current-module
2023-05-23 01:41:35 -0400 < Zipheir> But it binds the imported names globally within the current module, right?
2023-05-23 01:42:34 -0400 < flatwhatson> there's warnings on redefinition, so it's not completely terrible
2023-05-23 01:42:37 -0400 < Zipheir> (And what would the extent of those bindings be?)
2023-05-23 01:44:45 -0400 < flatwhatson> hmm, in this case it's complicated by the fact that this is a guix g-expression
2023-05-23 01:44:55 -0400 < Zipheir> Perhaps you could create a dynamic extent with the bindings from foo-module.
2023-05-23 01:49:33 -0400 < flatwhatson> aiui it's not lexically scoped, it's modifying whatever the current module is, but warns if that's replacing a binding with one from a different module
2023-05-23 01:50:25 -0400 < flatwhatson> worst case you've fixed a procedure which would've failed due to undefined variable which is now defined
2023-05-23 01:51:03 -0400 < Zipheir> At least it warns of potential clobbering.
2023-05-23 02:12:39 -0400 < sham1> I'd like being able to do something like (lambda whatever (import (library in scope)) (do-stuff)) since it could then mean that the whole namespace of my current program or library doesn't get polluted
2023-05-23 02:14:58 -0400 < sham1> Although a problem might arise if the import runs the library body every time the procedure is called
2023-05-23 02:17:04 -0400 < sham1> I'd honestly just allow imports in the same places as defines, they're similar enough. But yeah, having a first-class reified library would be useful
2023-05-23 02:23:17 -0400 < flatwhatson> oh interesting, looks like use-modules inside a lambda actually doesn't leak, i was incorrect
2023-05-23 02:25:58 -0400 < jobol> sham1, is there reason why importing only with/without renaming does not the job?
2023-05-23 02:30:38 -0400 < sham1> It does help but it also requires specifying that stuff manually
2023-05-23 02:31:50 -0400 < jobol> I see
2023-05-23 07:35:54 -0400 < cow_2001> orgmode + babel + a session of geiser + guile is nice
2023-05-23 08:08:08 -0400 < cow_2001> okay, i don't know how to write a recursive sort
2023-05-23 08:18:42 -0400 < sham1> You split your data into the stuff that is smaller than your pivot and the stuff that is larger. Then you sort those parts
2023-05-23 08:33:23 -0400 < cow_2001> hmmmmmmmm
2023-05-23 08:44:03 -0400 < anthk_> cow_2001: that's my setup, but with chicken instead of guile, for sicp
2023-05-23 08:48:58 -0400 < cow_2001> okay, infinite loop
2023-05-23 08:49:19 -0400 < cow_2001> i feel especially dumb
2023-05-23 08:50:17 -0400 < cow_2001> http://0x0.st/Hqmw.txt
2023-05-23 08:50:20 -0400 < cow_2001> dum dum
2023-05-23 08:56:02 -0400 < anthk_> cow_2001: this sorts a list?
2023-05-23 08:56:24 -0400 < cow_2001> http://0x0.st/Hqm3.txt
2023-05-23 08:56:26 -0400 < cow_2001> maybe
2023-05-23 08:56:28 -0400 < cow_2001> i mean, no
2023-05-23 08:56:34 -0400 < cow_2001> it recurses forever, i think
2023-05-23 08:57:51 -0400 < anthk_> if I had the whole code I could (trace) sort
2023-05-23 08:57:58 -0400 < anthk_> and the rest of functions
2023-05-23 08:58:00 -0400 < anthk_> with chicken
2023-05-23 08:58:03 -0400 < anthk_> (trace sort)
2023-05-23 08:59:43 -0400 < cow_2001> the whole src block http://0x0.st/HqmY.txt
2023-05-23 09:00:22 -0400 < cow_2001> guile modules above
2023-05-23 09:02:17 -0400 < jobol> try to exclude the pivot from sub lists
2023-05-23 09:03:02 -0400 < cow_2001> oh ~_~
2023-05-23 09:21:29 -0400 < anthk_> ok in chicken it's the same expect for the srfi loading line
2023-05-23 09:23:03 -0400 < anthk_> cow_2001:  trace in chicken:
2023-05-23 09:23:10 -0400 < anthk_> https://termbin.com/8s9pa
2023-05-23 09:23:17 -0400 < anthk_> I traced (sort) and (sorted?)
2023-05-23 09:23:35 -0400 < cow_2001> oh boy
2023-05-23 09:24:06 -0400 < anthk_> -> it's the output
2023-05-23 09:25:12 -0400 < cow_2001> oh no
2023-05-23 09:27:30 -0400 < anthk_> what's the matter?
2023-05-23 09:45:40 -0400 < cow_2001> works! http://0x0.st/HqmR.txt
2023-05-23 09:46:56 -0400 < anthk_> yes, indeed
2023-05-23 09:49:13 -0400 < anthk_> cow_2001: https://termbin.com/vc6d
2023-05-23 09:50:50 -0400 < cow_2001> anthk_: looked it up and there's ,trace EXP for guile too!
2023-05-23 09:54:09 -0400 < anthk_> on chicken it's an "egg" (module)
2023-05-23 09:54:32 -0400 < anthk_> chicken install trace as a root user
2023-05-23 09:54:39 -0400 < anthk_> chicken-install, rotty
2023-05-23 09:54:44 -0400 < anthk_> guile might do sth similar
2023-05-23 10:07:21 -0400 < cow_2001> now sort/predicate is poop
2023-05-23 10:07:37 -0400 < cow_2001> i thought i'd just have to replace the < with pred, and yet it doesn't work ~_~
2023-05-23 10:41:13 -0400 < cow_2001> of course. i forgot to replace the "sort" recursion calls with "sort/predicate pred" ~_~
2023-05-23 10:41:37 -0400 < cow_2001> and now it works ~_~
2023-05-23 10:41:58 -0400 < cow_2001> it mysteriously worked for < but not for >, because it recursed into the previously defined sort
2023-05-23 10:42:20 -0400 < cow_2001> oh, and there's already "sort" with the scheme
2023-05-23 12:04:26 -0400 < Zipheir> cow_2001: Most implementations provide a 'sort' of some sort. SRFI 132/(scheme sort) has a lot more. https://srfi.schemers.org/srfi-132/srfi-132.html
2023-05-23 12:07:31 -0400 < sham1> That is sort of what an implementation is supposed to do
2023-05-23 12:07:57 -0400 < Zipheir> There is an extremely elegant (but inefficient) functional quicksort implementation: (define (qsort xs) (match xs (() ()) ((x . xs) (append (qsort (filter (lambda (y) (< y x)) xs) (list x) (qsort (filter (lambda (y) (>= y x)) xs)))))
2023-05-23 12:10:03 -0400 < Zipheir> (I'm not sure if Richard Bird and Phil Wadler discovered that implementation, but it appears in their 1988 book.)
2023-05-23 12:11:38 -0400 < Zipheir> sham1: Some Schemes provide a sequence-generic sort procedure instead of all the vector- etc. variants.
2023-05-23 12:12:16 -0400 < sham1> That specific comment was sort of based around the pun
2023-05-23 12:12:27 -0400 < Zipheir> I thought so, but I wasn't sure. :)
2023-05-23 12:14:05 -0400 < cow_2001> oh
2023-05-23 12:14:07 -0400 < cow_2001> i dumm
2023-05-23 12:14:23 -0400 < cow_2001> wait, no
2023-05-23 12:15:30 -0400 < cow_2001> how did you make sure the x is duplicated into the.. hmmm
2023-05-23 12:16:22 -0400 < cow_2001> you append the lows, the x, and the highs
2023-05-23 12:16:39 -0400 < sham1> Well it will be duplicated into there if there are duplicates, but it doesn't matter
2023-05-23 12:17:13 -0400 < cow_2001> oh right only (list x) will end up in the output
2023-05-23 12:17:41 -0400 < cow_2001> i mean, down into the call tree you get many many (list x)
2023-05-23 12:17:43 -0400 < sham1> Because if your pivot is X, the "right side" will have the elements >= X, but if X is chosen as a pivot, then all the other elements will just go on its right
2023-05-23 12:17:46 -0400 < Zipheir> Quicksort's recursive pattern is a little tricky.
2023-05-23 12:17:59 -0400 < cow_2001> and you append all those (list x)
2023-05-23 12:17:59 -0400 < sham1> Because by definition they're >=
2023-05-23 12:18:21 -0400 < cow_2001> the lows and highs are all () at the edge of the call tree
2023-05-23 12:18:28 -0400 < sham1> Yes
2023-05-23 12:18:57 -0400 < sham1> Since the first branch of the match means that if you're sorting an empty list, you just get the empty list back
2023-05-23 12:20:03 -0400 < sham1> And this can very easily be made compatible with stuff like comparators
2023-05-23 12:21:21 -0400 < sham1> Of course unlike "real" quicksort on vectors, this is O(n) space while quicksort is O(log n) IIRC
2023-05-23 12:25:11 -0400 < Zipheir> Yeah, allocating the partitions of xs on each step is not optimal.
2023-05-23 12:25:48 -0400 < Zipheir> But quicksort's always been a pretty sorting algorithm, not the best one.
2023-05-23 12:26:13 -0400 < sham1> Well quicksort is almost the best as far as comparison sorts are concerned
2023-05-23 12:26:43 -0400 < sham1> You just need to somehow make sure that you don't hit the worst case by modifying it slightly to get introsort
2023-05-23 12:27:11 -0400 < Zipheir> introsort?
2023-05-23 12:28:34 -0400 < Zipheir> Wikipedia says it's pretty good. https://en.wikipedia.org/wiki/Introsort
2023-05-23 12:29:15 -0400 < sham1> Yeah. Worst-case O(n log m)
2023-05-23 12:29:21 -0400 < sham1> n log n
2023-05-23 12:29:48 -0400 < sham1> Of course things get more interesting once you also want stability
2023-05-23 12:29:48 -0400 < Zipheir> Which is the best worst-case, IIRC.
2023-05-23 12:29:58 -0400 < sham1> It is for comparison sorts, yss
2023-05-23 12:31:26 -0400 < sham1> You can get as low as O(n) if your data has certain properties to it
2023-05-23 12:31:58 -0400 < sham1> Usually that the sorting keys are naturals from 0 to n
2023-05-23 12:33:24 -0400 < Zipheir> Right.
2023-05-23 14:49:40 -0400 < cow_2001> blah https://git.sr.ht/~kakafarm/eopl3/tree/master/item/a.org
2023-05-23 16:46:13 -0400 < tomhg> Hey. Did I missinterpret CCC (Calculating Correct Compilers, Bahr & Hutton)? It just does not give one a parse tree because it isn't concerned with such, right?
2023-05-23 16:52:59 -0400 < edgar-rft> maybe it parses with bushes :-)
2023-05-23 16:54:48 -0400 < tomhg> No, I mean it attempts to consume the tokens immediately; But writing this shows me I should just carry on and not get drifted :o)
2023-05-23 16:57:43 -0400 < Zipheir> tomhg: I believe the types give the parse tree.
2023-05-23 16:58:48 -0400 < Zipheir> Perhaps not. I have to review the paper.
2023-05-23 16:59:02 -0400 < tomhg> yeah, you are right.
2023-05-23 16:59:13 -0400 < tomhg> Thanks for the quick answer.
2023-05-23 16:59:19 -0400 < tomhg> *answers
2023-05-23 16:59:58 -0400 < Zipheir> There is no parsing at all in that paper. The input to the compiler (type Expr) is a parsed expression.
2023-05-23 17:00:59 -0400 < edgar-rft> don't try to interpret when you have a compiler
2023-05-23 17:01:13 -0400 < Zipheir> Parsing is orthogonal to what they're talking about, which is compiling expressions for execution by (virtual) machine.
2023-05-23 17:02:05 -0400 < tomhg> Thanks. This is why I initially though I am actually interssted in an scheme-native AST. Just read about LL/LR parsing for the first time and I had to revisited the first Chapter of CCC.
2023-05-23 17:02:30 -0400 < Zipheir> Cool.
2023-05-23 17:03:40 -0400 < Zipheir> Some old-style compilers (like the one in Crenshaw's compiler tutorial) parse, compile, and emit code at the same time. But usually those stages are separated.
2023-05-23 17:05:11 -0400  * tomhg bows
2023-05-23 17:05:31 -0400 < tomhg> edgar-rft: this one I don't get. But I take a walk.
2023-05-23 17:06:45 -0400 < Zipheir> Walking is good for thinking.
2023-05-23 17:29:28 -0400 < tomhg> Its is! At work we have an non-it guy who moderates meetings while walking and calls it a roman round. I love it and myself is living just 20 meter from a roman castell so I encorporated it, somehow.
2023-05-23 17:31:47 -0400 < tomhg> edgar-rft: I forgot about it after the going downstairs, actually. So good night, schemers.
2023-05-23 17:38:28 -0400 < sham1> Interpreting while compiling can be useful. Guile for example does that for constant stuff
2023-05-23 17:38:41 -0400 < sham1> So basically a more general version of constant folding
2023-05-23 18:41:22 -0400 < Zipheir> sham1: I take it you don't mean "folding" in the recursive sense.
2023-05-23 19:11:43 -0400 -!- teiresias2 is now known as teiresias
2023-05-23 21:38:27 -0400 < gwatt> Zipheir: typically "constant folding" means doing things like convert (+ 5 5) to 10.
2023-05-23 21:41:13 -0400 < gwatt> If an implementation marks provided functions as "foldable" and then if all the arguments to those procedures are statically known, the optimizer can replace the function calls with the final result.
2023-05-23 23:25:11 -0400 < Zipheir> gwatt: Got it. Thanks.
2023-05-23 23:28:38 -0400 < Zipheir> I guess it's a catchier term than "statically evaluable".
--- Day changed Wed May 24 2023
2023-05-24 01:35:23 -0400 < sham1> Yeah, basically what gwatt said. Guile also calls the process "partial evaluation"
2023-05-24 08:42:04 -0400 < cow_2001> uhm
2023-05-24 08:42:41 -0400 < cow_2001> exercise 2.3.1 in eopl3: http://0x0.st/Hqpa.txt
2023-05-24 10:29:07 -0400 < cow_2001> when doing exercise eopl3 2.3.2, it is probably cheating doing a diff->integer first, right?
2023-05-24 10:30:22 -0400 < cow_2001> a Diff-tree ::= (one) | (diff Diff-tree Diff-tree)
2023-05-24 10:30:52 -0400 < cow_2001> (one) is the primitive 1 and (diff (one) (one)) is a composite 0
2023-05-24 10:31:31 -0400 < cow_2001> (diff d_1 d_2) read: the value of d_1 minus the value of d_2
2023-05-24 11:21:39 -0400 < Zipheir> cow_2001: Clearly using diff->integer would not be what they have in mind.
2023-05-24 11:23:21 -0400 < Zipheir> cow_2001: Although it might be helpful to *specify* the operations in terms of diff->integer.
2023-05-24 11:46:39 -0400 < cow_2001> Zipheir: tricky
2023-05-24 11:47:09 -0400 < cow_2001> there is a simple way of doing it
2023-05-24 12:24:25 -0400 < cow_2001> in haskell it would be: data DiffTree = One | Diff DiffTree DiffTree
2023-05-24 12:24:33 -0400 < cow_2001> with some deriving typeclasses
2023-05-24 12:29:28 -0400 < Zipheir> That doesn't tell you any more than the EoPL style type definition.
2023-05-24 12:29:49 -0400 < cow_2001> yes
2023-05-24 12:30:02 -0400 < cow_2001> it's all opaque
2023-05-24 12:30:04 -0400 < cow_2001> dumdum
2023-05-24 12:33:04 -0400 < cow_2001> not you, me
2023-05-24 12:35:49 -0400 < cow_2001> wait, i can just do it constructively
2023-05-24 12:36:00 -0400 < cow_2001> without bothering with normalisation
2023-05-24 12:36:14 -0400 < cow_2001> normalisation is future me's problem
2023-05-24 12:36:49 -0400 < cow_2001> no, i still have to write down is-zero?
2023-05-24 12:41:29 -0400 < Zipheir> I have to say that I never bothered to finish the diff-tree exercises. They have almost nothing to do with the rest of the book.
2023-05-24 12:41:43 -0400 < cow_2001> :|
2023-05-24 12:41:48 -0400 < cow_2001> :|||||||
2023-05-24 12:42:54 -0400 < Zipheir> Here is what they have to do with programming language theory: Abstract types can be implemented in different ways.
2023-05-24 12:47:30 -0400 < Zipheir> (If this is your kind of thing, you can go on to things like implementing Scheme on GNU make https://github.com/kanaka/mal)
2023-05-24 12:50:05 -0400 < cow_2001> oh no.
2023-05-24 12:50:31 -0400 < cow_2001> malpractice
2023-05-24 12:50:49 -0400 < cow_2001> wait, it's a serious project?
2023-05-24 12:52:35 -0400 < gwatt> Let's not get ahead of ourselves. It's a thing that exists because someone wanted to make it. Not necessarily "serious"
2023-05-24 12:53:03 -0400 < cow_2001> no, this whole mal thing
2023-05-24 12:53:40 -0400 < Zipheir> It's been around for a while.
2023-05-24 12:53:45 -0400 < cow_2001> is it all a didactic thing or a real useful thing? is it all about running the same code on many different places where maybe this or that interpreter / compiler do not exist?
2023-05-24 12:55:40 -0400 < cow_2001> a sort of a universal language that runs on anything you've gotten access to because you'd like to spy or sabotage whomever?
2023-05-24 12:55:46 -0400 < Zipheir> In a world where data-vaccuuming song-sharing apps are considered "real, useful", I don't understand the distinction.
2023-05-24 12:56:22 -0400 < cow_2001> like lua on iranian centrifuges
2023-05-24 12:56:29 -0400 < Zipheir> cow_2001: It's for experimenting with language implementations.
2023-05-24 12:56:33 -0400 < cow_2001> oh
2023-05-24 12:56:45 -0400 < Zipheir> Great, because *that's* a good thing to use programming for.
2023-05-24 12:57:21 -0400 < Zipheir> Sorry, I need to have some more coffee.
2023-05-24 12:57:32 -0400 < cow_2001> i've recently watched three cold war anti nuke movies
2023-05-24 12:58:43 -0400 < cow_2001> The Mouse That Roared, The Russians Are Coming (well, maybe not anti nuke, but very... hopeful? movie), and Dr. Strangelove
2023-05-24 12:59:42 -0400 < cow_2001> what sort of coffee do you usually have, zipheir?
2023-05-24 13:00:41 -0400 < cow_2001> mal reminds me of that roguelike tutorial
2023-05-24 13:01:02 -0400 < Zipheir> Cheap stuff. I default to Café Bustelo if there's nothing else affordable.
2023-05-24 13:01:43 -0400 < cow_2001> i haven't seen that firm around here
2023-05-24 13:03:45 -0400 < Zipheir> I mentioned MaL because it involves problems like finding strange implementations of numbers that work on, say, make.
2023-05-24 13:06:46 -0400 < cow_2001> yeah
2023-05-24 13:07:08 -0400 < cow_2001> a layer of abstraction between mal and substrate
2023-05-24 13:07:50 -0400 < cow_2001> thank you!
2023-05-24 13:08:30 -0400 < Zipheir> :)
2023-05-24 21:12:27 -0400 < Zipheir> https://srfi-email.schemers.org/srfi-discuss/msg/22667768/  mnieper makes a good point about SRFI 1 linear update procedures, but it's probably too late to change any names.
2023-05-24 21:37:47 -0400 < flatwhatson> extending ! to describe call/cc unsafety and retroactively renaming stuff seems pretty radical
2023-05-24 21:38:12 -0400 < flatwhatson> but he seems to suggest that this use of ! comes from R6RS?
2023-05-24 21:38:17 -0400 < acdw> what other punc marks are there
2023-05-24 21:38:28 -0400 < acdw> map~
2023-05-24 21:39:02 -0400 < acdw> map‽
2023-05-24 21:39:12 -0400 < acdw> map∆
2023-05-24 21:40:06 -0400 < flatwhatson> if you want guaranteed continuation-safe procedures, wouldn't it make sense to have a library which provides safe replacements?
2023-05-24 21:44:28 -0400 < Zipheir> That's one possibility.
2023-05-24 21:45:05 -0400 < acdw> I thinks that's how Haskell does it? sorta?
2023-05-24 21:46:02 -0400 < Zipheir> Haskell's an interesting question. You might be able to expose mutation through continuations in a Haskell library that uses unsafePerformIO.
2023-05-24 21:46:27 -0400 < Zipheir> It's a widespread, but maybe not that serious problem in Scheme.
2023-05-24 21:46:46 -0400 < acdw> oh I was just thinking of how they have libraries that like, expose alternative versions of standard procedures
2023-05-24 21:47:14 -0400 < Zipheir> Oh, ok.
2023-05-24 21:47:51 -0400 < Zipheir> That's probably the solution I would prefer.
2023-05-24 21:58:07 -0400 < acdw> makes a bunch of sense, I really like it
2023-05-24 21:58:35 -0400 < acdw> I guess package authors might not want to write two versions of everything... tho I don't think that would be necessary
2023-05-24 21:59:26 -0400 < Zipheir> I once half-seriously suggested that libraries use names like "map" instead of "widget-map" and let the person importing the library add their own prefixes.
2023-05-24 21:59:49 -0400 < Zipheir> But without static type checking this is tricky.
2023-05-24 22:00:34 -0400 < acdw> mm
2023-05-24 22:02:07 -0400 < Zipheir> Sometimes the naming does get very heavy, e.g. computation-environment-ref, (computation-environment-update, etc. (sorry, Marc)
2023-05-24 22:04:22 -0400 < flatwhatson> that's kind of the CLOS approach right?
2023-05-24 22:04:44 -0400 < Zipheir> Maybe? I don't know CLOS.
2023-05-24 22:05:40 -0400 < flatwhatson> the idea would be that you make map a generic function with runtime dispatch
2023-05-24 22:06:25 -0400 < Zipheir> Oh, that's a much bigger project. I was just talking about naming.
2023-05-24 22:10:59 -0400 < flatwhatson> guile supports a renamer procedure which can arbitrarily rename symbols on import
2023-05-24 22:11:21 -0400 < flatwhatson> so you could s/computation-environment/ce/ on all the symbols
2023-05-24 22:12:56 -0400 < Zipheir> That's interesting.
2023-05-24 22:13:15 -0400 < Zipheir> But then, there's always (import (rename ...)).
2023-05-24 22:14:20 -0400 < Zipheir> Which is, arguably, less surprising than auto-renaming.
2023-05-24 22:15:26 -0400 < flatwhatson> yes, retains grepability
--- Day changed Thu May 25 2023
2023-05-25 00:05:23 -0400 < mdhughes> Also internally it's sometimes convenient to (let [(bar verylongname-bar)], so it's documented close to where you use it.
2023-05-25 04:15:40 -0400 < cow_2001> this non-naive apply procedure, which takes a procedure and an environment, sounds very very powerful.
2023-05-25 04:16:40 -0400 < cow_2001> like many different schemes all running together
2023-05-25 04:16:56 -0400 < cow_2001> (haven't gotten to actually using it)
2023-05-25 04:19:33 -0400 < cow_2001> also saving and loading
2023-05-25 05:11:41 -0400 < cow_2001> i don't quite understand how to use the notation of describing the operations of environments for describing stacks as in exercise 2.4
2023-05-25 06:13:22 -0400 < sham1> Wouldn't the stack be environments pointing to environments?
2023-05-25 16:59:41 -0400 -!- grettke_ is now known as grettke
2023-05-25 17:37:41 -0400 -!- Netsplit *.net <-> *.split quits: civodul, FiskFan1999, teiresias, mdhughes, f8l, wasamasa, gnomon
2023-05-25 18:04:54 -0400 -!- Netsplit over, joins: wasamasa, teiresias, mdhughes, f8l, gnomon
2023-05-25 21:21:01 -0400 < cow_2001> you know how there's the tail recursive way of writing factorial and the recursive way? how about the tail call way plus a stack argument? isn't that funny?
2023-05-25 21:21:08 -0400 < cow_2001> :|
2023-05-25 21:22:31 -0400 < Zipheir> Isn't that just CPS?
2023-05-25 21:22:36 -0400 < cow_2001> (def (fac n s) (if (= n 0) (apply * s) (fac (1- n) (cons n s)………
2023-05-25 21:22:42 -0400 < cow_2001> ………
2023-05-25 21:22:57 -0400 < Zipheir> Oh. It's the hylomorphic version.
2023-05-25 21:23:06 -0400 < cow_2001> ??
2023-05-25 21:23:45 -0400 < Zipheir> A hylomorphism is a function that can be factored as (1) unfolding a list, then (2) folding it.
2023-05-25 21:24:12 -0400 < Zipheir> So here you unfold the factors of n!, then fold those factors with *.
2023-05-25 21:25:35 -0400 < cow_2001> i now need to sleep. good night!
2023-05-25 21:25:39 -0400 < cow_2001> thank you
2023-05-25 21:25:56 -0400 < Zipheir> Good night.
--- Day changed Fri May 26 2023
2023-05-26 11:42:52 -0400 -!- rgherdt_ is now known as rgherdt
2023-05-26 12:01:50 -0400 < cow_2001> oh, an alternative alist structure in environments: Env ::= () | (list Var Val Env)
2023-05-26 12:02:39 -0400 < cow_2001> Alist ::= () | (list (Key . Val) Alist)
2023-05-26 12:03:09 -0400 < acdw> that first one is a plist i think
2023-05-26 12:03:10 -0400 < acdw> yeah
2023-05-26 12:03:59 -0400 < cow_2001> plist o.o
2023-05-26 12:04:56 -0400 < cow_2001> they are both trivially similar, no? it is just a coin flip that this rather than that was chosen, no?
2023-05-26 12:05:15 -0400 < cow_2001> err
2023-05-26 12:05:17 -0400 < cow_2001> wait
2023-05-26 12:05:19 -0400 < acdw> pretty much yeah
2023-05-26 12:05:37 -0400 < acdw> i think that different lisps maybe preferred different ones or something? back in the Day
2023-05-26 12:05:58 -0400 < acdw> like, Emacs uses both in various things, kind of willy-nilly
2023-05-26 12:06:26 -0400 < acdw> plist is short for 'property list' b/c afaik CL used it (and emacs does too) to store properties of objects
2023-05-26 12:06:59 -0400 < acdw> i prefer alist b/c you can do like, (map (lambda (x) (do-thing-with (car x) (cdr x))) alist)
2023-05-26 12:07:03 -0400 < acdw> which you can't w plist
2023-05-26 12:07:11 -0400 < cow_2001> ah
2023-05-26 12:07:17 -0400 < cow_2001> so not so similar
2023-05-26 12:07:22 -0400 < gwatt> I suspect plists are more pleasant to write by hand, but alists seem slightly easier to work with in code
2023-05-26 12:07:27 -0400 < acdw> yeah i think so
2023-05-26 12:11:08 -0400 < Zipheir> That doesn't look like a plist.
2023-05-26 12:13:01 -0400 < Zipheir> I think it's equivalent to one, though.
2023-05-26 12:13:44 -0400 < Zipheir> The hard part about specifying a type of plists is that they're heterogenous lists.
2023-05-26 12:14:18 -0400 < Zipheir> I think EoPL calls this kind of thing a "ribcage".
2023-05-26 12:15:37 -0400 < acdw> oh i missed some context
2023-05-26 12:18:03 -0400 < Zipheir> A plist would be something like (x 1 y 2), equivalent to the alist ((x . 1) (y . 2)).
2023-05-26 12:18:53 -0400 < Zipheir> You could type that first list as (list-of (or Symbol Number)), but that's not the whole story.
2023-05-26 12:56:46 -0400 < sham1> plists work nicer with things like apply
2023-05-26 12:57:24 -0400 < Zipheir> Yes, but you can't in general validate them.
2023-05-26 13:16:51 -0400 < Zipheir> Well, you could at least check that the even-numbered elements are symbols, and you can check for unbalanced plists in O(n) time. You can't check alists any faster, of course.
2023-05-26 13:30:10 -0400 < Zipheir> I didn't mean to make a point about validation. I meant to say only that it's hard to write the type of a plist.
2023-05-26 13:36:08 -0400 < sham1> Well, plist := () | (cons* a b plist)
2023-05-26 13:36:21 -0400 < sham1> For all a, b
2023-05-26 13:38:59 -0400 < dadinn[m]> Hi all
2023-05-26 13:42:13 -0400 < Zipheir> dadinn[m]: Welcome.
2023-05-26 13:42:22 -0400 < dadinn[m]> I've written to guile-devel around a month ago about a hygienic rewrite of (ice-9 expect) macros:
2023-05-26 13:42:22 -0400 < dadinn[m]> https://mail.gnu.org/archive/html/guile-devel/2023-05/index.html
2023-05-26 13:42:26 -0400 < Zipheir> sham1: If it's enough to define them as even-length lists.
2023-05-26 13:43:04 -0400 < dadinn[m]> Sorry, I meant this thread:
2023-05-26 13:43:04 -0400 < dadinn[m]> https://mail.gnu.org/archive/html/guile-devel/2023-05/msg00026.html
2023-05-26 13:46:51 -0400 < Zipheir> dadinn[m]: You may want to mention that in #guile, if you haven't already.
2023-05-26 13:47:27 -0400 < Zipheir> There is some Guile-related discussion here, but we don't usually get any Guile big wheels.
2023-05-26 13:47:39 -0400 < dadinn[m]> Zipheir: ah true :P
2023-05-26 13:50:42 -0400 < dadinn[m]> Actually, I've discussed it with @mnieper here to rewrite this.
2023-05-26 13:59:31 -0400 < Zipheir> Ah, good. He hasn't been on IRC for a few weeks, unfortunately.
2023-05-26 14:15:48 -0400 < Zipheir> sham1: Sorry, I didn't read carefully enough. That does cover plists, provided the "values" are all bs.
2023-05-26 14:16:06 -0400 < Zipheir> And the keys are all as.
2023-05-26 15:53:52 -0400 < amirouche> Zipheir: acdw there is a new one at
2023-05-26 15:54:14 -0400 < amirouche> I think there is a new version of the html / markdown version of R7RS-small done by vincent chair of committee P
2023-05-26 15:54:42 -0400 < acdw> ooo
2023-05-26 15:54:44 -0400 < acdw> donde
2023-05-26 15:54:55 -0400 < amirouche> donde?
2023-05-26 15:55:07 -0400 < acdw> (hwere)
2023-05-26 15:57:21 -0400 < amirouche> I do not find it anymore, it shoud be at https://groups.google.com/g/scheme-reports-wg2/search?q=vincent
2023-05-26 15:57:38 -0400 < acdw> oh
2023-05-26 15:57:45 -0400 < amirouche> otherwise for basic search look at https://groups.google.com/g/scheme-reports-wg2/search?q=vincent
2023-05-26 15:57:46 -0400 < acdw> why google groups,oof
2023-05-26 15:57:52 -0400 < amirouche> oops https://scheme.rs/specification/#container
2023-05-26 15:59:38 -0400 < acdw> oh nice, that's the html then eh
2023-05-26 15:59:51 -0400 < acdw> needs to be cleaned up but not bad
2023-05-26 16:00:34 -0400 < amirouche> vincent did another port that is better, or maybe I am dreaming
2023-05-26 16:00:38 -0400 < acdw> hm
2023-05-26 16:01:32 -0400 < amirouche> I sent a message to vincent
2023-05-26 16:03:02 -0400 < acdw> :D
2023-05-26 16:17:43 -0400 < Zipheir> amirouche: Thanks.
2023-05-26 16:21:41 -0400 < tomhg> Just a Hi. *musicandhousehold*
2023-05-26 16:23:33 -0400 < Zipheir> Hi tomhg
2023-05-26 16:40:09 -0400 < tomhg> *shortstopby* Today someone suggest "event storming" to explore a process which I just want to drop without context and proceed with my things :)
2023-05-26 21:43:03 -0400 -!- Netsplit *.net <-> *.split quits: gabot, bsima, fgudin, pyro
2023-05-26 21:48:21 -0400 -!- Netsplit over, joins: fgudin, gabot, bsima
--- Day changed Sat May 27 2023
2023-05-27 00:44:33 -0400 < lockywolf> What is the difference between "epistemological", and "semantical"?
2023-05-27 03:31:59 -0400 < Franciman> lockywolf: usually epistemological is about the act of knowing
2023-05-27 03:32:09 -0400 < Franciman> semantical is about giving meaning to things
2023-05-27 03:34:43 -0400 < Franciman> sorry , semantical is about the meaning of things
2023-05-27 06:14:53 -0400 < amirouche> acdw, Zipheir: here is the html rendering I was thinking about: https://standards.scheme.org/corrected-r7rs/r7rs.html
2023-05-27 06:15:07 -0400 < amirouche> > Lassi Kortela and Dorai Sitaram did the conversion, using an (apparently) modified version of tex2page, which can be found at https://github.com/ds26gte/tex2page.
2023-05-27 08:27:31 -0400 < festerdam> Hi, all.
2023-05-27 08:33:01 -0400 < acdw> amirouche: oh hey!
2023-05-27 08:33:14 -0400 < acdw> thanks
2023-05-27 08:36:36 -0400 < festerdam> Recursion is an elegant and intuitive approach to problem solving, but it performs badl when compared to an iterative solution, and is limited by the size of the stack. Some languages like Scheme optimize tail-recursion to allow to do recursion with constant stack usage. However, it only works if we are working with a tail-call, if we do anything else with that result, the code won't be optimized, so
2023-05-27 08:36:41 -0400 < festerdam> everything has to be passed as arguments to the function. This has the consequence that solutions that use this kind of optimization end up being immitations of imperative programming, without explicitly using any imperative constructs. Has there been any research on also optimizing recursive functions that aren't tail-recursive?
2023-05-27 08:36:46 -0400 < festerdam> *badly
2023-05-27 08:41:23 -0400 < festerdam> And if yes, where can I read more
2023-05-27 08:41:25 -0400 < festerdam> *?
2023-05-27 08:42:31 -0400 -!- abraxas_ is now known as abraxas
2023-05-27 08:43:35 -0400 < festerdam> Or rather, where should I look?
2023-05-27 09:52:26 -0400 < wklew> laziness seems to be one solution. in a strict language you have to push the whole recursive chain onto the stack first, then start evaluating. but if you're recursing over a lazy structure like a stream you can still produce values iteratively.
2023-05-27 09:53:38 -0400 < wklew> so for example haskell functions on lists are more elegant than ours. but then you have tradeoffs with laziness as well, space leaks and such.
2023-05-27 10:18:52 -0400 < sham1> Space leaks and things like lazy IO being weird
2023-05-27 10:23:37 -0400 < Zipheir> They're gone already.
2023-05-27 10:26:20 -0400 < Zipheir> Who says "recursion performs badly"? That's oversimplified.
2023-05-27 10:29:09 -0400 < Zipheir> amirouche: Thanks a lot for the link. I'll look at it after the weekend. I'm going to be AFK a lot until Monday.
2023-05-27 10:30:30 -0400 < sham1> Darn smart-part filtering. I can't see if a chatter has left
2023-05-27 10:48:31 -0400 < Zipheir> Be excellent to each other. :)
--- Log closed Sat May 27 10:48:33 2023
