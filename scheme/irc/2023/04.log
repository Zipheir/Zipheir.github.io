--- Day changed Sat Apr 01 2023
2023-04-01 04:36:25 -0400 < tomhg> mdhughes: This is the only method I came up with https://termbin.com/jbzu to log some gc statistics. This is not in a parseable format yet, though.
2023-04-01 04:37:11 -0400 < tomhg> daviid: That's my problem: I do not fully grasp the documentation at the end of this chapter and the sibling 19.6 @https://www.iro.umontreal.ca/~gambit/doc/gambit.html#C_002dinterface
2023-04-01 04:40:07 -0400 < tomhg> To me it sounds that after I have allocated memory on the C-side and return it as a scheme-object, it would be enough to free the created memory immediately via a macro after returning since the memory was copied to an gc-managed-mem-block. I will inspect this. Though I have troubles understanding why there are _four_ type-conversion-methods on `(c-define-type`s to be quite honest.
2023-04-01 04:42:51 -0400  * tomhg leaves the said macro for the interested: `  return str;
2023-04-01 04:42:51 -0400 < tomhg>   #define ___AT_END if (str != NULL) ___release_rc(str);
2023-04-01 04:44:36 -0400 < mdhughes> There are tracing mallocs in C, but I haven't used such in years. Large-scale, I use Xcode's Instruments, which is basically dtrace with a good UI.
2023-04-01 04:48:51 -0400 < tomhg> *levelshisglasses* that's above my current capabilities yet.
2023-04-01 05:24:37 -0400 < mnieper> By "jit" I meant a library that allows an application to compile code just-in-time and abstracted away from a concrete machine.
2023-04-01 05:25:11 -0400 < mnieper> libgccjit, LLVM, GNU lightning, etc. fall under this definition.
2023-04-01 05:25:27 -0400 < mnieper> As does a Scheme whose `eval' compiles code on the fly.
2023-04-01 05:29:16 -0400 < dpk> libgccjit, at least as used by Emacs, is actually an AOT compiler, despite the name
2023-04-01 05:38:08 -0400 < mnieper> Yes, unlike GNU lightning, it can also write the jitted code into an object file.
2023-04-01 05:38:45 -0400 < mnieper> In fact, even when used as a jit, it writes a shared object and dynamically links it.
2023-04-01 05:39:15 -0400 < mnieper> This is because it has to rely on gas as one can use asm intrinsics in the libgccjit frontend.
2023-04-01 05:39:54 -0400 < mnieper> What's missing to make the world more perfect is something like libgas.
2023-04-01 07:47:23 -0400 < eve2002> is there a way to write a `double-even` function that doubles every even number, using tail recursion and `cons` that doesnt require reversing the list? I think this might be a more general pattern that traverses a list, making changes in some of the values, pretty much like a map function would do? all my attempts at solving this problem end up to
2023-04-01 07:47:23 -0400 < eve2002> requiring some way of reversing the list; any help is welcom as to find a way to solve this problem
2023-04-01 07:47:55 -0400 < mnieper> eve2002: You have a list of numbers given?
2023-04-01 07:48:10 -0400 < eve2002> yes
2023-04-01 07:48:45 -0400 < mnieper> You can do it using set-cdr!
2023-04-01 07:49:19 -0400 < mnieper> But this will not necessarily be better than using reverse on non-tail recursion.
2023-04-01 07:49:27 -0400 < eve2002> hmmm... that means I can set the tail part of a cons cell?
2023-04-01 07:49:39 -0400 < mnieper> Yes.
2023-04-01 07:50:03 -0400 < sham1> cdr-part*
2023-04-01 07:50:33 -0400 < mnieper> eve2002: But why do you rule out non-tail recursion or reverse?
2023-04-01 07:50:38 -0400 < eve2002> great... that is exactly what I need...
2023-04-01 07:50:57 -0400 < eve2002> this is just an exercise, actually... thats why
2023-04-01 07:51:57 -0400 < mnieper> In production code, just use `map' and assume that the system's implementation of `map' takes the most efficient route.
2023-04-01 07:52:53 -0400 < mnieper> In your exercise, consider using `make-list` to preallocate the list.
2023-04-01 07:53:07 -0400 < mnieper> This can be helpful for cache locality.
2023-04-01 07:53:35 -0400 < mnieper> If you use `make-list', you will need `set-car!', not `set-cdr!'.
2023-04-01 07:53:46 -0400 < eve2002> What does it mean to preallocate a list?
2023-04-01 07:53:52 -0400 < mnieper> Effectively, you will program as if you were coding in C.
2023-04-01 07:54:04 -0400 < eve2002> a mutable list?
2023-04-01 07:54:36 -0400 < mnieper> eve2002: (let ([res (make-list <number-of-items>)]) <loop to set-car! the values> res)
2023-04-01 07:55:21 -0400 < mnieper> Of course, you need to know the number of items, but this you can get with iteration from the original list.
2023-04-01 07:55:42 -0400 < mnieper> Alternatively, use the system's `list-copy' and then again modify in place.
2023-04-01 07:56:46 -0400 < mnieper> But, as I said, the exercise's code will look more like C in disguise of Scheme than actual Scheme. :)
2023-04-01 07:57:15 -0400 < eve2002> thats great anyway... I didnt even know this was possible with scheme
2023-04-01 07:57:53 -0400 < mnieper> Scheme is a multi-paradigm programming language.
2023-04-01 07:59:00 -0400 < eve2002> thanks a lot mnieper!
2023-04-01 08:03:04 -0400 < mnieper> YW
2023-04-01 11:45:05 -0400 -!- libfud1 is now known as libfud
2023-04-01 12:47:03 -0400 < amirouche> New TIOBE results are out!
2023-04-01 12:47:10 -0400  * amirouche drumrolls
2023-04-01 12:47:15 -0400 < amirouche> Rank 1: Scheme
2023-04-01 12:47:16 -0400 < amirouche> :P
2023-04-01 12:59:24 -0400 < Zipheir> Libera is moving to Discord? WTF is this!
2023-04-01 13:00:09 -0400 < johnjaye> april fool? lol
2023-04-01 13:01:02 -0400 < Zipheir> Oops. :)
2023-04-01 13:01:24 -0400  * Zipheir makes coffee and tries to remember what day it is.
2023-04-01 13:03:31 -0400 < amirouche> lol
2023-04-01 13:11:22 -0400 < johnjaye> scheme is moving to update itself to be more rust friendly by eliminating () and introducing cargo. that would be a fun af joke
2023-04-01 13:14:38 -0400 < Zipheir> Nested whitespace would be even funnier.
2023-04-01 13:17:47 -0400 < amirouche> cargo, or... cargo kult :p
2023-04-01 13:17:58 -0400 < Zipheir> The good thing about Scheme is that no one would care about such a joke. There's no one with the authority to make such a change.
2023-04-01 13:18:28 -0400 < Zipheir> We live not at the whims of a Guido or Larry.
2023-04-01 13:21:06 -0400 < ecraven> are there any nice cross-implementation libraries for ll/lr parsing and lexing?
2023-04-01 13:21:50 -0400 < amirouche> people like to gaze at the stars
2023-04-01 13:21:54 -0400 < mdhughes> Scheme finally gets syntax: https://srfi.schemers.org/srfi-119/srfi-119.html
2023-04-01 13:23:47 -0400 < Zipheir> ecraven: Dominique Boucher's lalr library is used by Guile and CHICKEN. I think it's portable. https://wiki.call-cc.org/eggref/5/lalr
2023-04-01 13:24:21 -0400 < Zipheir> I don't know whether it's correct. The code is good, but all of the comments are in French. :)
2023-04-01 13:26:14 -0400 < Zipheir> For lexing, there's Silex, but that's a similar story: it's big and minimally documented.
2023-04-01 13:26:39 -0400 < johnjaye> i heard an argument once on a presentation that language is code
2023-04-01 13:26:55 -0400 < johnjaye> i.e. in order to understand code in french you must speak french
2023-04-01 13:27:15 -0400 < johnjaye> by this logic we could not use boucher's library because we wouldn't understand it
2023-04-01 13:27:32 -0400 < Zipheir> Programmer's Sapir-Whorf?
2023-04-01 13:27:41 -0400 < johnjaye> basically yeah
2023-04-01 13:28:03 -0400 < johnjaye> for example variable names aren't foo or bar, they're queue or stack or pile or numbers. all english words
2023-04-01 13:28:22 -0400 < Zipheir> "We can't understand his program because it's written in Swedish Lisp." --from a Daniel Dennett thought experiment
2023-04-01 13:28:23 -0400 < johnjaye> even something like acc for accumulator you need a language cue to get it
2023-04-01 13:28:48 -0400 < Zipheir> True.
2023-04-01 13:29:13 -0400 < johnjaye> admittedly this argument is a bit silly at the assembly language level since at that point it's just a matter of 3 or 4 letters
2023-04-01 13:29:33 -0400 < Zipheir> I'm sometimes surprised to see so many non-native-English-speaking users of Lisps.
2023-04-01 13:29:41 -0400 < johnjaye> i asked somehow how about china and they told me in china they just use english to program but comments are in chinese
2023-04-01 13:30:28 -0400 < Zipheir> Probably in part because so many languages disallow Chinese names.
2023-04-01 13:30:39 -0400 < retropikzel> I'm finnish and I use english to program, english for comments. At work we do that too. I think any comments in finnish would be seen as old school way of doing things
2023-04-01 13:30:41 -0400 < Zipheir> Although that's being fixed, slowly.
2023-04-01 13:30:52 -0400 < Zipheir> Interesting.
2023-04-01 13:31:59 -0400 < mnieper> ecraven: My LR(1) parser generator is in portable R6RS.
2023-04-01 13:32:07 -0400 < retropikzel> But I can not say 100% sure for all finnish companies and programmers, I would certainly argue(in my work, for other finnish programmers) that all should be in english because you never know who will work in the code in the future
2023-04-01 13:32:30 -0400 < mnieper> ecraven: should be easily portable to any system that has syntax-case.
2023-04-01 13:32:53 -0400 < Zipheir> Still, Lisp-like languages seems more reliant on English than C-like languages, so I'm always a little surprised that people take on the extra work of learning names like 'call-with-current-continuation'.
2023-04-01 13:34:07 -0400 < Zipheir> retropikzel: In Finland, wouldn't the argument go the other way? You never know who'll be reading it, but they're probably more likely to know Finnish than English.
2023-04-01 13:34:12 -0400 < retropikzel> I would be suprised to meet a programmer who does not haw english skills here. But then again we are quite small population(5 million) so we kind of have to. It's propably different for spanish, french and german atleast
2023-04-01 13:34:28 -0400 < Zipheir> Despite very high levels of English knowledge in Scandanavia.
2023-04-01 13:34:30 -0400 < retropikzel> *have (excellent sentence to have typo in :D)
2023-04-01 13:35:01 -0400 < mnieper> Zipheir: Chicken's lalr unfortunately needs an external run (as Bison) to generate the actual parser.
2023-04-01 13:35:52 -0400 < retropikzel> Zipheir, might be, but then again if your company has even 1 person who does not speak finnish it's a problem. Similar if you want to share code online. Finnish is quite hard language
2023-04-01 13:36:13 -0400 < Zipheir> mnieper: Don't you want to compile the parser in advance, though?
2023-04-01 13:37:44 -0400 < Zipheir> retropikzel: That makes sense.
2023-04-01 13:37:54 -0400 < mnieper> Zipheir: Yes, but this should be done by the macro expander.
2023-04-01 13:38:06 -0400 < Zipheir> Finnish is a very beautiful language. Hard to practice in western New York, though. :-/
2023-04-01 13:38:13 -0400 < retropikzel> Zipheir, when I think about I would be quite suprised if somebody who knew how to program would know _only_ finnish and not english. After all most of the material is in english
2023-04-01 13:38:14 -0400 < mnieper> Zipheir: Scheme has phasing, so one should make use of it.
2023-04-01 13:38:35 -0400 < Zipheir> mnieper: I think I agree.
2023-04-01 13:39:45 -0400 < Zipheir> Yes, but I hope that knowing English isn't always a prerequisite of programming.
2023-04-01 13:40:57 -0400 < Zipheir> mnieper: The existing LALR and lexing tools stick too close to the C models, especially since they don't use macro expansion to build their machines.
2023-04-01 13:42:10 -0400 < mdhughes> I've seen Indian programs (Java, obvs) where some but not all of the functions & variables are written in Hindi, because Java was an early adopter of Unicode names.
2023-04-01 13:42:16 -0400 < retropikzel> Zipheir, personally I would argue english is the most important language for programmer to know :) All the books in finnish for example tend to be old, if they are translated at all
2023-04-01 13:42:45 -0400 < mdhughes> It's hard to read them at first, but after a bit you get used to "this stringy blob" means transaction, "that stringy blob" means commit, etc.
2023-04-01 13:43:04 -0400 < Zipheir> I was talking to sandra about lexing, and it seems that you could build a perfectly good lex with the portable irregex/SRFI 115 library. What's needed is a way to dump regexp DFAs for later reading.
2023-04-01 13:43:14 -0400 < retropikzel> I'm propably not good measurement but to me its hard to use finnish words for programming stuff, it feels so weird because I've always used the english ones. Like container is kontti in finnish and it just feels odd :D
2023-04-01 13:43:49 -0400 < Zipheir> retropikzel: Wow.
2023-04-01 13:44:03 -0400 < retropikzel> And failure is epäonnistuminen, so its just easier to say that something "feilaa" fails
2023-04-01 13:44:25 -0400 < retropikzel> Unit tests failed, unit testit feilas. Finglish :)
2023-04-01 13:44:34 -0400 < Zipheir> I love it.
2023-04-01 13:44:42 -0400 < Zipheir> Language is weird.
2023-04-01 13:44:46 -0400 < mdhughes> But languages will probably always be English first, because you need source portability. If you put a language specifier at the top of a file, and write everything in Hindi, nobody else can maintain it.
2023-04-01 13:45:18 -0400 < mdhughes> They tried localized COBOL in the early days, and it immediately ran into that problem (mostly French & German, Unicode being 50 years in the future)
2023-04-01 13:46:40 -0400 < mdhughes> Alternately, we can all go back to machine language. Numbered opcodes & addresses are universal.
2023-04-01 13:47:22 -0400 < Zipheir> Universal for a single architecture.
2023-04-01 13:47:41 -0400 < retropikzel> Or (joke) take the worst way possible, use numbered opcodes written out in different languages :)
2023-04-01 13:47:56 -0400 < mdhughes> You just invented a new esolang!
2023-04-01 13:48:06 -0400 < Zipheir> We still have opcodes in Scheme; they're called 'car' and 'cdr'.
2023-04-01 13:50:17 -0400 < retropikzel> What are they short for again?
2023-04-01 13:50:45 -0400 < amirouche> it seems to me there is a limited vocabulary, and getting those words translated in german, english, mandarin, and japanese is possible
2023-04-01 13:51:05 -0400 < amirouche> like getting (scheme base) internationalzed is not impossible
2023-04-01 13:51:10 -0400 < amirouche> but...
2023-04-01 13:51:15 -0400 < amirouche> many shy away from it
2023-04-01 13:51:23 -0400 < amirouche> it can help kids to learn programming
2023-04-01 13:52:16 -0400 < Zipheir> retropikzel: "Contents of the Address/Decrement part of Register" https://en.wikipedia.org/wiki/Lisp_(programming_language)#History
2023-04-01 13:52:47 -0400 < Zipheir> amirouche: Very good point. Kids shouldn't have to learn a new natural language to start programming.
2023-04-01 13:55:44 -0400 < Zipheir> But there are so many "educational" programming languages that the language issue isn't all that important. It would take an afternoon to write a BASIC interpreter for, say, Portuguese-speaking kids (assuming you knew Portuguese).
2023-04-01 13:55:53 -0400 < mdhughes> But without English they'll be cut off from the main programming examples; or if everyone uses their national language, everyone's cut off.
2023-04-01 13:56:25 -0400 < Zipheir> True.
2023-04-01 13:56:50 -0400 < johnjaye> Zipheir: yeah i was thinking the other day if chicken scheme could use a complex analysis library. and i thought that might fit better with a math framework like maxima.
2023-04-01 13:56:57 -0400 < Zipheir> English is the closest thing we've ever had to an international language.
2023-04-01 13:57:05 -0400 < mdhughes> You need to translate this to every lang: https://archive.org/details/basic-computer-games-microcomputer-edition_202207
2023-04-01 13:57:06 -0400 < johnjaye> but scheme could still have something like that, just trimmed down for 'educational' purposes
2023-04-01 13:57:40 -0400 < johnjaye> the key is to know your audience as in everything
2023-04-01 13:58:29 -0400 < Zipheir> mdhughes: Cool book. :) I suspect this was the inspiration for Land of Lisp.
2023-04-01 13:58:58 -0400 < tzar_bomba> hi, I document some scheme identifiers, and I want to make an integration test to check if I didn't make typos. I take my stuff, and then generate bunch of assertions from it. For example, `(test-assert (procedure? +))`. It's straightforward for procedures and plain values. But do you have some idea how can I assert for syntax? Something that would
2023-04-01 13:58:59 -0400 < tzar_bomba> succeed when calling `(assert &i/o)` but fail `(assert &i/oo)` (name with typo)
2023-04-01 13:59:08 -0400 < mdhughes> It definitely was, some of the LoL examples are direct copies/antonyms of the Creative Computing games.
2023-04-01 13:59:16 -0400 < johnjaye> oh yeah that reminds me land of lisp is that book i wanted to bu y
2023-04-01 13:59:32 -0400 < johnjaye> thanks Zipheir. always learn something cool by hanging around you
2023-04-01 13:59:47 -0400 < Zipheir> johnjaye: :) Thanks
2023-04-01 14:00:05 -0400 < Zipheir> Don't forget the LoL music video! https://www.youtube.com/watch?v=HM1Zb3xmvMc
2023-04-01 14:00:13 -0400 < johnjaye> i'm afraid i haven't been working anything that interesting lately in return though.
2023-04-01 14:00:16 -0400 < mdhughes> LoL's a lot of fun. I went thru it the first time and reimagined it all in Scheme, then more recently I've done most of it in actual CL, which is much more difficult.
2023-04-01 14:00:19 -0400 < johnjaye> unless you like the alacritty opengl terminal emulator
2023-04-01 14:00:42 -0400 < johnjaye> mdhughes: wouldn't it be easier if the examples are geared toward cl? or is that not the case
2023-04-01 14:00:55 -0400 < Zipheir> Grand Theft Wumpus with graphviz map graphics was a blast.
2023-04-01 14:01:26 -0400 < mdhughes> CL's a very hard language sometimes, and Barski chooses weird ways to do things even then, like using symbols as strings.
2023-04-01 14:02:16 -0400 < Zipheir> tzar_bomba: That's an interesting question.
2023-04-01 14:03:28 -0400 < Zipheir> tzar_bomba: My intuition is that this is meta-testing where you need to catch exceptions from the reader.
2023-04-01 14:04:05 -0400 < johnjaye> Zipheir: what's the deal with lalr in chicken and using bison? i didn't get that part
2023-04-01 14:04:40 -0400 < johnjaye> is the preference to not have to rely on bison or flex?
2023-04-01 14:05:02 -0400 < Zipheir> johnjaye: Oh, it doesn't use Bison. Like Bison, you have to call an external program to generate the parser.
2023-04-01 14:05:17 -0400 < Zipheir> Which is a pretty C-flavored thing.
2023-04-01 14:05:54 -0400 < retropikzel> Great now the LoL song is on a loop in my head :)
2023-04-01 14:06:10 -0400 < Zipheir> Hah.
2023-04-01 14:07:04 -0400 < mnieper> Excel/VBA have/had localized identifiers if I am not mistaken.
2023-04-01 14:09:38 -0400 < wasamasa> mdhughes: he did what
2023-04-01 14:09:42 -0400 < wasamasa> mdhughes: seriously?
2023-04-01 14:09:59 -0400 < wasamasa> mdhughes: I've heard complaints about this book and thought his style was just weird, but maybe he really doesn't know how to use CL
2023-04-01 14:10:42 -0400 < Zipheir> I don't think I'd recommend it as a way to learn Lisp, but it's definitely fun.
2023-04-01 14:10:48 -0400 < mdhughes> The text adventure uses lists of symbols, and then he has a parser that title-cases and punctuates sentences correctly.
2023-04-01 14:11:47 -0400 < mdhughes> You may not have been aware, Barski is either insane or does a fantastic job staying in character at all times.
2023-04-01 14:12:24 -0400 < Zipheir> It is a very 80s-style book, most obviously in that Barski repeats the silly old claim that Lisp can solve the Software Crisis.
2023-04-01 14:12:35 -0400 < johnjaye> what was the software crisis of the 80s?
2023-04-01 14:12:52 -0400 < johnjaye> sounds like something djikstra would have complained about
2023-04-01 14:12:53 -0400 < Zipheir> Like the software crisis of the 2020s, but not nearly as bad. :)
2023-04-01 14:13:09 -0400 < dpk> Zipheir: even then, there were too many people working on doomed AI projects
2023-04-01 14:13:45 -0400 < Zipheir> johnjaye: TOO MUCH COMPLEXITY
2023-04-01 14:14:26 -0400 < mdhughes> Or, NOT ENOUGH COMPLEXITY
2023-04-01 14:14:50 -0400 < Zipheir> How?
2023-04-01 14:15:09 -0400 < jcowan> I guess it would be redundant for me to resign as Chief Cook and Bottle Washer now
2023-04-01 14:15:09 -0400 < johnjaye> honestly software never came out of the crisis if that's the case. the hardware just got better to cover it up
2023-04-01 14:15:43 -0400 < Zipheir> johnjaye: Probably true.
2023-04-01 14:16:03 -0400 < dpk> (anyway, grumble, some people have hired the tiniest room available at my work for four hours, so i have to go and prepare it for them and let them in and stuff. i don't know that they'll survive four hours of claustrophobia in a room which is about 10 square metres, but fortunately cleaning up after them is someone else's job this time. also, this has no relevance to Scheme or the current conversation, i just wanted to rant about having to go
2023-04-01 14:16:03 -0400 < dpk> to work)
2023-04-01 14:16:16 -0400 < Zipheir> https://xkcd.com/2021/ was hardly satire
2023-04-01 14:16:36 -0400 < Zipheir> dpk: Sorry to hear it.
2023-04-01 14:17:01 -0400 < johnjaye> haha that is very true. the thought process in software does sometimes border on the absurd
2023-04-01 14:17:53 -0400 < johnjaye> > Update: It turns out the cannon has a motorized base, and can make holes just fine using the barrel itself as a battering ram. But due to design constraints it won't work without a projectile loaded in, so we still need those drills.
2023-04-01 14:19:00 -0400 < dpk> five euros says the person who was supposed to clean up last time didn’t do that properly so i’ll have to do that asap too
2023-04-01 14:21:38 -0400 < mdhughes> And that's how OpenDoc was created.
2023-04-01 15:54:16 -0400 < ecraven> hm.. where would I find mnieper's lr(1) parser generator?
2023-04-01 15:54:36 -0400 < ecraven> Zipheir: thanks, I'll look at that!
2023-04-01 16:09:29 -0400 < tomhg> ecraven: I think this is the repo: https://github.com/mnieper/scheme-macros
2023-04-01 16:16:47 -0400 < mnieper> Indeed.
2023-04-01 16:17:30 -0400 < mnieper> It is the bare minimum, but should be a good basis for adding bells and whistles.
2023-04-01 19:18:06 -0400 < tomhg> My scope slowly drifted: I realize that some sort of evaluator may be required to navigate scheme code. Though in my mind I still archive my language-agnostic goal; With more complexity though. Anyhow, exciting times.
2023-04-01 20:26:01 -0400 < whereiseveryone> For anyone interested, Sunday Demo: Live Loading Common Lisp Systems with Guix https://mail.gnu.org/archive/html/guix-devel/2023-03/msg00363.html
2023-04-01 20:40:44 -0400 < sandra> There is Chinese language programming languages including a version of Python
--- Day changed Sun Apr 02 2023
2023-04-02 02:23:39 -0400 -!- devmsv_ is now known as devmsv
2023-04-02 03:43:36 -0400 < cow_2001> runtime error
2023-04-02 03:43:43 -0400 < cow_2001> what SHALL i doooo?
2023-04-02 05:34:41 -0400 < rgherdt> amirouche: did you consider publishing your srfi-180 to snow? I'm thinking about porting my json-rpc and lsp code to snow, but need a portable json library for that. I could help with preparing a snow package for srfi-180
2023-04-02 05:36:17 -0400 < amirouche> good question, I will try something, and let you know tonight, or tomorrow morning
2023-04-02 05:37:26 -0400 < rgherdt> ok, thanks a lot
2023-04-02 06:50:34 -0400 < ecraven> tomhg: thangs
2023-04-02 07:07:20 -0400 < tomhg> rgherdt:
2023-04-02 07:07:52 -0400 < tomhg> https://gitlab.com/thchha/r5rs-json-library
2023-04-02 07:20:14 -0400 < rgherdt> tomhg: thanks, didn't know that one. But my code already relies on srfi-180's API, so I prefer to stick to it
2023-04-02 07:23:36 -0400 < tomhg> always forgetting about this one :o)
2023-04-02 09:30:12 -0400 < cow_2001> where's const defined? you know (define (const x) (lambda y x))
2023-04-02 09:31:02 -0400 < dpk> the recent combinators SRFI, i think
2023-04-02 09:31:42 -0400 < dpk> SRFI 235 under the name constantly
2023-04-02 09:32:55 -0400 < cow_2001> ah! thank you dpk!
2023-04-02 12:23:03 -0400 < cow_2001> i am reading mastering emacs 2022 because i am stuck in the 1980s and want to be put on display in a museum so i can go out of my display cabinet at night steal priceless artefacts and pieces of art
2023-04-02 13:45:23 -0400  * amirouche working on new scheme united release
2023-04-02 13:47:18 -0400 < amirouche> Based on /r/scheme feedback, the tag line is not obvious: How to write portable Scheme libraries, and programs
2023-04-02 13:47:37 -0400 < amirouche> maybe the author meant to say in a way that is diplomatic: that is useless
2023-04-02 13:47:39 -0400 < amirouche> ?
2023-04-02 13:48:22 -0400 < wasamasa> you don't make friends with salad^Wportable code
2023-04-02 13:48:58 -0400  * wasamasa checks subreddit
2023-04-02 13:49:44 -0400 < amirouche> Reminds me a quote: happy, or right, choose one.
2023-04-02 13:50:25 -0400 < amirouche> that could be summarized with: happy xor right.
2023-04-02 13:54:30 -0400 < wasamasa> couldn't find your announcement
2023-04-02 13:58:12 -0400 < Zipheir> Of course you can make friends (metaphorically speaking) with portable code. People like not having to roll their own.
2023-04-02 13:59:30 -0400 < wasamasa> yes, for example by using other people's unportable code
2023-04-02 14:02:06 -0400 < amirouche> why metaphorically?
2023-04-02 14:02:25 -0400 < Zipheir> Making friends literally is complicated.
2023-04-02 14:03:40 -0400 < wasamasa> also, it's a meme
2023-04-02 14:05:15 -0400 < wasamasa> you can look up the bits preceding the ^W and get a Simpsons clip
2023-04-02 14:06:30 -0400 < amirouche> that reminds me of the comic about a person from future traveling back in time, arguing with people to stop using fossil fuel, and everybody was shouting back: geeeeeeek!
2023-04-02 14:07:33 -0400 < wasamasa> I remember having a discussion in here how nearly all submitted SRFIs are irrelevant to the development I do with scheme
2023-04-02 14:07:44 -0400 < wasamasa> and people were quick to respond they found some SRFIs useful
2023-04-02 14:07:59 -0400 < amirouche> or the big bang theory episode, where two persons get a nobel prize after a series of mistakes, then they related to mistakes to a paper, and bang!
2023-04-02 14:08:15 -0400 < wasamasa> maybe the statement that the scheme united tagline is a diplomatic way of saying that it's useless is a similar sentiment
2023-04-02 14:08:43 -0400 < wasamasa> "I want to perform HTTP requests and dissect YAML, damnit"
2023-04-02 14:08:48 -0400 < amirouche> the paper's authors that did all the hard work were forgotten in misery.
2023-04-02 14:09:57 -0400 < amirouche> all my srfi are not perfect, but saying they are usefulness is just spreading Fear, Uncertainity, and Doubt, and arming Scheme, and software in general
2023-04-02 14:10:10 -0400 < amirouche> s/usefulness/useless/
2023-04-02 14:10:12 -0400 < Zipheir> wasamasa: So when people say that they find something useful what you get is "it's useless"? That's a rather cynical perspective.
2023-04-02 14:10:44 -0400 < wasamasa> no, what I hear is that they cannot hear what I say
2023-04-02 14:11:41 -0400 < wasamasa> and that makes me wonder what they're using scheme for
2023-04-02 14:11:49 -0400 < wasamasa> to take delight in designing SRFIs?
2023-04-02 14:12:06 -0400 < amirouche> pushing forward the final frontier?
2023-04-02 14:12:13 -0400 < wasamasa> that's an anime quote, right
2023-04-02 14:12:14 -0400 < Zipheir> Ah. Are you the only serious person using Scheme?
2023-04-02 14:12:28 -0400 < wasamasa> I'm sure there are more people like me, for example on #emacs
2023-04-02 14:13:13 -0400 < amirouche> are you refering to vox pop?
2023-04-02 14:13:18 -0400 < wasamasa> I've had a lengthy discussion there some days ago and someone said that in terms of language standardization processes, scheme had the most dysfunctional one
2023-04-02 14:13:25 -0400 < wasamasa> no, I'm referring to people outside of #scheme
2023-04-02 14:13:38 -0400 < Zipheir> That's a different issue.
2023-04-02 14:13:55 -0400 < Zipheir> But I hope you realize that people program for different reasons.
2023-04-02 14:14:15 -0400 < wasamasa> yeah and I wonder whether some people truly take delight in language standardization
2023-04-02 14:14:31 -0400 < wasamasa> after all, Norvig said you should have the decency to hop off such an effort as quickly as possible
2023-04-02 14:14:33 -0400 < Zipheir> And which reasons are "serious" is not a programming question.
2023-04-02 14:14:42 -0400 < wasamasa> no, it's a social one
2023-04-02 14:15:07 -0400 < wasamasa> also, didn't you mention that word first, "serious"?
2023-04-02 14:15:13 -0400 < amirouche> you mean having convos that actually try to improve the state of things, instead of merely calling out?
2023-04-02 14:15:31 -0400 < Zipheir> Yes, I did. I didn't mean to set up a strawman.
2023-04-02 14:15:35 -0400 < wasamasa> ok
2023-04-02 14:16:35 -0400 < wasamasa> amirouche: my goal was trying to explain why someone would post that on reddit (I still didn't find it on reddit)
2023-04-02 14:18:59 -0400 < amirouche> Other people have so many reason to dislike Scheme, first and formost because it is very hard to make living with it; why would someone support a zero profit entreprise?
2023-04-02 14:19:07 -0400 < amirouche> Like someone wise once said: "Those who know, keep it for themselfs; those who do not know, think they can do better";
2023-04-02 14:19:27 -0400 < wasamasa> zero profit enterprise?
2023-04-02 14:19:33 -0400 < amirouche> Second because LISP, and Scheme in particular got so many things right for a long time, that today, other stacks are copying it e.g. gcc, and llvm JIT; Java tail calls...
2023-04-02 14:20:13 -0400 < amirouche> giving credits to LISP, or Scheme is admiting they got it wrong in some places, and admiting some way Scheme is better
2023-04-02 14:21:19 -0400 < amirouche> and that even happens inside Scheme community
2023-04-02 14:21:40 -0400 < amirouche> it is a practice that aims to increase the chance of survival of individuals, instead of the whole.
2023-04-02 14:22:07 -0400 < Zipheir> amirouche: I know you don't believe that. Of course some people will support non-profit enterprises.
2023-04-02 14:22:15 -0400 < wasamasa> I don't feel like having the lisp resting on its laurels discussion again, but zero profit enterprise seems like a paradoxical thing
2023-04-02 14:22:27 -0400 < wasamasa> zero profit business maybe
2023-04-02 14:22:37 -0400 < wasamasa> but an enterprise is a risky undertaking
2023-04-02 14:22:45 -0400 < wasamasa> profit is what makes the risk worthwhile
2023-04-02 14:23:48 -0400 < amirouche> profit that is money is the tree hiding the forest.
2023-04-02 14:26:30 -0400 < amirouche> eventually, it is not only a problem of technology, or software. It is also a problem of people, which brings back the 'survival of individuals', and politics.
2023-04-02 14:29:38 -0400 < amirouche> Another example of things that LISP people got right is the LISP machine, whole stack LISP, when other stacks people are calling this out as absence of diversity or elitism.
2023-04-02 14:50:58 -0400 < tomhg> So I started with Scheme about three years ago on my own with R5RS. Though I learned that I used some functionality from R6RS. And learned that R7RS-small actually is very practical. The only thing missing to pull in SRFI's is a way to install them via my distro's package manager. But for this there may not be an SRFI yet :)
2023-04-02 14:51:28 -0400 < wasamasa> lol
2023-04-02 14:51:45 -0400 < wasamasa> I remember one SRFI about standardizing the existence of a particular CLI flag
2023-04-02 14:52:03 -0400 < tomhg> and?
2023-04-02 14:52:15 -0400 < wasamasa> I'll have to look it up before continuing to speak
2023-04-02 14:52:21 -0400 < tomhg> hehe, check
2023-04-02 14:52:30 -0400 < wasamasa> ah yes: https://srfi.schemers.org/srfi-176/srfi-176.html
2023-04-02 14:52:41 -0400 < wasamasa> I love how they sneaked in LOSE
2023-04-02 14:53:36 -0400 < tomhg> okay, on first glance I have to admit that SRFI appears to be .. premature?
2023-04-02 14:54:07 -0400 < wasamasa> possibly, it's too complicated for me to tell
2023-04-02 14:54:41 -0400 < wasamasa> but my point is, it's about a seemingly trivial topic, yet ended up gargantuan
2023-04-02 14:54:47 -0400 < wasamasa> reviewing it seems difficult
2023-04-02 14:55:02 -0400 < wasamasa> so, a SRFI for installing extensions, I do not see that happen
2023-04-02 14:55:17 -0400 < wasamasa> also, isn't that bit out of scope anyway?
2023-04-02 14:55:26 -0400 < tomhg> Well, at least this would be useful for any package manager. I see why you referring to it now.
2023-04-02 14:55:48 -0400 < wasamasa> I'm not sure whether it's the thing I meant to look at
2023-04-02 14:56:04 -0400 < tomhg> wasamasa: It would come with a standard to layout my modules I suppose.
2023-04-02 14:56:19 -0400 < wasamasa> yeah and that's something implementations heavily disagree about
2023-04-02 14:56:30 -0400 < wasamasa> even something like adding .sld as a de-facto file extensions
2023-04-02 14:57:33 -0400 < wasamasa> maybe this: https://srfi.schemers.org/srfi-138/srfi-138.html
2023-04-02 14:57:51 -0400 < tomhg> the extension may be  meaningless in this regards
2023-04-02 14:58:26 -0400 < wasamasa> uh, looking at this one
2023-04-02 14:58:32 -0400 < wasamasa> I think I've found another inconsistency
2023-04-02 14:58:42 -0400 < wasamasa> but I currently do not have the brain cells to tell whether it is one
2023-04-02 14:59:06 -0400 < wasamasa> > The resulting executable file shall be written to the file specified by the -o option (if present) or to the file file if pathname is of the form file.scm. (Implementations on Windows would choose file.exe instead of file.)
2023-04-02 14:59:08 -0400 < wasamasa> > Use the pathname outfile, instead of the default a.out, for the executable file produced.
2023-04-02 14:59:14 -0400 < wasamasa> so is it a.out or file
2023-04-02 15:01:22 -0400 < tomhg> I see. This should only give the flags and I could select my srfi-conformant implementation to compile, yeah.
2023-04-02 15:01:42 -0400 < tomhg> But at least a implementation has some place to refer to the idea!
2023-04-02 15:01:42 -0400 < wasamasa> yeah, so there is precedent in a SRFI specifying to do OS-specific things
2023-04-02 15:01:49 -0400 < wasamasa> like providing a command to do a well-defined task
2023-04-02 15:01:59 -0400 < wasamasa> I imagine a command to install a SRFI is a less well-defined task
2023-04-02 15:02:21 -0400 < tomhg> It feels that this SRFI is trying to introduce consistency for makefiles
2023-04-02 15:02:50 -0400 < wasamasa> yes
2023-04-02 15:04:03 -0400 < tomhg> well, actually I would put it simple. Like there are three directories to look for an directory "name" describing module "name": LD_LIBRARY_PATH/name > LD_USER_LIBRARY_PATH/name (or some) > /home/user/.scheme/modules/name
2023-04-02 15:04:45 -0400 < tomhg> so at install any implementation can read these out or create them *shrugs*.
2023-04-02 15:05:09 -0400 < wasamasa> bold of you to assume windows support is optional
2023-04-02 15:05:17 -0400 < tomhg> The implementations wouldn't need to do any implementation at first; But there would be a convention. But I am sure R7RS has some thoughts about it.
2023-04-02 15:05:43 -0400 < tomhg> wasamasa: There is APP_DATA on windows..
2023-04-02 15:05:50 -0400 < wasamasa> ok, so it's not as simple
2023-04-02 15:06:30 -0400 < tomhg> I think it should be.
2023-04-02 15:06:43 -0400 < tomhg> but then who am I :o)
2023-04-02 15:07:52 -0400 < tomhg> But since I can make an SRFI, I will give priority to a flag called `--toxic` which shall be used if the module system connects to the internet when building a program!!
2023-04-02 15:14:12 -0400 < wasamasa> uh, ok
2023-04-02 15:31:02 -0400 < acdw> gwatt: fhqwhgads
2023-04-02 15:31:08 -0400 < acdw> -lang
2023-04-02 16:36:45 -0400 < jcowan> wasamasa: I do enjoy working on standardization, and if I didn't have to make a living, I'd be able to work on it more intensively.
2023-04-02 16:37:31 -0400 < jcowan> My "profit" if you want to call it that is the satisfaction of seeing it all come together, and then of it being adopted by implementers and users
2023-04-02 16:39:31 -0400 < wasamasa> hm
2023-04-02 16:39:35 -0400 < wasamasa> yeah, I'd not call it profit
2023-04-02 16:39:48 -0400 < wasamasa> rather a reward
2023-04-02 16:40:07 -0400 < wasamasa> source of fuzzy feelings
2023-04-02 16:48:08 -0400 < jcowan> once you get past bare survival, that's all there is to profit, really
2023-04-02 16:52:31 -0400 < wasamasa> I dunno, I'm used to profit being about business things
2023-04-02 16:52:38 -0400 < wasamasa> like money
2023-04-02 16:52:50 -0400 < wasamasa> but social credit also kind of qualifies
2023-04-02 16:56:40 -0400 < jcowan> Well, people work to make money, and then they spend some of it on food, shelter, etc.  But whatever is surplus to that, they spend on things that they enjoy.
2023-04-02 16:57:21 -0400 < jcowan> and then you are in the realm of "fuzzy feelings"
2023-04-02 17:00:08 -0400 < wasamasa> yeah
2023-04-02 17:15:07 -0400 < Zipheir> As has been said many times, you can't buy fuzzy feelings.
2023-04-02 17:15:28 -0400 < Zipheir> Although some things you can buy will make you feel fuzzy.
2023-04-02 17:39:05 -0400 < jcowan> "Money won't make you happy, but then again, happy won't make you money."  --Groucho
2023-04-02 17:44:38 -0400 < Zipheir> I suppose a comedian can be said to make money from happy.
2023-04-02 17:45:15 -0400  * Zipheir frowns at the nouned adjective.
2023-04-02 17:47:15 -0400 < daviid> poverty definitely makes people (very) sad though (up to suicide) ... there is a certain hypocrisy in 'shouting loud and clear' that money won't make you happy, generally those who claim that far over past strict survival needs - they just don't even know what having no money is, less what and how to survive ...
2023-04-02 17:48:40 -0400 < Zipheir> There are several different claims there.
2023-04-02 17:49:39 -0400 < Zipheir> A billionaire who admits he isn't happy isn't saying "let them eat cake".
2023-04-02 17:52:29 -0400  * daviid don't want and won't engage in a conversation, just wanted to remind that claiming 'money won't make you happy' is ...
2023-04-02 17:54:13 -0400 < Zipheir> Trite.
2023-04-02 17:56:11 -0400 < Zipheir> But again, it's not saying the same thing as "you can [and should!] be happy in poverty".
2023-04-02 17:59:29 -0400 < Zipheir> Anyway.
2023-04-02 18:00:55 -0400 < Zipheir> tomhg: You might take a look at Lassi's srfi tool: https://github.com/scheme-requests-for-implementation/srfi-common/tree/master/srfi-tools  I don't know if it will ever do what you're looking for, but it exists.
2023-04-02 18:24:52 -0400 < tomhg> Thanks! What's up with these double-tilde-things? I spotted it only one time prior and that referred to gambits runtime-directory from the installation-dir; not the cloned repo.
2023-04-02 18:53:44 -0400 < jcowan> Zipheir: I've added oset-accumulate to the SRFI 153 spec
2023-04-02 19:28:45 -0400 < Zipheir> jcowan: Great. Thanks.
2023-04-02 20:53:50 -0400 -!- AndrewYu is now known as Andrew
2023-04-02 21:19:47 -0400 -!- greaser|q is now known as GreaseMonkey
--- Day changed Mon Apr 03 2023
2023-04-03 08:33:41 -0400 < cow_2001> how come in scheme it's map and lisp it's mapcar?
2023-04-03 08:34:26 -0400 < lloda> bc scheme came later and was able to smooth those rough spots
2023-04-03 08:35:02 -0400 < cow_2001> originally a map just went over the pairs and not the cars
2023-04-03 08:35:08 -0400 < cow_2001> but why?
2023-04-03 08:35:54 -0400 < cow_2001> maybe it's for context? but then you know only what comes next, not what comes before
2023-04-03 08:36:20 -0400 < cow_2001> (maybe you could file these questions under shower thoughts)
2023-04-03 08:37:12 -0400 < cow_2001> and it's getting warmer and i really need to adjust my wardrobe or else i'd need more showers and consequently, will have more shower thoughts to pointlessly ask here about lisp
2023-04-03 09:16:21 -0400 < lockywolf> schemers discussing making money today
2023-04-03 09:17:13 -0400 < lockywolf> we need to write a bot which would be making money and funding Scheme development
2023-04-03 09:18:16 -0400 < cow_2001> oh no! elisp doesn't have tail recursion optimisations! D:<
2023-04-03 09:19:01 -0400 < cow_2001> lockywolf: a bot that would write code to replace all programmers? already made
2023-04-03 09:19:17 -0400 < lockywolf> cow_2001: but not in Scheme
2023-04-03 09:19:28 -0400 < cow_2001> it can bootstrap itself
2023-04-03 09:19:34 -0400 < cow_2001> probably
2023-04-03 09:19:35 -0400 < cow_2001> maybe
2023-04-03 09:20:41 -0400 < lockywolf> probably not
2023-04-03 12:06:40 -0400 < Zipheir> Does anyone have an idea about why this implementation makes chibi complain about () not being a pair? https://github.com/Zipheir/srfi-153/blob/master/srfi/153-impl.scm#L28
2023-04-03 12:08:51 -0400 < Zipheir> Never mind, I found it. It's the call to mapping-adjoin, which should get a pair of elements to adjoin.
2023-04-03 13:29:23 -0400 -!- mdhughes_ is now known as mdhughes
2023-04-03 14:16:36 -0400 < amirouche> rgherdt: I am too busy, I will not have time to do it myself.
2023-04-03 14:46:53 -0400 < rgherdt> amirouche: no problem, thanks for the feedback. I can give it a try later the week
2023-04-03 15:29:32 -0400 < tomhg> jcowan: So I just spotted that you created SRFI-153.. When are osets appropriate to use? After I have already constructed the collection; They are ordered and made immutable, correct?
2023-04-03 15:33:59 -0400 < jcowan> tomhg: The simplest approach is to construct a list and then to use list->oset.
2023-04-03 15:34:30 -0400 < jcowan> (or list->oset/ordered if the elements of the list are already ordered)
2023-04-03 15:39:42 -0400 < tomhg> I see. I am comparing the API between sets/bags and osets now. There may lie a little inconsistency in procedure naming.
2023-04-03 15:51:06 -0400 < Zipheir> tomhg: You use them when you want to find an element in logarithmic or better time.
2023-04-03 15:52:02 -0400 < tomhg> jcowan: Nvm. I suspected the exclamation point missing from oset. Though now I'm wondering why they need to be immutable in the first place.
2023-04-03 15:52:36 -0400 < tomhg> Zipheir: Thanks, I didn't know and understand the implications.
2023-04-03 15:52:51 -0400 < jcowan> We have unordered mutable sets in SRFI 113
2023-04-03 15:53:04 -0400  * tomhg didn't know and didn't understand - Would I have to negate both verbs here?
2023-04-03 15:53:26 -0400 < tomhg> So why not have ordered mutable sets which reorder itself?
2023-04-03 15:53:26 -0400 < jcowan> Eventually Committee C will clean up any inconsistencies
2023-04-03 15:55:01 -0400 < Zipheir> tomhg: "didn't know and didn't understand" makes sense to me. "didn't know and understand" is ambiguous, for fans of De Morgan, at least.
2023-04-03 15:55:14 -0400 < jcowan> You can efficiently add new elements to an oset and then you get back a new oset
2023-04-03 15:55:30 -0400 < jcowan> which may share internal structure with the original oset
2023-04-03 15:55:38 -0400 < tomhg> *nods*
2023-04-03 15:55:57 -0400 < Zipheir> Whereas ordered-list insert is O(n) in time.
2023-04-03 15:57:06 -0400 < tomhg> jcowan: Then the rationale could point the reuse out. I thought it was simply recreated. But it may be optimal efficiency (I just assume :o) )
2023-04-03 15:58:32 -0400 < Zipheir> Every immutable structure is expected to share. It's the best reason for immutability.
2023-04-03 15:59:05 -0400 < tomhg> Ignore me. I should read first. I am writing while reading; Which is obv. bad. Though as a first reader, this _may_ be experience as of future readers.
2023-04-03 15:59:36 -0400 < Zipheir> (We only used the word "immutable" once in SRFI 224.)
2023-04-03 15:59:39 -0400 < tomhg> See. That was completely hidden to me. I won't ping again.
2023-04-03 15:59:52 -0400 < Zipheir> tomhg: Please don't worry about it.
2023-04-03 15:59:57 -0400 < jcowan> It's pretty much like lists: you can mutate a list, but it's more typical to grow it by prepending elements
2023-04-03 15:59:59 -0400 < jcowan> with cons
2023-04-03 16:00:48 -0400 < tomhg> Thanks #scheme.
2023-04-03 16:01:25 -0400 < acdw> you're welcome!
2023-04-03 16:01:41 -0400 < Zipheir> The only use of list mutation I've seen in practical Scheme is reverse!, and I'm not sure that's worth it.
2023-04-03 16:02:02 -0400 < tomhg> acdw: :o) you just prooved that there is proof-reading going on.
2023-04-03 16:02:19 -0400 < acdw> hmmmm yes
2023-04-03 16:03:00 -0400 < tomhg> Zipheir: like switching elements by mutation in place?
2023-04-03 16:03:23 -0400 < Zipheir> tomhg: Yes.
2023-04-03 16:04:20 -0400 < Zipheir> tomhg: But folklore says that reverse! is not good for the garbage collector.
2023-04-03 16:04:36 -0400 < tomhg> Never thought of this.. Should prob. be the more performant solution instead of allocating a new list..
2023-04-03 16:04:40 -0400 < acdw> i miss the days when we knew the cost of nothing
2023-04-03 16:04:55 -0400 < Zipheir> acdw: I appreciate the allusion. :)
2023-04-03 16:05:17 -0400 < acdw> :)
2023-04-03 16:06:48 -0400 < Zipheir> tomhg: Except for the effects on the GC, possibly.
2023-04-03 16:13:19 -0400 < tomhg> To my current knowledge thats resolves simply in an undocumented implementation optimization.
2023-04-03 16:15:58 -0400 < Zipheir> I'd still use 'reverse'.
2023-04-03 16:17:22 -0400 < tomhg> yeah, that should be hidden.
2023-04-03 16:20:58 -0400 < Zipheir> Usually, reverse is used on an intermediate list which was accumulated in reverse order. In that case, generational GCing should make that intermediate list almost invisible to memory use. If, OTOH, you have a huge, non-intermediate list, using reverse! on it to save space has a side effect: you'd better not have any live sublist references.
2023-04-03 16:22:29 -0400 < Zipheir> Anyway, this is what I've put together from what more experienced folks have said.
2023-04-03 16:27:28 -0400 < tomhg> Didn't thought about the live references. Also, I googled cost-of-nothing and I would like it to have it in my scheme toolbok very much.
2023-04-03 16:27:50 -0400 < tomhg> /s/bo(o)k/box
2023-04-03 16:41:42 -0400 < Zipheir> tomhg: It's from Alan Perlis's "Epigrams in Programming" (https://www.cs.yale.edu/homes/perlis-alan/quotes.html)  "A LISP programmer knows the value of everything, but the cost of nothing." (no. 55)
2023-04-03 16:41:49 -0400 < tomhg> In the same thought I want to leave here: My program started immediately prior to refactoring. I added some smaller macros (one one automaton; It's loaded but never used) and it my start-up time increased to about one second. Afterward loading there are no performance issues. Just sharing... *leaves*
2023-04-03 16:42:10 -0400  * tomhg *bows*
2023-04-03 16:43:00 -0400 < tomhg> Zipheir: I googled and even walked the time-machine. Thought it was about this: https://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html
2023-04-03 16:48:05 -0400 < tomhg> ; increase in time was only tested via invocation via interpreter. So this shall not be an issue; Sorry..
2023-04-03 16:52:57 -0400 < Zipheir> "The program SHOULD NOT have any bugs."
2023-04-03 16:55:59 -0400 < tomhg> The use case of using the interpreter SHALL NOT be concerned with performance. For this I got shipped a compiler.
2023-04-03 19:15:31 -0400 < webshinra> algorithmic complexity is important even with interpreter
2023-04-03 19:18:13 -0400 < jcowan> tomhg, Zipheir: Another application of list mutation is sorting a list in a way that reuses the conses of the list.  SRFIs 132 and 32 provide this.
2023-04-03 19:20:06 -0400 < jcowan> list-sort! and list-stable-sort!
2023-04-03 22:26:21 -0400 < mdhughes> Building trees from cons cells is a good use for set-car!/cdr! - but eventually it'll be fragmented and you'll have a lot of cache misses, so it might be better to use a vector of "cells" and integers instead of pointers.
2023-04-03 22:27:48 -0400 < mdhughes> And I have some simple databases where I set-cdr! to assign values; the keys don't change, it's allocated in place.
--- Day changed Tue Apr 04 2023
2023-04-04 00:02:20 -0400 < Zipheir> mdhughes: Let me introduce you to a new idea: record types.
2023-04-04 00:02:54 -0400 < Zipheir> You can have exactly as much mutability as you need.
2023-04-04 00:04:10 -0400 < mdhughes> Which use a lot more memory.
2023-04-04 00:06:47 -0400 < Zipheir> I suppose it's possible that they will, but a record is traditionally just a tagged vector.
2023-04-04 00:09:18 -0400 < mdhughes> Which is a minimum of 3 words (pointer to memory, type, length) extra over a cons cell (2 pointers).
2023-04-04 00:09:56 -0400 < Zipheir> If you need the bare minimum, go for it.
2023-04-04 00:10:01 -0400 < mdhughes> Which, sure, we have gigs of RAM now. I still make big structures sometimes and have to care about not doubling memory size.
2023-04-04 01:14:38 -0400 < mnieper> The next Scheme dialect should have a proper list data type that is immutable and where it can be tested in O(1) whether it is a proper list or not.
2023-04-04 01:14:45 -0400 < mnieper> Argument lists should be of this type.
2023-04-04 01:14:58 -0400 < mdhughes> Technically values already is!
2023-04-04 01:15:21 -0400 < mnieper> ? values is a procedure.
2023-04-04 01:19:49 -0400 < mnieper> A half-R6RS/half-Racket approach seems the best to eventually end up with proper lists in Scheme (note that all list procedures currently have to pay for that someone might mutate pairs or produce infinite lists).
2023-04-04 01:20:28 -0400 < mnieper> By that I mean to deprecate set-car!/set-cdr! as in R6RS, but to offer mpairs as well for use cases like mdhughes'.
2023-04-04 01:21:00 -0400 < mnieper> An mpair is philosophically spoken just a cheap record with two mutable fields.
2023-04-04 01:22:35 -0400 < mnieper> bbl
2023-04-04 01:22:39 -0400 < mdhughes> values is a closure over a list of arguments, really - what type is that argument list? It's probably an internal, immutable list type.
2023-04-04 01:23:39 -0400 < sham1> But you can mutate the argument list
2023-04-04 01:23:40 -0400 < mdhughes> My thought is to pull that out and make it user-facing. For most of the things you use immutable lists for, that's all you need, rather than a real chain of cons cells.
2023-04-04 01:24:33 -0400 < mdhughes> Like Python's tuple, before they extended it into a dictionary, struct, etc.
2023-04-04 01:57:26 -0400 < mnieper> Scheme has to convert whatever internal representation it uses for argument lists into the user-facing list data type, which can be mutated, and which makes working with rest arguments less efficient than it needs to be.
2023-04-04 01:59:23 -0400 < mnieper> mdhughes: To maintain as much compatibility as possible, my idea is to eventually remove mutation of the existing cons cells so that argument lists can stay argument lists as they currently are.
2023-04-04 02:00:00 -0400 < mnieper> And to offer something to users that need space-efficient mutable pairs.
2023-04-04 02:11:08 -0400 < jcowan> mdhughes: Most implementations of pairs have car, cdr, and type fields, and most implementations of records do not have a length field, so in fact there is no memory cost for records over pairs.
2023-04-04 02:11:38 -0400 < jcowan> (There are some systems where pairness is represented by a bit in the pointer to the pair instead.)
2023-04-04 02:13:38 -0400 < mdhughes> I would expect (and have read, but not looked at Chez etc's impls) they'd just use tagged pointers, and so 2 words as a value for a cons cell.
2023-04-04 02:13:50 -0400 < mnieper> NB: This is quite informative: https://www.gnu.org/software/guile/manual/html_node/Cheaper-Pairs.html
2023-04-04 02:15:26 -0400 < mdhughes> So even guilers can catch a worm once in a while.
2023-04-04 02:20:08 -0400 < mnieper> BTW, here are Chez's tags: https://github.com/cisco/ChezScheme/blob/main/s/cmacros.ss#L698
2023-04-04 02:29:26 -0400 < jcowan> Guile doesn't actually use pair tags, though, because they are incompatible with the BDW gc.
2023-04-04 02:34:38 -0400 < jcowan> oh no, I'm wrong; I don't know how they make that work with BDW, though
2023-04-04 02:37:57 -0400 < mnieper> Adding a small tag value still lets the (modified) pointer point into the C heap.
2023-04-04 02:38:06 -0400 < mnieper> Isn't BDW using this information?
2023-04-04 02:41:17 -0400 < sjamaan> I thought Guile has a new GC now - I remember wingo posting about garbage collectors on his blog
2023-04-04 02:44:55 -0400 < jcowan> I read about that yes, but I don't think it's in the mainline yet.
2023-04-04 02:45:26 -0400 < jcowan> And yes, BDW now supports arbitrary interior pointers
2023-04-04 02:45:37 -0400 < jcowan> s/yes/too
2023-04-04 02:45:44 -0400 < jcowan> Gambit has pair tags, but Chicken does not
2023-04-04 02:49:22 -0400 < sjamaan> In the latest version of CHICKEN, we eliminate argument to rest list conversion when it can be determined that only certain procedures are called
2023-04-04 02:50:02 -0400 < sjamaan> Currently that's length, cdd...ar and null?, IIRC
2023-04-04 03:03:14 -0400 < mnieper> sjamaan: How do you deal with (apply f x*)?
2023-04-04 03:05:04 -0400 < jcowan> Unfortunately, internal tag formats are underdocumented in most Schemes
2023-04-04 03:10:46 -0400 < sjamaan> mnieper: AFAIK it always gets converted from a list to an "argvector"
2023-04-04 03:11:36 -0400 < sjamaan> (and possibly back into a list inside the procedure)
2023-04-04 03:12:03 -0400 < mnieper> With "true lists" we can make apply and rest arguments much more efficient.
2023-04-04 03:13:02 -0400 < sjamaan> At the cost of quite some additional complexity to the language
2023-04-04 03:14:04 -0400 < sjamaan> Scheme was never about putting efficiency of implementation first
2023-04-04 03:14:38 -0400 < mnieper> We pay a high price for set-car!/set-cdr! and for the existence of improper or circular lists.
2023-04-04 03:14:58 -0400 < mnieper> The language would become simpler.
2023-04-04 03:14:59 -0400 < mnieper> A lot
2023-04-04 03:15:00 -0400 < mnieper> .
2023-04-04 03:16:09 -0400 < sjamaan> It would be quite a different language though
2023-04-04 03:16:20 -0400 < mnieper> I don't think so.
2023-04-04 03:17:25 -0400 < mnieper> It would if we changed the mechanism for rest arguments.
2023-04-04 03:18:31 -0400 < sjamaan> You'd break any code that relies on cyclic lists, for one
2023-04-04 03:18:43 -0400 < sjamaan> And to fix that you could introduce a new type, making the language more complex again
2023-04-04 03:19:00 -0400 < mnieper> We already have types for this, they are called records.
2023-04-04 03:22:05 -0400 < mnieper> The standard libraries would just export one predefined, nongenerative, opaque, sealed record type named mpair, which may be implemented more efficiently than through (define-record-type (mpair mcons mpair?) (nongenerative) (sealed #t) (opaque #t) (fields (mutable car mcar set-mcar!) (mutable cdr mcdr set-mcdr!))).
2023-04-04 03:22:48 -0400 < sjamaan> Please don't
2023-04-04 03:22:57 -0400 < mnieper> Why?
2023-04-04 03:22:58 -0400 < sjamaan> That's one of the worst design decisions
2023-04-04 03:23:05 -0400 < mnieper> Why?
2023-04-04 03:23:11 -0400 < sjamaan> Now you have two distinct, incompatible types of pair
2023-04-04 03:23:21 -0400 < sjamaan> Talk about complexity!
2023-04-04 03:23:44 -0400 < mnieper> You already have thousands of incompatible types of pairs.
2023-04-04 03:23:50 -0400 < mnieper> (-> records)
2023-04-04 03:24:14 -0400 < mnieper> (Which is actually good because it gives you type safety.)
2023-04-04 03:24:15 -0400 < sjamaan> That's disingenuous
2023-04-04 03:24:56 -0400 < sjamaan> The idea of a "pair" implies it works with the standard map, for-each etc
2023-04-04 03:25:15 -0400 < mnieper> If I want to implement a mutable binary tree, the inner nodes are better modelled as dedicated records of two fields than as pairs.
2023-04-04 03:25:18 -0400 < sjamaan> And it would confuse beginners too - why are there two kinds of pairs?  Why can't I take the car or both?
2023-04-04 03:25:35 -0400 < mnieper> sjamaan: Beginnners shouldn't look at mpairs at all.
2023-04-04 03:25:58 -0400 < sjamaan> They would still notice them
2023-04-04 03:26:16 -0400 < mnieper> These are only for people like mdhughes who need to allocate 2G pairs on the heap.
2023-04-04 03:26:57 -0400 < mnieper> sjamaan: Beginners will notice many things in a large language specification.
2023-04-04 03:28:01 -0400 < mnieper> At the moment, `map', `for-each', etc. all have to deal with the fact the list they have started working on may no longer be a list after some iterations.  This is what makes the language complex and which is a wart.
2023-04-04 03:29:32 -0400 < sjamaan> What benefit is there to defining mutable pairs in the standard?  If you want to make pairs immutable that's one thing (and I see why it could be useful, even if I don't think the result would still be "Scheme") but then do it properly and have only immutable pairs
2023-04-04 03:30:00 -0400 < mnieper> Sequences (by which I mean immutable finite sequences in the mathematical way) appear all over in programming and in APIs; yet, Scheme does not have a proper type for such objects.  There are probably two or three orders of magnitude more common in code than circular lists.
2023-04-04 03:30:08 -0400 < sjamaan> Mutable pairs sounds like you want to appease people who want mutable pairs without actually making them act like proper pairs, which means you lose all of the benefits of them
2023-04-04 03:30:12 -0400 < mnieper> s/There/They
2023-04-04 03:31:29 -0400 < mnieper> sjamaan: The benefit of mpairs would be space-efficiency (on some impls).  Not that they can be used to build lists as spoken by the rest of Scheme.
2023-04-04 03:32:19 -0400 < sjamaan> How are mutable pairs more space efficient than a custom record type for the job?
2023-04-04 03:32:45 -0400 < sjamaan> Ah yeah, depends on the impl
2023-04-04 03:32:47 -0400 < sjamaan> n/,
2023-04-04 03:32:49 -0400 < sjamaan> n/m
2023-04-04 03:32:58 -0400 < sjamaan> There's just no winning this argument - I give up
2023-04-04 03:33:12 -0400 < sjamaan> Go mess up the language
2023-04-04 03:33:44 -0400 < mnieper> If there are enough tag bits, an implementation may choose a header-less record representation on the heap for some records.
2023-04-04 03:34:21 -0400 < mnieper> "... and only have immutable pairs" does not make sense when there are mutable record types.
2023-04-04 03:34:37 -0400 < sjamaan> You're focusing so much on efficiency you're missing the bigger picture of how incredibly _ugly_ it is to have two types of incompatible pairs
2023-04-04 03:35:16 -0400 < sjamaan> Especially if you have one type that doesn't even behave anything like a pair
2023-04-04 03:38:56 -0400 < mnieper> Forget about efficiency; the fact that what is a list may suddenly be no longer a list (or a list of a different length) makes the specification and implementation of all list procedures much more complicated.
2023-04-04 03:39:48 -0400 < sjamaan> I understand that and I also understand the reasoning behind making pairs immutable - but it makes no sense to have both
2023-04-04 03:40:42 -0400 < sjamaan> And dropping mutable pairs is incompatible with the small standard so I don't even see how this would work
2023-04-04 03:41:36 -0400 < mnieper> I think a problem in this discussion is that when we say "pair" we mean two different things.  You mean a cons-cell when you say "pair"; I mean the mathematical concept of an aggregation of two values (possibly mutable).
2023-04-04 03:41:41 -0400 < mdhughes> If mcons is added, all the pair/list primitives should (MUST) work with it transparently.
2023-04-04 03:41:57 -0400 < mnieper> mdhughes: Not the list primitives.
2023-04-04 03:42:22 -0400 < mnieper> That would counter the introduction of proper lists.
2023-04-04 03:42:31 -0400 < sjamaan> mnieper: I mean all the things we associate with pairs - being able to use map, for instance
2023-04-04 03:42:55 -0400 < sjamaan> That's also what I mean by "Scheme" - the combination of features that work together so well
2023-04-04 03:43:07 -0400 < sjamaan> I don't want Haskell with parentheses
2023-04-04 03:43:10 -0400 < mdhughes> I don't know what a "proper list" is if it's not made of pairs.
2023-04-04 03:43:17 -0400 < mnieper> sjamaan: To have a simple map specification, map would only work on immutable lists.
2023-04-04 03:43:29 -0400 < mnieper> sjamaan: It will work better, not worse.
2023-04-04 03:43:54 -0400 < mnieper> I think your argument is basically "tradition".
2023-04-04 03:44:10 -0400 < mdhughes> Tradition, existing codebases, same thing.
2023-04-04 03:44:16 -0400 < sjamaan> Exactly
2023-04-04 03:44:23 -0400 < sjamaan> It's too fundamental of a change
2023-04-04 03:44:30 -0400 < mdhughes> And yeah, -1000 on (Haskell)
2023-04-04 03:44:32 -0400 < sjamaan> And adding "mpairs" just messes things up further
2023-04-04 03:45:00 -0400 < mnieper> It has nothing to do with Haskell in particular.
2023-04-04 03:45:21 -0400 < mnieper> And I guess no one uses Racket.
2023-04-04 03:45:32 -0400 < sjamaan> I use Scheme, not Racket
2023-04-04 03:45:48 -0400 < mnieper> R5RS won't go away.
2023-04-04 03:45:50 -0400 < mdhughes> Students use Racket, but it's diverging so much now.
2023-04-04 03:45:59 -0400 < sjamaan> Racket is that kitchen sink language if you want one
2023-04-04 03:46:39 -0400 < mnieper> My point was not about the size of Racket but that you can go very far in Scheme without mutable lists.
2023-04-04 03:46:50 -0400 < dpk> and Chicken isn't? http://eggs.call-cc.org/5/
2023-04-04 03:47:04 -0400 < sjamaan> dpk: It has a small core
2023-04-04 03:47:16 -0400 < mnieper> Racket's core is also small.
2023-04-04 03:48:08 -0400 < mnieper> It even documents the core forms (which are truly core forms in Racket).
2023-04-04 03:48:10 -0400 < sjamaan> I have no idea what the core is, but AFAIK it includes lots and lots of other things like continuation marks, mutable pairs etc
2023-04-04 03:48:42 -0400 < mnieper> And syntax-case!
2023-04-04 03:48:47 -0400 < sjamaan> Indeed
2023-04-04 03:48:57 -0400 < mnieper> As I said, R5RS won't go away.
2023-04-04 03:49:38 -0400 < mdhughes> Is that helpful in any way? Nobody much uses R5RS now.
2023-04-04 03:49:39 -0400 < dpk> continuation marks are a useful primitive, more useful than parameters (which Chicken has ‘in core’)
2023-04-04 03:49:40 -0400 < sjamaan> What about r7rs small then?  It has mutable pairs
2023-04-04 03:50:36 -0400 < mnieper> (NB mutable pairs are not part of Racket's core unless I am mistaken)
2023-04-04 03:50:59 -0400 < sjamaan> dpk: Parameters interact with threads, so they have to be in core
2023-04-04 03:51:09 -0400 < sjamaan> (assuming the core includes threading support)
2023-04-04 03:51:45 -0400 < dpk> yes, but continuation marks allow implementing parameters (with the useful additional property that parameterize has a proper tail context in its body) as a library out of core, and more
2023-04-04 03:52:15 -0400 < mdhughes> I think people who want to do radical language surgery like this, need to fork off their own version and try writing their libraries in it. And then when they've shown working code/spec, that can be considered.
2023-04-04 03:52:34 -0400 < sjamaan> mdhughes: Full ack
2023-04-04 03:52:40 -0400 < mnieper> sjamaan: Initially, I said "The next Scheme dialect should have a proper list data type that is immutable and where it can be tested in O(1) whether it is a proper list or not."  I didn't talk about R7RS-small.
2023-04-04 03:53:15 -0400 < mdhughes> Time for mneiper-arc!
2023-04-04 03:53:22 -0400 < sjamaan> dpk: That sounds useful indeed, and might be a worthwile way to do it. But the point was that it includes way more stuff
2023-04-04 03:53:29 -0400 < mdhughes> s/ei/ie/
2023-04-04 03:53:33 -0400 < mnieper> mdhughes: As you use R6RS, you already have the deprecation of mutable pairs.
2023-04-04 03:53:58 -0400 < mdhughes> But they're still actually mutable, and the procedures are there in (chezscheme)
2023-04-04 03:54:10 -0400 < dpk> sjamaan: well, the two examples you cited are 1. something which isn't an extra thing in core, but an alternative primitive to one that Chicken has, and 2. something which isn't in core at all
2023-04-04 03:54:33 -0400 < mdhughes> Actually, they're in r6rs-lib
2023-04-04 03:54:36 -0400 < mnieper> mdhughes: Yes, but you can already easily isolate where you need mutability.
2023-04-04 03:55:07 -0400 < mnieper> They are not in (rnrs).
2023-04-04 03:55:26 -0400 < mdhughes> The procedures provided by the (rnrs mutable-pairs (6)) library allow new values to be assigned to the car and cdr fields of previously allocated pairs.
2023-04-04 03:56:35 -0400 < mnieper> sjamaan: dpk: don't even know whether "small core" is important.  What is important is "a core as simple as the offered features allow".
2023-04-04 03:57:00 -0400 < dpk> sjamaan, mdhughes: to be clear, R7RS Large is not going to remove or even deprecate mutable pairs as we know them from R5RS and R7RS small. i don't *think* that's what mnieper is saying, and if he is, we need to have another long argument about the WG2 charter, one in which i will certainly take your side
2023-04-04 03:57:56 -0400 < mnieper> map/fold/for-each/... (if we count them as core) would be simpler in spec and impl without mutation of their arguments during the dynamic extent of calls to them.
2023-04-04 03:58:53 -0400 < mnieper> Yes, by "next Scheme dialect", I didn't mean R7RS-large.
2023-04-04 03:59:27 -0400 < mnieper> But R7RS-large could take some steps in this direction (as R6RS did with moving mutable pairs to a library that has to be explicitely imported).
2023-04-04 03:59:51 -0400 < dpk> not really, because set-car! and set-cdr! are already in (scheme base), and we can't change that
2023-04-04 03:59:58 -0400 < mnieper> In WG2, we already discussed mutability of strings and how to deal with it in the future.
2023-04-04 04:00:34 -0400 < mnieper> For example, should all new string procedures work on mutable strings as well, or should they favor immutable one.
2023-04-04 04:00:45 -0400 < dpk> the string situation is different
2023-04-04 04:00:54 -0400 < mnieper> Easier, yes.
2023-04-04 04:01:02 -0400 < dpk> i would say harder :D
2023-04-04 04:01:03 -0400 < mnieper> But some principles are the same.
2023-04-04 04:01:07 -0400 < mnieper> :)
2023-04-04 04:01:17 -0400 < dpk> i realized recently that the main issue is that Schemers have decided on the wrong idiom for string processing
2023-04-04 04:01:50 -0400 < dpk> it would be better if string processing code were, in general, written in terms of char and chdr, rather than string-ref. but it isn't
2023-04-04 04:02:04 -0400 < dpk> (note this is saying nothing about the implementations of strings or the performance characteristics of string-ref)
2023-04-04 04:02:06 -0400 < mnieper> At some point, even (scheme base) needs versioning (unless we exclude R8RS).  R7RS-large could offer (scheme mutable-pairs) and (scheme large) besides (scheme base), for example.  (Just talking in the large.)
2023-04-04 04:02:38 -0400 < mnieper> dpk: What about going a character backwards?
2023-04-04 04:02:56 -0400 < mnieper> Or searching from the end?
2023-04-04 04:03:18 -0400 < mnieper> So, maybe a string should be modeled as a doubly-linked list with two ends accessible?
2023-04-04 04:05:01 -0400 < mdhughes> I hate CL strings.
2023-04-04 04:05:51 -0400 < mdhughes> I don't know if they're *actually* implemented as lists, but they present the same, performance is awful, and they don't have any conveniences like Scheme's escapes.
2023-04-04 04:09:37 -0400 < mnieper> I don't know CL strings, but I think dpk (if I understand her correctly) is right that random accessing a character in a string is not primarily useful; it is only useful in Scheme because more fundamental primitives are not there.
2023-04-04 04:10:03 -0400 < dpk> mnieper: you could have rchar and rchdr as well. in two of the three possible string implementations which occur to me which would give an efficient chdr, the same procedures could be equally efficient going from the end of the string instead of the start
2023-04-04 04:10:22 -0400 < dpk> (and the other possible string implementation is a linked list like in Haskell, which nobody wants in practice)
2023-04-04 04:12:16 -0400 < mnieper> Coming back to "simplicity": We should also drop vectors. They are just an efficiency thing and I cannot use my list procedures on them. list-ref and list-set! is all I need. This will also make the language more beginner-friendly.
2023-04-04 04:12:20 -0400 < mnieper> This why I don't buy the simplicity/small core argument.
2023-04-04 04:12:40 -0400 < mnieper> dpk: I like this.
2023-04-04 04:13:44 -0400 < mnieper> Would you have time to implement one of the string SRFIs with these primitives?
2023-04-04 04:14:41 -0400 < mnieper> If this works, we could offer at least a library exporting char, chdr, rchar, rchdr.
2023-04-04 04:19:35 -0400 < dpk> well, to make it efficient and work with a Scheme's native strings, it would need core implementation support
2023-04-04 04:19:49 -0400 < dpk> (which could be as simple as a non-copying substring procedure)
2023-04-04 04:21:33 -0400 < mnieper> When talking about implementing one of the string SRFIs I was thinking about detecting algorithmic complexity issues this way.
2023-04-04 06:06:14 -0400 < dpk> jcowan: i'm internally bikeshedding the name of rchar and rchdr. when writing https://github.com/johnwcowan/r7rs-work/blob/master/DoublyLinkedListsCowan.md, did you choose cpr because of the prefix part of the register on the IBM 704, or simply because p is an inverted d?
2023-04-04 06:07:22 -0400 < dpk> (i think this is a dead end line of thinking for obvious reasons, and would probably go with string-head, string-tail for char, chdr (aliases which T supported), and maybe … string-foot for rchar and i dunno for rchdr?)
2023-04-04 06:09:41 -0400 < jcowan> I think the "p" stands for "previous"
2023-04-04 06:12:26 -0400 < mnieper> string-rtail string-rhead
2023-04-04 06:12:35 -0400 < mnieper> (for "reverse(d)")
2023-04-04 06:15:15 -0400 < jcowan> CL strings are one-dimensional arrays whose element-type is character.  CL *simple* strings are the subset of those which are not adjustable in size and don't have fill pointers.
2023-04-04 06:15:34 -0400 < jcowan> s/character/string-char
2023-04-04 06:15:39 -0400 < jcowan> (a subset of character)
2023-04-04 06:16:30 -0400 < jcowan> mnieper: string-rtail is ambiguous: reverse and then take the tail, or take the tail and then reverse?
2023-04-04 06:17:06 -0400 < mnieper> Neither :)
2023-04-04 06:17:25 -0400 < jcowan> Ergo it is a bad name
2023-04-04 06:17:38 -0400 < mnieper> Yep!
2023-04-04 06:18:36 -0400 < jcowan> mdhughes: the things you are saying about CL strings are not true
2023-04-04 06:24:12 -0400 < mdhughes> I didn't benchmark it yet, just casual use of them in LoL, but they really don't have escapes.
2023-04-04 06:24:22 -0400 < mnieper> string-first string-last string-drop-first string-drop-last
2023-04-04 06:24:27 -0400 < mdhughes> They behave like other collections.
2023-04-04 06:24:34 -0400 < mdhughes> i.e. lists
2023-04-04 06:25:35 -0400 < mdhughes> And the one running over a lot of content thing I did with them, was much much slower than Scheme. Entirely possible that's me not knowing the right way to use CL, but also possible it's just 100x slower.
2023-04-04 06:27:23 -0400 < mdhughes> Hm. https://ptrace.fefe.de/wp/ doesn't have a .lsp version, you want to write one?
2023-04-04 06:28:36 -0400 < mdhughes> My best case Chez is 4.35s, Python is still champ at 1.53s, goddamned C libraries.
2023-04-04 06:31:41 -0400 < mnieper> mdhughes: What is the Scheme version in this directory? .ss looks like Racket because of the #lang.
2023-04-04 06:32:03 -0400 < mdhughes> .ss
2023-04-04 06:32:34 -0400 < mnieper> It is not written with efficiency in mind, I think.
2023-04-04 06:33:08 -0400 < mnieper> For example, the final hash table entries are processed as a list and not as a vector.
2023-04-04 06:33:13 -0400 < mnieper> R6RS has vector-sort.
2023-04-04 06:33:52 -0400 < mnieper> Then why are all strings internalized into symbols?
2023-04-04 06:34:44 -0400 < mdhughes> Oh, sure. I improved on it in my version, but made it longer. That's the nerd-snipe of this. Everyone can look at each version in their language, and try to make it better.
2023-04-04 06:34:46 -0400 < mnieper> Depending on the length of a line (string-append line " ") is also not optimal.
2023-04-04 06:35:33 -0400 < mdhughes> The (string-append line " ") just makes sure there's a terminator.
2023-04-04 06:35:34 -0400 < mnieper> Unless it is "optimally" written in each language compared, benchmarks don't make much sense.
2023-04-04 06:37:06 -0400 < mdhughes> There should be a warning on this repo, "13,375 nerds have lost 187,666,001 hours in here"
2023-04-04 06:37:29 -0400 < mdhughes> And then you have to update it every time you go at it.
2023-04-04 06:38:18 -0400 < mdhughes> But regardless of any individual impl, it's a reasonable task, it's SUPER easy and fast in some languages and harder and slower in others that you may not expect.
2023-04-04 07:30:47 -0400 < jcowan> mdhughes: where is your CL string benchmark code
2023-04-04 07:30:50 -0400 < jcowan> ?
2023-04-04 07:31:08 -0400 < mdhughes> jcowan: I'm no CL pro. You write it!
2023-04-04 07:31:35 -0400 < jcowan> You're saying CL strings are as inefficient as lists.  Where's your evidence?
2023-04-04 07:33:20 -0400 < mdhughes> I sucked in /usr/share/dict for a thing, and it was sluggish. Like I said: I haven't got around to the benchmarking to see why or how much.
2023-04-04 07:34:27 -0400 < jcowan> What code did you use to suck it in?
2023-04-04 07:34:38 -0400 < jcowan> And what CL implementation did you use?
2023-04-04 07:36:34 -0400 < mdhughes> SBCL. Just (with-open-file (in filename) (with-standard-io-syntax ... and a bunch of reads.
2023-04-04 07:42:31 -0400 < mdhughes> Then after I got those in a list, I was matching words against another word list (for maybe obvious reasons). I'm sure lists are fast enough in CL, I/O probably fine, so it was the substrings that were my problem.
2023-04-04 07:50:06 -0400 < jcowan> Matching how?
2023-04-04 07:58:15 -0400 < mdhughes> I don't see it in my ~/.sbcl_history, just my database read code which is in a file. Probably compared subseqs, there was no obvious string-index in CLHS
2023-04-04 07:59:24 -0400 < mdhughes> Which I could complain about that, too, but it's not even in the top 10 of annoyances.
2023-04-04 10:38:03 -0400 < gwatt> I think you use "nth" to index any sequence, including strings
2023-04-04 10:38:41 -0400 < acdw> do yall know if cyclone scheme can use snowfort packages? slash akku slash whatever? Or is "winds" a different thing
2023-04-04 11:52:19 -0400 < jcowan> gwatt: "index" in this context returns an index rather than accepting an index
2023-04-04 11:53:57 -0400 < jcowan> mdhughes: find is the function to find a specific character in a string, position to find a character that matches a predicate
2023-04-04 11:54:51 -0400 < mdhughes> I wanted a substring to match, not just one char.
2023-04-04 11:55:18 -0400 < jcowan> oh, string-contains
2023-04-04 11:56:04 -0400 < jcowan> that's spelled "search"
2023-04-04 13:24:44 -0400 < wasamasa> I love how mpairs basically forced hackernews to stay on ancient racket, lol
2023-04-04 13:25:57 -0400 -!- grettke_ is now known as grettke
2023-04-04 13:33:56 -0400 < gwatt> wasamasa: That seems like something pretty straightforward to get past.
2023-04-04 13:34:19 -0400 < wasamasa> so you'd think, but you're underestimating the laziness of the average programmer
2023-04-04 13:34:36 -0400 < acdw> is hackernews writ in wracket?
2023-04-04 13:35:06 -0400 < wasamasa> in arc
2023-04-04 13:35:26 -0400 < wasamasa> which is implemented in ancient racket
2023-04-04 13:35:41 -0400 < acdw> oh fun
2023-04-04 13:36:54 -0400 < wasamasa> theoretically this should be as easy as locating the code using mpairs and using mpairs there only
2023-04-04 13:37:02 -0400 < wasamasa> but I suspect it's not written in FP style at all
2023-04-04 13:37:08 -0400 < wasamasa> so you'd have to interchange pairs and mpairs
2023-04-04 13:39:01 -0400 < gwatt> My straightforward approach would be to assume all pairs are mpairs. Do an import+rename, done
2023-04-04 13:39:31 -0400 < wasamasa> but isn't the issue that you can only use mpairs for mutation?
2023-04-04 13:39:42 -0400 < wasamasa> instead of passing them to regular list processing functions?
2023-04-04 13:40:47 -0400 < wasamasa> > A mutable pair is not a pair; they are completely separate datatypes. Similarly, a mutable list is not a list, except that the empty list is also the empty mutable list.
2023-04-04 13:40:56 -0400 < wasamasa> yeah, I dimly remember some contract violation
2023-04-04 13:41:42 -0400 < gwatt> There's gotta be a mutable versions of the immutable list ops
2023-04-04 13:42:17 -0400 < gwatt> yeah, compatibility/mlist
2023-04-04 13:43:11 -0400 -!- grettke is now known as grettke_
2023-04-04 13:48:44 -0400 < wasamasa> hm, I see
2023-04-04 13:48:53 -0400 < wasamasa> that gives you a lot more functions to work with, but they're still prefixed
2023-04-04 13:51:15 -0400 < dpk> wasamasa: someone managed to port Arc to newer Racket, but i'm not sure HN ever moved because that was after Paul Graham lost interest in it
2023-04-04 13:51:34 -0400 < wasamasa> yeah, that seems to be the likelier cause
2023-04-04 13:51:38 -0400 < wasamasa> that is, loss of momentum
2023-04-04 13:55:06 -0400 < acdw> oh arc is pg lisp
2023-04-04 13:57:11 -0400 < wasamasa> yeah
2023-04-04 13:58:18 -0400 < Zipheir> bel was the other one.
2023-04-04 13:58:45 -0400 < Zipheir> Graham fans are still waiting for the 'c' Lisp.
2023-04-04 14:05:00 -0400 < acdw> cat
2023-04-04 14:05:27 -0400 -!- grettke_ is now known as grettke
2023-04-04 14:08:42 -0400 < gwatt> oh good, apparently racket has unsafe-set-immutable-c[ad]r!.
2023-04-04 14:21:09 -0400 < dpk> unsafePerformMutablePair
2023-04-04 14:28:10 -0400 < whereiseveryone> Is there a SRFI that is just predicate functions?
2023-04-04 14:28:56 -0400 < whereiseveryone> Just trying to collect random Scheme trivia questions for a game...
2023-04-04 14:40:52 -0400 < amirouche> no
2023-04-04 14:40:59 -0400 < amirouche> what kind of predicates are you looking for?
2023-04-04 14:41:10 -0400 < amirouche> someone will argue that scheme is predicate calculus
2023-04-04 14:55:39 -0400 < acdw> you know what a good predicate would be? `srfi?` takes a number n, returns whether that number is a srfi
2023-04-04 15:08:07 -0400 < wasamasa> what about the withdrawn ones?
2023-04-04 15:11:08 -0400 < gwatt> (define (srfi? n) (fx>= n 0)) ;;; accounts for future srfis
2023-04-04 15:15:10 -0400 < acdw> gwatt: lmao hell yeah. now i want to propose srfi 𝑖
2023-04-04 15:15:19 -0400 < acdw> what's fx>= ?
2023-04-04 15:17:08 -0400 < wasamasa> fixnum-specific version of >=
2023-04-04 15:17:22 -0400 < wasamasa> you'd say integer in other programming languages
2023-04-04 15:17:31 -0400 < acdw> aha, thank you
2023-04-04 15:17:40 -0400 < acdw> so i coud also do srfi π
2023-04-04 15:17:43 -0400 < wasamasa> no
2023-04-04 15:17:53 -0400 < acdw> :(
2023-04-04 15:17:57 -0400 < wasamasa> because π is an irrational number, not integer
2023-04-04 15:18:10 -0400 < acdw> well yeah, that's what i was saying. to break gwatt's srfi?
2023-04-04 15:18:16 -0400 < acdw> no cheating! only lookups!
2023-04-04 15:21:25 -0400 < dpk> gwatt's procedure will fail if there are ever more than fx-greatest SRFIs, though
2023-04-04 15:21:37 -0400 < dpk> (sadface that we didn't call it most-positive-fixnum)
2023-04-04 15:21:54 -0400 < acdw> mm that's true too.
2023-04-04 15:21:58 -0400 < acdw> srfi a
2023-04-04 15:22:14 -0400 < acdw> srfi א
2023-04-04 15:32:43 -0400 < gwatt> dpk: Given the current rate of srfi generation, the universe will be long dead by the time that's a concern
2023-04-04 15:33:11 -0400 < gwatt> rnrs will probably be at least 10 by that time though
2023-04-04 15:34:16 -0400 < acdw> hm i'm not sure about tat
2023-04-04 15:38:01 -0400 < edgar-rft> the universe will die because RnRS becomes so huge that there's no room left for other things
2023-04-04 15:39:03 -0400 < gwatt> R^(Graham's Number)RS
2023-04-04 15:39:38 -0400 < amirouche> make it 11
2023-04-04 15:44:20 -0400 < amirouche> then it will implode into kernel
2023-04-04 15:44:29 -0400 < amirouche> s/into kernel/into a kernel/
2023-04-04 15:44:32 -0400 < amirouche> ;)
2023-04-04 15:51:57 -0400 < uics> :\
2023-04-04 16:25:02 -0400 < whereiseveryone> acdw: That would be a cool if YOLO SRFI
2023-04-04 16:26:45 -0400 < acdw> which one? pi, a, alef?
2023-04-04 16:29:02 -0400 < whereiseveryone> not sure
2023-04-04 16:30:11 -0400 < uics> where is everyone
2023-04-04 16:30:16 -0400  * acdw looks
2023-04-04 16:59:40 -0400 -!- grettke is now known as grettke_
2023-04-04 17:00:10 -0400 -!- grettke_ is now known as grettke
2023-04-04 17:11:04 -0400 < tomhg> webshinra: It is. I thought I grasp Zipheir's comment so I stated my current take :) I agree but maybe you give me a hint about macro-algorithms. In this case - I am a rookie and try not to touch macros yet!
2023-04-04 17:12:21 -0400 < tomhg> jcowan: regarding an use case of SRFI-153 (ordered-set); I only saw this. So I am wondering why this SRFI needs immutability.
2023-04-04 17:13:02 -0400 < webshinra> tomhg, I'm not sure I understand your question
2023-04-04 17:15:45 -0400 < tomhg> you replied to my comment that I encountered a increased start-up time for a program which I introduced macros to. You commented that algorithmic complexity is also important within the interpreter. I misjudged the "effort".
2023-04-04 17:20:40 -0400 < webshinra> I was thinking that, with poor data structure choices or naïve solution of some problemes, the fastest langage would not help at all
2023-04-04 17:26:56 -0400 < tomhg> jepp. Scheme's performance is matching my needs. I _thought_ the performance of macro expansion would be relevant. It ain't on second thought; Given the use case of an interpreter to me (script or interactive invocations). ; junior here.
2023-04-04 17:34:33 -0400 < Zipheir> edgar-rft: Katamari Schemacy
2023-04-04 18:49:29 -0400 -!- grettke is now known as grettke_
2023-04-04 19:10:00 -0400 -!- grettke_ is now known as grettke
2023-04-04 21:57:06 -0400 -!- grettke is now known as grettke_
--- Day changed Wed Apr 05 2023
2023-04-05 01:31:10 -0400 < mnieper> dpk: jcowan: What do you think about string-first/-last-/drop-first/drop-last?
2023-04-05 02:49:05 -0400 < mdhughes> I assumed that was a joke about list handling. With immutable strings you *can* do substrings with shared state, but as Java showed it's an incredibly hard problem to get right, and you basically won't.
2023-04-05 02:50:03 -0400 < mdhughes> It'll create massive GC problems because you have many objects pointing to possibly large buffers, and no way to ever get them separated from those buffers without going thru each string object and trimming to a new backing buffer.
2023-04-05 02:50:40 -0400 < mdhughes> There's like 20 years of analysis been done on how Java's shared strings are a catastrophe.
2023-04-05 02:53:07 -0400 < wasamasa> mutating strings be weird
2023-04-05 02:53:24 -0400 < wasamasa> usually people want just a mutable binding
2023-04-05 02:53:57 -0400 < mdhughes> Mutable's useful for making buffers, and simple string transformations (capitalize in place, etc.)
2023-04-05 02:54:28 -0400 < mdhughes> Immutable *is* easier to use safely, but you can't share those buffers or it causes more problems.
2023-04-05 02:55:11 -0400 < wasamasa> why does this sound like lists in lisp
2023-04-05 02:56:19 -0400 < mdhughes> The problem in Scheme is two major data types are mutable but fixed-length, and one's mutable but growable but its mutability is again useful but very dangerous.
2023-04-05 02:56:23 -0400 -!- unpx_ is now known as unpx
2023-04-05 02:57:20 -0400 < wasamasa> yeah, without insertion, the use of mutability is limited
2023-04-05 02:57:32 -0400 < wasamasa> hence the difference between buffers and strings
2023-04-05 02:57:36 -0400 < mdhughes> There's not a convenient growable, safe type. Hashtables are about it, as noted I sometimes use (hashtable-set! h (hashtable-length h) v) to append to a sparse array. There's no tools to use that safely.
2023-04-05 02:57:58 -0400 < mdhughes> Javascript's Array object is excellent. You can push, pop, append, shift, insert in the middle, slice out segments, etc.
2023-04-05 02:58:42 -0400 < wasamasa> it is convenient, but I wonder how I'm supposed to use it for ideal performance
2023-04-05 02:58:52 -0400 < mdhughes> And when you get a subarray, apparently in the impls I use it copies out the backing store, not produce another GC reference.
2023-04-05 02:59:34 -0400 < mdhughes> With JS the performance is less important than safety, since it's a rigorous sandbox.
2023-04-05 02:59:45 -0400 < wasamasa> lol
2023-04-05 03:00:05 -0400 < mdhughes> Scheme would presumably make the opposite choice, because most impls prioritize speed over safety.
2023-04-05 03:00:36 -0400 < mdhughes> I know, it's ridiculous that JS is the safest lang in the world right now, but it is.
2023-04-05 03:00:57 -0400 < mnieper> Ordinary Scheme strings should be immutable (allowing more efficient implementation strategies and because the current form of mutability is too limited to be useful in practise), but Scheme should get a mutable buffer type.
2023-04-05 03:01:29 -0400 < mnieper> Even capitalization does not work in-place with Scheme strings.
2023-04-05 03:01:45 -0400 < mdhughes> And I did write a mutable stringbuffer. I should clean it up and SRFI it, I suppose.
2023-04-05 03:01:47 -0400 < wasamasa> damn zee germanß
2023-04-05 03:01:58 -0400 < wasamasa> yes please
2023-04-05 03:02:10 -0400 < wasamasa> I remember one not so great implementation from a guile user
2023-04-05 03:02:24 -0400 < wasamasa> but you could just put it up on snow/akku
2023-04-05 03:02:34 -0400 < mdhughes> Mine's currently more speed over safety, so I need to instrument the edge cases.
2023-04-05 03:02:39 -0400 < mnieper> A mutable stringbuffer proposal would be great.
2023-04-05 03:04:50 -0400 < wasamasa> https://wiki.call-cc.org/eggref/4/gap-buffer
2023-04-05 03:07:57 -0400 < wasamasa> I remember writing a way more convenient to use faux implementation of emacs-style procedures which just used a string and an integer wrapped in a record
2023-04-05 03:09:03 -0400 < wasamasa> but then I ended up scrapping them in favor of irregex
2023-04-05 04:43:34 -0400 < dpk> mdhughes: there are, as i wrote yesterday, three reasonable implementations strategies known to me for strings which can be iterated over in a manner like linked lists
2023-04-05 04:44:38 -0400 < dpk> one is a linked list. unfortunately, this sucks for anything except this access pattern, and probably is sub-optimal even for it, given probably at least two words of storage space for every character
2023-04-05 04:44:46 -0400 < dpk> so let's discount that
2023-04-05 04:46:22 -0400 < dpk> another is very similar to what implementations already do, and is i think what you were hinting at with your references to Java: a string's contents is floating around a blob of memory somewhere, and the string object itself consists of a reference to that blob of memory at a certain offset, plus a length
2023-04-05 04:47:53 -0400 < dpk> this doesn't necessarily imply that the string has to be immutable, but we are deprecating string-set! in R7RS Large anyway (by explicitly warning that it will probably have terrible performance)
2023-04-05 04:49:06 -0400 < dpk> so if an implementation has to resort to really bad and slow hacks to make string-set! work with this approach, however we define ‘work’ under the existence of the char/chdr substring procedures, so be it
2023-04-05 04:50:09 -0400 < dpk> string-set! is about the most useless primitive imaginable for string mutation anyway (you can't use it to change the number of characters in a string, which is a prerequisite for most things people want to do with mutable strings). being the only such primitive Scheme supports, deprecating it is that much easier
2023-04-05 04:51:32 -0400 < dpk> the other difficulty with this approach is that garbage collectors should ideally be able to free part of the underlying blob of memory if the string objects remaining only point to some of it, but that isn't really such a concern if these substring objects are only used for iteration
2023-04-05 04:52:11 -0400 < dpk> the third approach is some kind of tree, probably a rope
2023-04-05 04:52:56 -0400 < dpk> this makes the garbage collector's job that much easier, and makes string-append and similar practically free as well
2023-04-05 04:55:07 -0400 < dpk> oh, my other concern about the middle approach is how it interacts with table-based approaches to make string-ref run in O(1). not an insurmountable issue, but does imply a slightly different implementation, and even more involvement from the garbage collector in the specific implementation of strings, if you do want to have it be able to collect now-extraneous parts of strings which now only exist as substrings
2023-04-05 05:06:59 -0400 < amirouche> I am goign to reach to the tree
2023-04-05 05:07:29 -0400 < amirouche> it will be useful to agree on an API, and do a small competition
2023-04-05 05:07:36 -0400 < amirouche> oh that is called an SRFI :)
2023-04-05 05:08:20 -0400 < amirouche> that reminds me I need to benchmark scheme mapping, schemepunk's btree, and mine
2023-04-05 07:37:08 -0400 < lockywolf> Is anyone using guix as their default system?
2023-04-05 07:56:34 -0400 < dpk> why did SRFI 152 get rid of the KMP
2023-04-05 07:56:40 -0400 < dpk> primitives?
2023-04-05 07:56:44 -0400 < dpk> from SRFI 13
2023-04-05 07:57:25 -0400 < dpk> they’re useful primitives for searching for strings in ports, string-like structures (we mentioned gap buffers above) other than actual strings, etx
2023-04-05 07:57:28 -0400 < dpk> *etc
2023-04-05 08:52:59 -0400 < lockywolf> A file system should not be a tree. It should be a directed acyclic graph.
2023-04-05 08:54:49 -0400 < pinoaffe> lockywolf: I use guix as my daily driver
2023-04-05 08:57:59 -0400 < mdhughes> A real file system should be a single u8vector that you write to from your REPL. "Ah yes I put the TPS reports at #x4800, the nudie pics at #x8400, and this time don't confuse them."
2023-04-05 09:51:05 -0400 < jcowan> dpk: I removed the KMP primitives because they constrain the implementation to be KMP rather than its superior successor,, whatever that will be
2023-04-05 09:51:38 -0400 < mnieper> I agree that exposing the actual algorithm is not "the right thing".
2023-04-05 09:52:20 -0400 < mnieper> As KMP is not restricted to strings, it probably belongs into its own library.
2023-04-05 09:52:28 -0400 < jcowan> mdhughes: The MVS file system is basically like that, except you have to mention actual sectors and tracks
2023-04-05 09:53:14 -0400 < jcowan> I agree that a generalized KMP SRFI is a reasonable idea
2023-04-05 09:55:27 -0400 < dpk> why do we need a new SRFI? the Batteries committee could just put those procedures from SRFI 13 in their own library
2023-04-05 09:57:23 -0400 < mnieper> dpk: A Codeberg issue may suffice; the procedures should be revised in any case.  For example, the argument about non-optional arguments seem to stem from pre-case-lambda times.
2023-04-05 09:57:46 -0400 < mnieper> But jcowan may have a more complete set of KMP procedures in mind.
2023-04-05 09:59:05 -0400 < mnieper> The advantage of a SRFI is that it could be used right now (and also in contexts where R7RS-large won't be available).  Insofar it makes sense to have the Battery libraries also as SRFIs.
2023-04-05 09:59:06 -0400 < jcowan> I don't have anything specific in mind, but if you want them to work on arbitrary sequences, you can't just grab SRFI 13, which is restricted to strings.  I'm not saying such a SRFI would necessarily be a big job.
2023-04-05 09:59:45 -0400 < jcowan> The reason to use SRFIs is that they have a well-defined process that people actually participate in.
2023-04-05 10:02:04 -0400 < jcowan> dpk: Note that SRFI 135 uses one-level trees, and provides guaranteed bounds on sharing
2023-04-05 10:02:53 -0400 < dpk> in space, but not in time
2023-04-05 10:03:14 -0400 < dpk> any substring operation is still O(n) in time
2023-04-05 10:03:57 -0400 < dpk> mnieper: SRFI 13 can be used right now. it’s one of the most commonly provided SRFIs
2023-04-05 10:04:12 -0400 < dpk> Chibi is a notable exception, just to annoy everyone
2023-04-05 10:05:17 -0400 < dpk> jcowan: two out of three of the KMP procedures in SRFI 13 are agnostic about the type of the haystack, though the needle must be a string
2023-04-05 10:05:49 -0400 < dpk> a version where the needle can be a bytevector is the only obvious improvement i can think of, and even that’s dubious
2023-04-05 10:06:57 -0400 < mnieper> dpk: If R7RS-large gets an improved/extended version of SRFI 13's KMP procedures, people may want to use it outside of the large language (which cannot be provided by all impls).
2023-04-05 10:08:03 -0400 < mnieper> Searching for a sublist in a long list can also be an application.
2023-04-05 10:09:43 -0400 < dpk> true!
2023-04-05 10:13:08 -0400 < jcowan> CL's `search` procedure has a domain of "lists or 1-dimensional arrays" (strings are arrays)
2023-04-05 10:16:20 -0400 < jcowan> Back to SRFI 135: the textual-ref procedure runs in O(1) time (unless its argument is a string, of course)
2023-04-05 11:12:05 -0400 < cow_2001> are they talking about stuff like miranda again? 138 The phenomenon of a single computational object being accessed by more than one name is known as aliasing. The joint bank account situation illustrates a very simple example of an alias. In 3.3 we will see much more complex examples, such as “distinct” compound data structures that share parts. Bugs can occur in our programs if we forget that
2023-04-05 11:12:07 -0400 < cow_2001> a change to an object may also, as a “side effect,” change a “different” object because the two “different” objects are actually a single object appearing under different aliases. These so-called side-effect bugs are so difficult to locate and to analyze that some people have proposed that programming languages be designed in such a way as to not allow side effects or aliasing (Lampson
2023-04-05 11:12:09 -0400 < cow_2001> et al. 1981; Morris et al. 1980).
2023-04-05 11:24:26 -0400 < jcowan> That's a very good (if unintended) explanation of why immutable objects (which should really be called immutable values) are a Good Thing
2023-04-05 11:25:45 -0400 < jcowan> dpk: From SRFI 135: "Implementations that share storage between texts must satisfy the following requirement: There is some reasonably small fixed bound on the ratio of storage used by the shared representation divided by the storage that would be used by an unshared representation."
2023-04-05 11:29:55 -0400 < jcowan> If you use the sample implementation, the worst-case ratio is 16
2023-04-05 11:30:59 -0400 < jcowan> when (a) the internal representation is UTF-8, (b) a 1-character ASCII text retains up to 127 characters of a text that is no longer reachable, and (c) all 127 of those retained characters lie outside Unicode's Basic Multilingual Plane (BMP).
2023-04-05 11:34:52 -0400 < dpk> jcowan: yes, but the *time* usage for a substring operation is linear, because although the chunks mostly don't have to be copied, the vector pointing to the chunks does
2023-04-05 12:39:53 -0400 < mdhughes> jcowan: Really that's just FAT with one less step; good old days having to write my own filesystem.
2023-04-05 12:40:29 -0400 < jcowan> Except that FAT is chained.
2023-04-05 12:41:07 -0400 < jcowan> dpk: true
2023-04-05 12:41:55 -0400 < jcowan> It's a tradeoff between complexity and storage.  SRFI 135 doesn't specify anything about the performance of subtext.
2023-04-05 12:51:21 -0400 < mnieper> Doesn't it then fail part of its goal?
2023-04-05 13:21:50 -0400 < jcowan> No.
2023-04-05 13:22:18 -0400 < jcowan> (I mean the procedure named `subtext`).
2023-04-05 13:23:12 -0400 < jcowan> Actually, it says "should run in O(1) time".
2023-04-05 13:58:04 -0400 < cow_2001> now this https://yuvallangerontheroad.codeberg.page/mirror-sarabander-sicp/html/3_002e2.xhtml
2023-04-05 14:04:10 -0400 < dpk> jcowan: where?
2023-04-05 14:04:40 -0400 < dpk> the only relevant sentence i can see is "The other procedures specified by this SRFI should run in amortized linear time"
2023-04-05 14:07:09 -0400 < dpk> there seems to be a + missing in the previous paragraph
2023-04-05 14:07:17 -0400 < dpk> ‘If the first two arguments passed to textual-contains and textual-contains-right are texts, then those procedures must run in O(m n) time’
2023-04-05 14:07:53 -0400 < dpk> it should be O(m + n), presumably
2023-04-05 14:10:55 -0400 < dpk> incidentally, jcowan, i think your argument about there maybe being something better than KMP one day is not really valid because there's unlikely to ever be anything which beats O(m + n). at best, someone might find an algorithm with better constant factors – but even then, presumably only in the preparation phase, which is the part linear in the time of the smaller (usually much smaller) string anyway
2023-04-05 14:50:38 -0400 < amirouche> jart that created lisp sector, is not working alone, how suprising.
2023-04-05 14:51:15 -0400 < amirouche> I fixed a namespacing issue with letloop.cloud; now database subspace are properly disjoint
2023-04-05 14:55:09 -0400 < jcowan> Well, nobody thought quicksort could be improved on either, and yet the various qsort() and quicksort() algorithms in standard libraries no longer do quicksorts.
2023-04-05 14:56:12 -0400 < jcowan> dpk:^^
2023-04-05 15:33:09 -0400 < dpk> well, there's quite a difference between improving on an algorithm which has a quadratic worst case and one which always runs in linear time
2023-04-05 15:48:34 -0400 < jcowan> Linearithmic time, actually.  Only radix sort runs in linear time, I think
2023-04-05 16:00:20 -0400 < Zipheir> And that's a rather special-purpose algorithm.
2023-04-05 16:03:01 -0400 < Zipheir> I believe that general-purpose sorting algorithms top out at O(n log n) with merge sort https://en.wikipedia.org/wiki/Merge_sort
2023-04-05 16:03:21 -0400 < Zipheir> (So far.)
2023-04-05 16:11:24 -0400 < cow_2001> you know, i've noticed that you can almost call '( blah blah ) a multi line comment
2023-04-05 16:12:34 -0400 < cow_2001> it doesn't really do anything if you stick it somewhere where its value is ignored
2023-04-05 16:13:08 -0400 < cow_2001> have you ever used it lime that?
2023-04-05 16:19:44 -0400 < gwatt> cow_2001: I think there's a standard multi-line comment of #| ... |# which is actually a comment.
2023-04-05 16:22:42 -0400 < gwatt> And if you want to misuse a scheme datum in place of a comment a string literal probably works better.
2023-04-05 16:23:32 -0400 < cow_2001> hmmmmmm
2023-04-05 16:24:06 -0400 < cow_2001> i wonder if paredit works in multiline comments too
2023-04-05 16:24:37 -0400 < cow_2001> gwatt: thank you
2023-04-05 16:25:03 -0400 < acdw> oh there was some other thing that made me want to switch to puni the other day. paredit is good ... until it's not
2023-04-05 16:30:31 -0400 < cow_2001> acdw: share please your opinions on it
2023-04-05 16:33:12 -0400 < acdw> oh just sometimes it gets into a non-balanced state and it's a real pain to get it back
2023-04-05 17:52:51 -0400 < tomhg> mdhughes, wasamasa: Scheme's language design in regards to its list showed me why I am not interested in immutability. All these mutations are handled outside of my concern. With Java I am aware that each new string may occupy a new entry on the stack. So either my program grows _unknown_ on the stack due to strings (immutability); Of I can judge on my own by mutating my store. The latter appears to be very
2023-04-05 17:52:57 -0400 < tomhg> fine to me.
2023-04-05 17:55:08 -0400 < tomhg> s/Of/Or
2023-04-05 17:58:56 -0400 < tomhg> *seufz* This large backlogs makes me procrastinate :) a String has to be mutable. this may not imply that reusing a string is prohibited (from my gut + skipped the following irc-history).
2023-04-05 18:05:33 -0400 < tomhg> second thought; Immutability may grant me hands on a string-reference which should not be collected. Since Strings are my most individual data structure they are very imporant to me. I am unable to judge and sincerly inquiry to skip any of my input prior. *leaves*
2023-04-05 18:21:52 -0400 < Zipheir> It's good to pay attention to mutability when writing library procedures or anything else that will be used by other people.
2023-04-05 18:23:01 -0400 < tomhg> If we would have a common denominator to strings we could rely on the purity of procedures; I'm out of my bounds, Zipheir ...
2023-04-05 18:25:10 -0400 < Zipheir> It's not just strings and lists. If you want to write things that work with continuations, you have to be very careful about mutation.
2023-04-05 18:26:13 -0400 < tomhg> *hm* I suspected to restore the state of a continuation once I invoke it.
2023-04-05 18:27:51 -0400 < tomhg> I didn't tested such invocation due to beeing afraid of it. Though I thought this should be correct.
2023-04-05 18:27:56 -0400 < Zipheir> If you have fluid-let, you can do stuff like that.
2023-04-05 18:28:11 -0400 < Zipheir> But maybe we're talking about different things.
2023-04-05 18:29:04 -0400 < tomhg> Maybe. I still got the task of reading about fluid-let on my backlog.
2023-04-05 18:29:24 -0400 < tomhg> May I procrastinate publicly?:
2023-04-05 18:30:44 -0400 < tomhg> I entered my holiday on monday and was already called three times. I was on two birthdays + one to come. I have scheduled my entire holidays helping people. I need rest :(
2023-04-05 18:33:08 -0400 < tomhg> I fk love this channel. I'm leaving for a few. *waveshands*. Thanks.
2023-04-05 23:34:30 -0400 < lockywolf> it's amusing that in programming "strings" and "threads" mean something entirely unlike
2023-04-05 23:47:38 -0400 < acdw> and ropes
2023-04-05 23:56:42 -0400 < sham1> Ropes mean a similar thing to strings though
--- Day changed Thu Apr 06 2023
2023-04-06 00:09:17 -0400 < acdw> yeah i guess so
2023-04-06 00:09:22 -0400 < acdw> i was just listing stringy things
2023-04-06 00:26:19 -0400  * dave0 unravels the threads
2023-04-06 04:29:22 -0400 -!- polyrob_ is now known as polyrob
2023-04-06 07:25:52 -0400  * amirouche playing with LLMs
2023-04-06 08:52:34 -0400 < cow_2001> should I be using more let and less define?
2023-04-06 08:52:55 -0400 < cow_2001> i just don't like nesting more than i have to
2023-04-06 08:53:33 -0400 < cow_2001> but someone here said something like "define galore" so maybe let has its benefits?
2023-04-06 08:53:40 -0400 < mdhughes> I only use define at top level, let inside functions. If you're very deeply nested, extract a sub-function, it's doing too much.
2023-04-06 08:53:42 -0400 < cow_2001> when looking at my code
2023-04-06 08:54:04 -0400 < cow_2001> hmm! mdhughes
2023-04-06 08:55:12 -0400 < cow_2001> but why use let instead of define? don't they do sort of the same thing? bind a name to a value in the following environment?
2023-04-06 08:55:25 -0400 < mdhughes> Also I use a lot of let* where I assign sub-computations in order, and then end up with one actual result. Just a habit of how I do math.
2023-04-06 08:55:57 -0400 < mdhughes> They're probably equivalent in function, but it's more clear what the limited scope of a let is.
2023-04-06 08:56:20 -0400 < cow_2001> ah! so you use it to document where the name is used
2023-04-06 08:57:06 -0400 < cow_2001> i will try it out and think of that while at it
2023-04-06 08:57:18 -0400 < cow_2001> thank you
2023-04-06 09:02:29 -0400 < cow_2001> mdhughes: what do you say about having a single name, but you keep let* at it? (let* ([x (get-initial-value)] [x (work-it x)] [x (work-some-more x)]) x)
2023-04-06 09:03:04 -0400 < mdhughes> I usually rename each term in order, often with more meaningful names than x or x2.
2023-04-06 09:05:28 -0400 < cow_2001> like line, stripped-line, split-line, name-field?
2023-04-06 09:05:57 -0400 < mdhughes> Sure. Or bounds, inside-rect, left-rect, etc.
2023-04-06 09:06:17 -0400 < cow_2001> ooh, you do a lot of graphical stuff?
2023-04-06 09:06:39 -0400 < mdhughes> Yeah, I make games (RPGs mostly).
2023-04-06 09:06:46 -0400 < cow_2001> O_O
2023-04-06 09:07:05 -0400 < cow_2001> i need to look you up now
2023-04-06 09:08:00 -0400 < cow_2001> oh here you are!
2023-04-06 09:08:25 -0400 < mdhughes> https://mdhughes.tech
2023-04-06 09:08:34 -0400 < cow_2001> you are into osr
2023-04-06 09:09:03 -0400 < mdhughes> Yep.
2023-04-06 09:09:35 -0400 < cow_2001> oh boy.
2023-04-06 09:09:51 -0400 < mdhughes> Nearly done with my new TTRPG, but also very close to shipping my damned roguelike, and then get back to work on the JRPG-like.
2023-04-06 09:09:51 -0400 < cow_2001> catan guy is kaput, did you hear that?
2023-04-06 09:10:10 -0400 < mdhughes> Yeah. Tho been 20 years since I played any Settlers.
2023-04-06 09:10:13 -0400 < cow_2001> even my mother heard that
2023-04-06 09:10:43 -0400 < cow_2001> didn't know it was so famous
2023-04-06 09:12:23 -0400 < cow_2001> i wish i had any art in me. i have some game ideas
2023-04-06 09:12:32 -0400 < mdhughes> Recovered boardgames from a dumpster where they'd been since the '80s.
2023-04-06 09:12:54 -0400 < cow_2001> not a place for boardgames.
2023-04-06 09:13:00 -0400 < mdhughes> Also Cheap-Ass Games helped a lot with the recovery. So you don't need much art, just game design (which is harder).
2023-04-06 09:13:10 -0400 < cow_2001> you know what i hate? DRMed board games
2023-04-06 09:13:27 -0400 < cow_2001> no, computer games
2023-04-06 09:14:18 -0400 < cow_2001> it is not a very new gameplay, but they are funny little games that exist only inside my imagination
2023-04-06 09:14:31 -0400 < cow_2001> alas
2023-04-06 09:14:52 -0400 < cow_2001> actually, no new gameplay, only established tropes
2023-04-06 09:15:20 -0400 < cow_2001> but they've been playing chess for centuries, so who cares
2023-04-06 09:16:03 -0400 < mdhughes> Well, it's easy enough to make small games. Scheme's a little harder because you need to learn to use SDL2 or some other graphics UI. Racket's probably easier but its graphics are very slow.
2023-04-06 09:16:36 -0400 < mdhughes> Or you can just make text games, it really is pretty easy to print out some ANSI escapes and read a line of input.
2023-04-06 09:20:16 -0400 < acdw> would you recommend any resources for learning SDL?
2023-04-06 09:20:21 -0400 < acdw> or other graphics?
2023-04-06 09:20:37 -0400 < cow_2001> one of these days goblins would sprinkle wasm over guile and we'll be able to say bye bye to javascript
2023-04-06 09:21:04 -0400 < drakonis> its already happening
2023-04-06 09:21:55 -0400 < cow_2001> O_O
2023-04-06 09:24:26 -0400 < mdhughes> I use thunderchez's sdl2 lib, and then added some of my own C FFI stuff to manage audio.
2023-04-06 09:24:57 -0400 < drakonis> https://gitlab.com/spritely/guile-hoot-updates/
2023-04-06 09:25:03 -0400 < mdhughes> Mostly you can convert C examples directly over.
2023-04-06 09:26:10 -0400 < mdhughes> WASM doesn't really help you, it doesn't give you JS-like DOM access, it's just a compute module.
2023-04-06 09:30:17 -0400 < drakonis> js interop has to be implemented along with it
2023-04-06 09:34:59 -0400 < wasamasa> acdw: I guess it's a lot of trial and error because there aren't many games with source code to study
2023-04-06 09:35:18 -0400 < wasamasa> acdw: recently skeeto posted about mistakes to avoid with SDL2, but then, he's got peculiar requirements
2023-04-06 09:36:32 -0400 < wasamasa> acdw: https://nullprogram.com/blog/2023/01/08/
2023-04-06 09:36:58 -0400 < mdhughes> The really smart way to do it is all thru C FFI, minimal Scheme API and do as much as possible on the C side. Then you can change & update libraries easier.
2023-04-06 09:37:22 -0400 < mdhughes> But that assumes you like writing C.
2023-04-06 09:37:29 -0400 < wasamasa> he writes C trying to avoid libc entirely and develops for windows, too
2023-04-06 09:38:16 -0400 < wasamasa> and indeed, he seems to like writing C
2023-04-06 09:39:55 -0400 < mdhughes> I do suggest using SDL-image unless you really like writing your own image handlers, or converting every asset to whatever format SDL2 supports internally.
2023-04-06 09:40:13 -0400 < mdhughes> SDL-ttf would be nice if you care about fonts, I just render bitmap fonts.
2023-04-06 09:40:25 -0400 < wasamasa> yes and he's the kinda dude to just reconvert things to make the code simpler
2023-04-06 09:51:31 -0400 < acdw> wasamasa: awesome thank you!
2023-04-06 09:52:01 -0400 < wasamasa> his point about the SDL2 wiki not being the canonical source of documentation is embarassing
2023-04-06 09:52:17 -0400 < wasamasa> I kind of suspected the wiki is roughly as useful as emacswiki
2023-04-06 09:52:22 -0400 < wasamasa> ok, not that useless
2023-04-06 09:52:34 -0400 < acdw> lmao
2023-04-06 09:52:35 -0400 < wasamasa> but now I know I should completely ignore it
2023-04-06 09:52:44 -0400 < wasamasa> and just read more example code
2023-04-06 09:54:52 -0400 < acdw> emacs or SDL?
2023-04-06 09:55:22 -0400 < mdhughes> I don't think the wiki's that bad, but you do want to hit the category page, use the text as a guide, look at the .h for specific details.
2023-04-06 09:59:42 -0400 < mnieper> define vs let(*)(rec) is mostly a question of style.
2023-04-06 10:00:11 -0400 < acdw> let's make a scheme with one let
2023-04-06 10:00:22 -0400 < mnieper> Internal defines are well-defined in terms of letrec, so there is not much of a difference at least as long the Scheme system knows how to efficiently compile letrec
2023-04-06 10:00:29 -0400 < mnieper> s/letrec/letrec*
2023-04-06 10:00:42 -0400 < acdw> ooo
2023-04-06 10:00:56 -0400 < mnieper> I typically use internal defines for local procedure definitions.
2023-04-06 10:01:01 -0400 < acdw> (define let letrec*) :p
2023-04-06 10:01:36 -0400 < mnieper> acdw: That's overspecifying.  letrec* has a fixed evaluation order.
2023-04-06 10:02:12 -0400 < acdw> oh I was joking of course. is there a reason why unspec order would be preferable to fixed thoñ
2023-04-06 10:02:15 -0400 < acdw> ?*
2023-04-06 10:02:29 -0400 < wasamasa> SDL
2023-04-06 10:02:45 -0400 < wasamasa> I ignore emacswiki, but for different reasons
2023-04-06 10:02:51 -0400 < acdw> aha, thanks. lmao
2023-04-06 10:03:07 -0400 < wasamasa> at least the SDL guides aren't hopelessly outdated
2023-04-06 10:03:32 -0400 < mdhughes> You don't need let or define as long as you have lambda.
2023-04-06 10:03:37 -0400 < mnieper> acdw: Reasons are optimization opportunities and being able to be more precise about the algorithm you want to write down.
2023-04-06 10:03:41 -0400 < mdhughes> But it's a lot less annoying!
2023-04-06 10:03:51 -0400 < wasamasa> clearly, scheme isn't a forth
2023-04-06 10:04:14 -0400 < wasamasa> if it were, it would have eliminated all that useless junk
2023-04-06 10:09:40 -0400 < wasamasa> see http://yosefk.com/blog/my-history-with-forth-stack-machines.html for the reference
2023-04-06 10:22:18 -0400 < drakonis> https://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html counterpoint
2023-04-06 10:45:08 -0400 < mdhughes> https://archive.org/details/ataribooks-forth-on-the-atari-learning-by-using
2023-04-06 10:46:53 -0400 < drakonis> https://www.forth.com/starting-forth/
2023-04-06 10:47:18 -0400 < drakonis> the cover art for atari's book on forth is so very 80s
2023-04-06 10:48:24 -0400 < acdw> mnieper: ahhh makes sense, I figured it was something to do with that
2023-04-06 10:48:37 -0400 < acdw> combine lisp and forth into fisp
2023-04-06 10:49:54 -0400 < drakonis> do you think someone hasnt tried already?
2023-04-06 10:50:20 -0400 < mnieper> acdw: As Scheme is also often used in academia, this precision makes sense for it.
2023-04-06 11:09:31 -0400 < acdw> oh yeah
2023-04-06 11:09:33 -0400 < acdw> drakonis: lol
2023-04-06 11:10:03 -0400 < wasamasa> acdw, drakonis: of course, you need to read Let over Lambda's later chapters
2023-04-06 11:10:32 -0400 < acdw> yes indeed
2023-04-06 11:10:44 -0400 < acdw> and its earlier chapters
2023-04-06 11:10:57 -0400 < acdw> probably the middle ones too
2023-04-06 11:11:25 -0400 < wasamasa> the later chapters are about some wild excursions, like implementing forth in lisp, then extending the forth and somehow going back to lisp
2023-04-06 11:14:42 -0400 < acdw> oh dang
2023-04-06 11:18:26 -0400 < wasamasa> > Lisp Moving Forth Moving Lisp
2023-04-06 11:18:38 -0400 < wasamasa> so just chapter 8
2023-04-06 11:45:33 -0400 < amirouche> anyone tried llama.cpp?
2023-04-06 12:45:09 -0400 < cow_2001> i love that cover so hard.
2023-04-06 12:46:36 -0400 < wasamasa> amirouche: I think there's other channels with more LLM enthusiasts
2023-04-06 12:47:30 -0400 < johnjaye> i tried installing it, didn't work. maybe one day you will have an llm in scheme and it will be educational
2023-04-06 12:52:38 -0400 < wasamasa> for example ##machinelearning is a thing apparently
2023-04-06 12:52:39 -0400 < acdw> i wrote an llm in bash: https://junk.acdw.net/as.sh
2023-04-06 12:52:46 -0400 < acdw> well. .. a slm
2023-04-06 13:21:09 -0400 < Zipheir> I can't see that Forth has much on Scheme in terms of expressivity. The complete lack of typing could also be a source of pitfalls.
2023-04-06 13:21:49 -0400 < Zipheir> The 'let situation' may be overcomplicated, but the idea is still better than relying on a stack discipline.
2023-04-06 13:22:11 -0400 < sham1> You do have locals in Forth though
2023-04-06 13:22:14 -0400 < sham1> And also, there's always the global words
2023-04-06 13:23:35 -0400 < Zipheir> Hmm, I guess it does.
2023-04-06 13:24:46 -0400 < Zipheir> Wikipedia says that "the Forth stack provides the role performed by local variables in other languages (although Forth has real local variables)".
2023-04-06 13:34:05 -0400 < wasamasa> it has the same kind of typing assembly has
2023-04-06 13:34:12 -0400 < wasamasa> so no surprises there
2023-04-06 13:38:10 -0400 < mdhughes> Minds weak typing strong for is.
2023-04-06 13:38:48 -0400 < wasamasa> some people argue assembly is untyped
2023-04-06 13:38:59 -0400 < nomagno> Depends on the assembly
2023-04-06 13:39:05 -0400 < wasamasa> because there is no coercion going on (weak typing)
2023-04-06 13:39:26 -0400 < nomagno> I treat addressing modes as types
2023-04-06 13:39:36 -0400 < acdw> isn't it all strongly typed as bits
2023-04-06 13:39:57 -0400 < nomagno> In mine
2023-04-06 13:40:30 -0400 < nomagno> If you only have one type, you have no types
2023-04-06 13:42:06 -0400 < mnieper> movq %al, %xmm0 doesn't work, does it?  So might say there is more than one type.
2023-04-06 13:42:18 -0400 < amirouche> tx wasamasa
2023-04-06 13:45:21 -0400 < mdhughes> You do have to be really precise about your data & calling functions in both Forth and ASM. So often you end up with something like Hungarian notation, name-as-type.
2023-04-06 13:46:12 -0400 < mdhughes> Scheme is dynamic typing: the objects know what they are, and functions usually assert or just blow up by accident if you mismatch them.
2023-04-06 13:46:56 -0400 < mnieper> So R5RS and R7RS are, at least in principle, very similar to ASM in this regard.
2023-04-06 13:47:43 -0400 < mdhughes> Not really? If you call (string-length x) and x is an integer, it'll error.
2023-04-06 13:48:53 -0400 < mnieper> Only if your impl is nice.
2023-04-06 13:49:22 -0400 < mnieper> The standards R5RS and R7RS allow the impl to blow up the universe if you do this.
2023-04-06 13:50:50 -0400 < acdw> pew pew
2023-04-06 13:51:05 -0400 < Zipheir> But you'll know that if you're using one of those.
2023-04-06 13:51:17 -0400 < mnieper> What do you mean?
2023-04-06 13:51:26 -0400 < mnieper> Impls?
2023-04-06 13:52:44 -0400 < Zipheir> "It's the fragment, not the day / It's the pebble, not the stream / It's the ripple, not the sea / That is happening." (Stephen Sondheim)
2023-04-06 13:52:56 -0400 < mnieper> ?
2023-04-06 13:52:57 -0400 < Zipheir> And that is all I have to say about that.
2023-04-06 13:53:12 -0400 < mdhughes> All the ones I have error out nicely enough, Universe wasn't destroyed AFAICT.
2023-04-06 13:53:40 -0400 < mdhughes> This is probably how the Universe ends, me screwing around in a REPL.
2023-04-06 13:53:45 -0400 < mnieper> :D
2023-04-06 13:54:17 -0400 < mnieper> Even C compilers do not achieve this.
2023-04-06 13:54:41 -0400 < mnieper> Although they try hard.
2023-04-06 13:54:55 -0400 < acdw> i'm big in japan
2023-04-06 13:55:45 -0400 < cow_2001> tonight?
2023-04-06 13:55:58 -0400 < mdhughes> Hi Big in Japan, I'm Mark.
2023-04-06 13:56:05 -0400 < cow_2001> oh hi mark
2023-04-06 13:56:17 -0400 < acdw> https://www.youtube.com/watch?v=FVdfDoXHdZc
2023-04-06 13:56:45 -0400 < Zipheir> Funny song.
2023-04-06 13:57:22 -0400 < mnieper> R7RS shouldn't have reverted the safety-guarantees of R6RS.
2023-04-06 13:58:18 -0400 < acdw> great song!
2023-04-06 13:58:42 -0400 < acdw> i am disappointed to find out that r7rs rolled back full utf8 compliance
2023-04-06 13:59:43 -0400 < mdhughes> Yeah, R7's a disappointment all around.
2023-04-06 14:00:10 -0400 < mdhughes> Good news, the best impls don't care, and the supposed R7 impls are often better than the spec.
2023-04-06 14:00:43 -0400 < Zipheir> Obviously enough of the Scheme community liked the pre-R6 situation.
2023-04-06 14:01:40 -0400 < Zipheir> I like a lot of R6RS, but there are reasons it was rejected. We shouldn't pretend that everyone agrees on it, now.
2023-04-06 14:02:05 -0400 < mdhughes> Because lazy impls didn't want to put in any work.
2023-04-06 14:02:32 -0400 < Zipheir> That kind of remark just makes the fragmentation worse.
2023-04-06 14:02:33 -0400 < mdhughes> Well, they're gonna get to do that work to catch up with R7-large.
2023-04-06 14:03:16 -0400 < mdhughes> OH NO I might slightly annoy someone who's making their impl better.
2023-04-06 14:03:22 -0400 < mdhughes> not making
2023-04-06 14:04:41 -0400 < amirouche> sort of
2023-04-06 14:04:41 -0400 < Zipheir> Not everyone has the same idea of "better". Even if you like strict language safety, you might not like R6's way of doing it (and of rolling togething conditions and record types).
2023-04-06 14:04:47 -0400 < amirouche> I have seen worse cheap talk tho
2023-04-06 14:04:49 -0400 < Zipheir> *together
2023-04-06 14:05:55 -0400 < mdhughes> So in R7 you can't trap specific exceptions from I/O or whatever, you have to catch everything, or experimentally catch impl-specific exceptions.
2023-04-06 14:05:57 -0400 < amirouche> Let's talk about the real conundrum... Kernel, a Scheme, when?
2023-04-06 14:06:15 -0400 < mdhughes> Have fun rooting thru the source on your impl and making non-portable code.
2023-04-06 14:06:34 -0400 < Zipheir> I agree, that's a weakness.
2023-04-06 14:07:14 -0400 < jcowan> mnieper: R7RS didn't *revert* anything of R6RS, because it is not a descendant of R6RS.  It did make a few incompatible changes to R5RS, all of them well documented.
2023-04-06 14:07:28 -0400 < Zipheir> I honestly wonder why R7RS-small didn't adopt SRFI 35.
2023-04-06 14:07:58 -0400 < mdhughes> Has Kernel ever been impl'd?
2023-04-06 14:08:22 -0400 < jcowan> Yes, there are two implementations
2023-04-06 14:08:39 -0400 < jcowan> Zipheir: SRFI 35 was incompatible with existing Schemes.
2023-04-06 14:08:53 -0400 < mdhughes> Sure, 5, 6, 5.5, 7… that's a perfectly normal way for Perl people to count.
2023-04-06 14:09:41 -0400 < jcowan> 1 is prime (sort of), 3 is prime, 5 is prime, 7 is prime, 9 is an error, 11 is prime, 13 is prime ... all odd numbers are prime!
2023-04-06 14:10:07 -0400 < Zipheir> jcowan: Was it that Schemes already had their own condition objects that worked differently from SRFI 35 conditions?
2023-04-06 14:10:13 -0400 < jcowan> Yes.
2023-04-06 14:10:34 -0400 < amirouche> mdhughes: there is SRFI-226 :O
2023-04-06 14:10:50 -0400 < jcowan> It took literally years after Guile implemented R6RS before it was possible to catch a native exception with an R6RS expression or vice versa
2023-04-06 14:11:12 -0400 < amirouche> it is though to say kernel is not a scheme, it just have - a lot - of - good - extensions.
2023-04-06 14:11:46 -0400 < Zipheir> jcowan: Thanks.
2023-04-06 14:12:31 -0400 < jcowan> R6RS was even more incompatible than SRFI 35, because it required that conditions be inspectable records.
2023-04-06 14:12:42 -0400 < mdhughes> jcowan: And yet they were aiming at catching up, and did. Even if guile's not my favorite thing, it's put in the work.
2023-04-06 14:13:17 -0400 < jcowan> Andy Wingo basically did it single-handed
2023-04-06 14:13:33 -0400 < jcowan> Unfortunately, there is only one of him
2023-04-06 14:14:26 -0400 < mdhughes> And for people to say "we can't do this one part, so let's abandon UNICODE nobody needs that" is >:(
2023-04-06 14:15:49 -0400 < jcowan> That's not what R7RS says.  It says you can choose the characters you support, but you must use Unicode rules about them.
2023-04-06 14:20:02 -0400 < mdhughes> But you can't rely on it. So I pass Unicode thru R6RS, I know what happens, char-alphabetic? works. R7, no idea. May only work on the ASCII chars like it's 1969.
2023-04-06 14:22:55 -0400 < Zipheir> Writing a standard is not the same thing as designing a language.
2023-04-06 14:23:39 -0400 < mnieper> The Guile problem were not the conditions but the exception system, which R7RS took from R6RS.
2023-04-06 14:24:26 -0400 < mnieper> It is not hard to write a SRFI 35 on top of a native condition hierarchy as long as the native hierarchy is fine-grained enough.
2023-04-06 14:25:18 -0400 < mnieper> Exceptions are caught with with-exception-handler, so you can just exchange the native object with a new one before calling the user-installed handler.
2023-04-06 14:26:03 -0400 < mnieper> By "revert" I meant "taking away what was already standardized".
2023-04-06 14:28:10 -0400 < mnieper> No one probably programs in R7RS-small alone.  It's always R7RS-small+some impl-specific extensions/guarantees.
2023-04-06 14:28:40 -0400  * mdhughes reverts to unconsciousness.
2023-04-06 15:03:17 -0400 < cow_2001> chapter 3.4 is about concurrency
2023-04-06 15:03:25 -0400 < cow_2001> oh boy
2023-04-06 15:04:52 -0400 < cow_2001> and i'm not even half way through
2023-04-06 15:08:16 -0400 < Zipheir> That chapter has some annoying exercises.
2023-04-06 15:16:43 -0400 < cow_2001> i'm still at 3.3
2023-04-06 15:16:50 -0400 < cow_2001> or maybe 3.2, depending on how you count
2023-04-06 15:39:59 -0400 < jcowan> mdhughes: Portability and interoperability are to some extent mutually exclusive.  R6 favors the first, R7 favors the second.
2023-04-06 15:46:08 -0400 < mnieper> Safety guarantees could have been provided without touching interoperability.
2023-04-06 15:48:06 -0400 < mnieper> The main obstacles to interoperability are the module system, the macro system and things like call/cc.
2023-04-06 15:59:06 -0400 < mnieper> I would say it is the module/macro system where interoperability wrt R6 and R7 really differs: As R7 only provides syntax-rules, phasing of libraries is irrelevant and as syntax-rules is also compatible with most low-level macro systems in use, it can be much easier integrated into existing native systems.
2023-04-06 16:00:08 -0400 < mnieper> Any standard that wants to offer more than syntax-rules has to face a decision.
2023-04-06 17:04:54 -0400 < sham1> R7RS-small + impl-specific stuff + SRFIs
2023-04-06 18:13:58 -0400 -!- ced1 is now known as cedb
2023-04-06 18:43:29 -0400 < jcowan> Everyone already has syntax-rules except for the Schemes that don't do macros at all.
2023-04-06 18:43:44 -0400 < jcowan> so syntax-rules is both portable and interoperable
2023-04-06 18:45:36 -0400 < jcowan> "Portability and interoperability are two different things, and often come into conflict with each other. When programming languages are specified, portability can be increased (and interoperability diminished) by inventing some specific semantics for all corner cases while forbidding extensions to standard syntax and procedures. Interoperability can be increased (and portability diminished) by leaving unimportant corner cases unspecified
2023-04-06 18:45:36 -0400 < jcowan> while allowing implementations to generalize syntax and semantics in ways that simplify interoperation with other standards and components."  --Will Clinger
2023-04-06 18:48:49 -0400 < Zipheir> What exactly is interoperability?
2023-04-06 18:49:31 -0400 < Zipheir> Merriam-Webster says "having or using the same parts or equipment".
2023-04-06 18:49:55 -0400 < Zipheir> But that seems to suggest portability, as well.
2023-04-06 19:27:58 -0400 < jcowan> Interoperability is "the ability of different systems, devices, applications or products to connect and communicate in a coordinated way without effort"
2023-04-06 19:28:18 -0400 < jcowan> The Clinger paper gives this example:
2023-04-06 19:29:17 -0400 < jcowan> Consider, for example, the port-position procedure of R6RS Scheme. Its first draft specification, based on a Posix feature that assumes every character is represented by a single byte, would have precluded efficient interoperation with UTF-8, UTF-16, and Windows. Subsequent drafts weakened that specification, increasing interoperability at the expense of allowing port positions to behave somewhat differently on different machines and in
2023-04-06 19:29:17 -0400 < jcowan> different implementations of the standard.
2023-04-06 19:32:07 -0400 < jcowan> Another nice example is the external representation of improper and circular lists.  R7RS systems interoperate with each other in both directions.  However, although an R7RS cannot send an improper/circular list reperesentation to an R6RS system, the converse is not true, because the behavior of  put-datum/write on such lists is not portable; therefore, an R6RS system can write R7RS-compatible improper/circular list datums.
2023-04-06 20:18:33 -0400 < Zipheir> jcowan: Thanks.
2023-04-06 23:23:38 -0400 < mdhughes> I think if the spec's clear, you get exactly the same portability and interop.
2023-04-06 23:24:12 -0400 < mdhughes> But R7 broke those features so you can't rely on even a library form.
2023-04-06 23:25:01 -0400 < mdhughes> I can write R5++ code in a .ss and include it from various .slds for each impl, but it's a pain in the ass.
2023-04-06 23:25:37 -0400 < mdhughes> If I want my code or data to be useful across impls, I have to put more wrappers in the .sld
--- Day changed Fri Apr 07 2023
2023-04-07 00:45:06 -0400 < mdhughes> Also the port-position argument is nonsense, complete prevarication. "If port is a binary port, pos should be a non-negative exact integer object. If port is a textual port, pos should be the return value of a call to port-position on port."
2023-04-07 00:45:53 -0400 < mdhughes> It works just fine on a textual port, it knows that 1 byte != 1 char, but you can't send arbitrary pos.
2023-04-07 00:46:32 -0400 < mdhughes> And there's port-has-port-position? and port-has-set-port-position? to find out if those are even available.
2023-04-07 00:46:50 -0400 < mdhughes> Because of course a stream may not be positionable.
2023-04-07 00:55:06 -0400 < mdhughes> So, let's look at R7RS. What's it have? Oh, right, nothing. If you want to read 1024 bytes/chars mid-file, you loop over read-u8/read-char 1024 times.
2023-04-07 00:55:50 -0400 < mdhughes> https://www.youtube.com/watch?v=KezvwARhBIc
2023-04-07 00:58:19 -0400 < mdhughes> Good luck writing a database or WAD file in R7.
2023-04-07 00:59:25 -0400 < godfather> Hi
2023-04-07 01:00:23 -0400  * mdhughes is am off to make dinner and coffee
2023-04-07 02:51:17 -0400 -!- Noisytoot is now known as Guest808
2023-04-07 02:57:05 -0400 < mnieper> mdhughes makes a number of good points; by reducing what's specified by the standard, you reduce interoperability when you are in a "contravariant" and not in a "covariant" position.
2023-04-07 03:09:44 -0400 < mnieper> From the perspective of some impl'ers I understand why R7RS-small is favored over R6RS because it takes much less time to write an R7RS-small-conformant Scheme than an R6RS-conformant one.
2023-04-07 03:12:46 -0400 < mnieper> What I don't understand is why many Scheme users seem to prefer R7RS-small over R6RS (barring the cases where the impl dictates the standard).  From the perspective of a Scheme programmer, in almost all regards R6RS is an improvement over R7RS-small.
2023-04-07 03:15:10 -0400 < mnieper> (Cond-expand is sometimes cited, but in some sense this is worse than Autoconf and with the tools R6RS gives you (like arbitrary evaluation at expansion time) you can emulate cond-expand if you must, but can also do better.)
2023-04-07 03:15:26 -0400 < amirouche> welcome godfather
2023-04-07 03:16:09 -0400 < mnieper> Good morning, amirouche and godfather!
2023-04-07 03:16:27 -0400 < amirouche> mnieper: what is your position on kernel? Do you think vau could be part of RnRS one day?
2023-04-07 03:16:29 -0400 < mdhughes> A lot of new users to anything just grab whatever the highest number is.
2023-04-07 03:19:36 -0400 < mnieper> mdhughes: Length matters after all?
2023-04-07 03:20:45 -0400 < mdhughes> Guile's still R5++/R6 (almost). Gambit and Gauche have just hit R7-small, *but* both have a much larger R5++ base and non-standard libraries.
2023-04-07 03:21:53 -0400 < mnieper> amirouche: It could become part of a future Scheme dialect, but I doubt that it fits to what's currently known as RnRS because the current dialects describe a mostly static language ("relatively easy" to compile), while Kernel is highly dynamic (and I don't know of any successful try to implement it efficiently).
2023-04-07 03:22:01 -0400 < mdhughes> LispPad's R7-small but really it's all non-standard libraries, the point is to glue together Mac/iOS tech.
2023-04-07 03:22:30 -0400 < amirouche> in other words, you / we need the proof that a Kernel implementation can be efficient
2023-04-07 03:23:22 -0400 < mdhughes> A user picking at random is probably 50% likely to get an R6-ish or R7-ish Scheme.
2023-04-07 03:24:01 -0400 < mnieper> amirouche: Have you ever tried to implement Kernel in Scheme?
2023-04-07 03:25:20 -0400 < mnieper> If you can translate substantial portions of a Kernel program to feed into Scheme's `eval', it will be a successful experiment.
2023-04-07 03:25:30 -0400 < mdhughes> Which of these is any good? https://axisofeval.blogspot.com/2011/09/kernel-underground.html
2023-04-07 03:34:16 -0400 < amirouche> the only one I find ready for more experiment is sink, the interpreter implemented by John N. Shutt
2023-04-07 03:34:48 -0400 < amirouche> mnieper: yes, but I added some more contraints related to tail-calls, and stack management
2023-04-07 03:35:08 -0400 < amirouche> imo, scheme should not expose tail call to the users.
2023-04-07 03:36:03 -0400 < mdhughes> I tried running that, but even in his expected mzscheme it doesn't run.
2023-04-07 03:36:12 -0400 < amirouche> mdhughes: https://github.com/amirouche/seed
2023-04-07 03:36:46 -0400 < amirouche> try: cat main.k | scheme --program seed.scm
2023-04-07 03:36:49 -0400 < amirouche> or
2023-04-07 03:36:57 -0400 < amirouche> try: cat library.snk main.k | scheme --program seed.scm
2023-04-07 03:37:18 -0400 < amirouche> re tail calls, and stack management are ime/imo an implementation detail, any thoughts?
2023-04-07 03:37:58 -0400 < wasamasa> oh wow, finally a legitimate use of cat
2023-04-07 03:38:22 -0400 < amirouche> that is from an user perspective obviously. Regarding the standard, I am not sure what proper wording would be good. I was thinking about something similar to the wording of memory management.
2023-04-07 03:41:16 -0400 < mdhughes> $define! and $lambda are… choices.
2023-04-07 03:41:30 -0400 < wasamasa> yeah
2023-04-07 03:41:33 -0400 < amirouche> yeah
2023-04-07 03:41:42 -0400 < wasamasa> the code in library.snk does look very far from scheme
2023-04-07 03:42:11 -0400 < wasamasa> more imperative than functional
2023-04-07 03:42:51 -0400 < wasamasa> lol, did you seriously hardcode a dependency on letloop
2023-04-07 03:43:11 -0400 < wasamasa> I still get an error 502 from it
2023-04-07 03:44:52 -0400 < amirouche> meh
2023-04-07 03:44:58 -0400 < amirouche> stop being negative :P
2023-04-07 03:46:19 -0400 < wasamasa> look, it's not like I'm going to use your code any time soon, but your code actively preventing me from using it
2023-04-07 03:46:23 -0400 < wasamasa> that's something else
2023-04-07 03:48:13 -0400 < mdhughes> scheme --script seed.scm works just fine.
2023-04-07 03:48:36 -0400 < wasamasa> it's as if someone took my rant about software engineers not being engineers seriously and took it as inspiration
2023-04-07 03:49:19 -0400 < mnieper> amirouche: What is the problem of exposing proper tail calls?
2023-04-07 03:50:02 -0400 < amirouche> wasamasa: you never say something nice
2023-04-07 03:50:05 -0400 < dpk> wasamasa: which rant is that?
2023-04-07 03:50:07 -0400 < mdhughes> At line 4052, insert           	(display "> ")
2023-04-07 03:50:20 -0400 < mnieper> If you don't demand them, a program that should run in bounded space suddenly runs in O(n) space.
2023-04-07 03:51:02 -0400 < amirouche> mnieper: it looks like a nice feature not to have to think about tail call position, in a way that is similar to not have to think about memory management
2023-04-07 03:51:25 -0400 < wasamasa> dpk: basically, you're only allowed to call yourself an engineer if there's consequences when you seriously mess up and a human dies as a result of your incompetence
2023-04-07 03:51:52 -0400 < mnieper> Actually, RnRS doesn't demand enough.  The program (let loop ([x 0]) (unless (= x N) (loop x))) is still allowed to run in O(N) space.
2023-04-07 03:52:26 -0400 < mdhughes> There's audio engineers and you have to *really* fuck up hard to kill someone.
2023-04-07 03:53:19 -0400 < wasamasa> the therac-25 incident is instructional
2023-04-07 03:53:33 -0400 < wasamasa> > Between June 1985 and July 1987, there were six accidents involving the Therac-25, manufactured by Atomic Energy Canada Limited (AECL). Each was a severe radiation overdose, which resulted in serious injuries, maimings, and deaths.
2023-04-07 03:53:40 -0400 < mdhughes> Software engineering's kind of middlin' body count. Therac, sure, and all the people killed by drones and nukes run by software.
2023-04-07 03:53:54 -0400 < mnieper> amirouche: I understand now what you mean but I don't think there is an easy to solution to it because compilers are not that clever (or cannot be).
2023-04-07 03:54:02 -0400 < mdhughes> A few "self-driving" car murders. but mostly it's hard to fuck up software enough to kill anyone.
2023-04-07 03:54:33 -0400 < wasamasa> sure, but overall, the industry does not take itself seriously enough to prevent this
2023-04-07 03:54:45 -0400 < wasamasa> it still feels very young overall and like we're slinging mud at a wall
2023-04-07 03:54:58 -0400 < mnieper> There is this famous sieve of Erathostenes example in Haskell where the "obvious" solution does give you something but not the sieve as far as algorithmic complexity is concerned.
2023-04-07 03:55:06 -0400 < mdhughes> ACM does. I used to be a dues-paying member, and the Ethics statement is very serious.
2023-04-07 03:55:08 -0400 < mnieper> So laziness is similar.
2023-04-07 03:55:10 -0400 < dpk> electrical engineers could be engineers depending what they’re working on, then? designing a motherboard or whatever: no. drive system for a train or electric road vehicle: yes
2023-04-07 03:56:07 -0400 < mdhughes> I think seed.scm needs to catch errors and reroute back into the REPL if it's running interactively.
2023-04-07 03:56:21 -0400 < wasamasa> death by cutting yourself open on a badly manufactured PC case :P
2023-04-07 03:56:34 -0400 < mdhughes> That's mechanical engineering, not our department!
2023-04-07 03:56:39 -0400 < wasamasa> yes, exactly
2023-04-07 03:56:42 -0400 < mnieper> bbs
2023-04-07 03:56:49 -0400 < wasamasa> I still remember my PC case giving me cuts every other time I opened it
2023-04-07 03:57:02 -0400 < mdhughes> Blood sacrifice is how you bind it to you.
2023-04-07 03:57:05 -0400 < wasamasa> I only had laptops ever since
2023-04-07 03:57:43 -0400 < wasamasa> I'm sure there's better formulated rants on the topic of CS being immature
2023-04-07 03:57:52 -0400 < wasamasa> I dimly remember something by Dijkstra on it
2023-04-07 03:58:16 -0400 < dpk> well, i agree the industry is immature. that’s why i left it
2023-04-07 03:58:58 -0400 < mdhughes> … who wrote those in the Dark Ages.
2023-04-07 03:59:18 -0400 < wasamasa> the dark ages of goto?
2023-04-07 03:59:51 -0400 < mdhughes> I like an EWD rant more than most, but he was in a very specific culture and time, lotta FORTRAN and shit around, and had no real experience with LISP, and disliked his friend's use of APL.
2023-04-07 04:00:22 -0400 < wasamasa> if I had to use fortran for something else than entertainment, I'd be angry, too
2023-04-07 04:00:27 -0400 < mdhughes> So take a few salt mines with his advice.
2023-04-07 04:00:39 -0400 < wasamasa> although gfortran is a surprisingly nice compiler compared to gcc
2023-04-07 04:00:58 -0400 < mdhughes> I've written F77 for money. And it's not my favorite thing. Not the worst, either, but I wouldn't do it again.
2023-04-07 04:01:47 -0400 < mnieper> Doesn't gfortran use/isn't gfortran part of the GCC suite?
2023-04-07 04:02:15 -0400 < wasamasa> I'm not talking about the suite, but the compiler
2023-04-07 04:03:14 -0400 < wasamasa> just the fact that gcc and clang are happy to blow your foot off if your code does not take pains to avoid undefined behavior, that alone is reason enough to consider attempts at engineering well-functioning programs with them futile
2023-04-07 04:03:15 -0400 < mnieper> My question was whether the compiler was the same whether you compile C or Fortran (so whether only the frontend differed).
2023-04-07 04:03:29 -0400 < wasamasa> gfortran doesn't do that
2023-04-07 04:04:10 -0400 < mnieper> You will like R6RS.
2023-04-07 04:04:15 -0400 < mnieper> :)
2023-04-07 04:04:17 -0400 < wasamasa> no
2023-04-07 04:04:28 -0400 < wasamasa> the scheme people are not anywhere near close to exploiting this behavior
2023-04-07 04:05:09 -0400 < wasamasa> at best, they're exploiting the capability of the RNRS process to produce incomprehensible documents so that people would rather just use the sample implementation
2023-04-07 04:06:08 -0400 < wasamasa> from what I hear from other people, gcc used to not be nearly as trigger-happy, which explains why lots of real-world code silently degrades when compiled on a recent version of gcc
2023-04-07 04:06:09 -0400 < mnieper> wasamasa: Are you so sure about UB?  Gambit and Chicken use a C backend.  Do they prevent all garbage that goes in from leaking into their backend?
2023-04-07 04:06:12 -0400 < mdhughes> I'm impatient for GNU Modula-2, but alternate langs on GCC vary from producing intermediate code to full ASM output. Clang generates LLVM, which is a lot more consistently compilable/optimizable.
2023-04-07 04:06:43 -0400 < wasamasa> given the CPS mess that the `chicken` executable produces, I'm pretty sure that any source of UB is the FFI
2023-04-07 04:06:57 -0400 < wasamasa> gcc just gives up optimizing it
2023-04-07 04:07:24 -0400 < mnieper> It's optimized to optimize typical C code.
2023-04-07 04:07:27 -0400 < wasamasa> correct
2023-04-07 04:07:33 -0400 < mnieper> Or C++/Fortran/whatever code.
2023-04-07 04:07:48 -0400 < wasamasa> of course gcc will try to optimize it, hence why there's a big source of time differences if I swap out gcc for tcc
2023-04-07 04:08:22 -0400 < wasamasa> I did sometimes run upon bugs in CHICKEN, but it was pretty much the runtime code being unsafe, not my own
2023-04-07 04:08:58 -0400 < mnieper> mdhughes: GCC also has an intermediate language: https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html#GIMPLE
2023-04-07 04:10:00 -0400 < mdhughes> mnieper: Right, but not every front end uses that.
2023-04-07 04:10:09 -0400 < mnieper> wasamasa: GCC's -fsanitize=XXX will be your friend if you have to deal with code bases potentially triggering UB.
2023-04-07 04:10:18 -0400 < wasamasa> so I think R5RS/R7RS implementations are comparable to early gcc in this aspect
2023-04-07 04:10:24 -0400 < mnieper> mdhughes: Then it is not a frontend, is it?
2023-04-07 04:10:40 -0400 < mdhughes> Or didn't, last I looked into it; I haven't had GCC as main compiler on my devices in 10 years.
2023-04-07 04:10:52 -0400 < amirouche> wasamasa: such estimated oss contributor should know the way of the bug tracker
2023-04-07 04:11:11 -0400 < wasamasa> amirouche: sure, I do report bugs here and there
2023-04-07 04:11:11 -0400 < mdhughes> Sure, it's using gcc to parse and produce something, but might be C or ASM or intermediate. It's not consistent.
2023-04-07 04:11:38 -0400 < mnieper> mdhughes: Do you have an example?
2023-04-07 04:12:01 -0400 < wasamasa> amirouche: is the letloop.cloud repo the right place for it?
2023-04-07 04:12:12 -0400 < mdhughes> Pretty sure it was gfortran that was producing ASM, because the C/intermediate was too slow.
2023-04-07 04:12:20 -0400 < wasamasa> amirouche: because strictly speaking, it's for the client, not the backend parts that are erroring out
2023-04-07 04:13:09 -0400 < mdhughes> Tho I much preferred Intel's FORTRAN compiler.
2023-04-07 04:13:10 -0400 < wasamasa> mnieper: ah, good point, gfortran did have something similar for memory bugs and allowed to initialize variables with values of your choosing
2023-04-07 04:13:49 -0400 < mdhughes> Kind of ridiculous perf increase by them "cheating" and using internal opcodes.
2023-04-07 04:14:02 -0400 < wasamasa> lol
2023-04-07 04:14:08 -0400 < wasamasa> sounds like intel alright
2023-04-07 04:21:06 -0400 < wasamasa> amirouche: in any case, I've found an unrelated issue :>
2023-04-07 06:27:08 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-07 08:02:08 -0400 < mnieper> jcowan: Does SRFI 144 give any guarantee that a literal constant like 3.0 evaluates to a flonum?
2023-04-07 08:10:25 -0400 < dpk> my reading says jain
2023-04-07 08:11:06 -0400 < dpk> it seems to say that one of the inexact real precisions implemented by a Scheme will be a flonum
2023-04-07 08:11:20 -0400 < mnieper> That's not helpful for portable code.
2023-04-07 08:11:28 -0400 < dpk> so if there is only one precision as is the case in all Schemes i know of, all inexact reals are flonums
2023-04-07 08:11:54 -0400 < dpk> if there are multiple precisions of inexact reals available, it doesn't specify which precision is a flonum, which is less good, as you say
2023-04-07 08:13:00 -0400 < dpk> so #i3.0 is a flonum in every Scheme available at the moment, but there's no way to write a literal flonum for all possible Schemes in the future which have SRFI 144
2023-04-07 08:13:12 -0400 < mnieper> SRFI 144 should say what it's already in R6RS, namely than an undecorated inexact real literal constant (using only "e" as exponent marker and no "|" (if available)) evaluates to a flonum.
2023-04-07 08:13:26 -0400 < mnieper> By what you say, dpk, this won't clash with any existing implementation.
2023-04-07 08:13:41 -0400 < mnieper> s/than/that
2023-04-07 08:34:20 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-07 08:40:15 -0400 < jcowan> I agree that that sentence ("If x is an external representation of an inexact real number  object and contains no vertical bar and no exponent marker other than e, the inexact real number object it represents is a flonum") should be added to SRFI 144
2023-04-07 08:51:02 -0400 < jcowan> I'm going to go with this version: "Flonums are an implementation-defined subset of the inexact real numbers, such that every such number with the default range and precision is a flonum."
2023-04-07 08:51:20 -0400 < jcowan> I think that covers it without being dependent on the external representation.
2023-04-07 08:53:50 -0400 < jcowan> s/with/representable using
2023-04-07 08:54:20 -0400 < jcowan> mnieper: ^^
2023-04-07 08:57:16 -0400 < mnieper> Is "default range" suitably defined in R7RS?
2023-04-07 09:10:19 -0400 < jcowan> It's defined as being at least as precise as double precision, but exactly what double precision is is not defned.
2023-04-07 09:12:37 -0400 < jcowan> Your loop example is wrong, I think: both "let loop" and "unless" have tail expressions.  (IN any case, it requires infinite time if N is not zero.)
2023-04-07 09:15:02 -0400 < mnieper> jcowan: s/x/(+ x 1)
2023-04-07 09:15:43 -0400 < mnieper> But the real problem is that, formally, each evaluation of the named `let` allocates another location to hold the then current value of `x`.
2023-04-07 09:16:28 -0400 < mnieper> And while the loop is tail-recursive, R[67]RS do not demand GC'ing of locations.
2023-04-07 09:17:13 -0400 < mnieper> The loop example is correct for what I want to demonstrate.
2023-04-07 09:17:55 -0400 < mnieper> The proper tail call guarantee of R[67]RS is nice, but it is not enough to actually conclude tail-loops run in bounded space.
2023-04-07 09:20:49 -0400 < mnieper> The problem is "fresh location" in the description of `lambda`.
2023-04-07 09:22:11 -0400 < mnieper> This is also reflected by the formal semantics (see page 66 of R7RS), where
2023-04-07 09:22:25 -0400 < mnieper> "new" appears in the semantics of `lambda`.
2023-04-07 09:23:53 -0400 < mnieper> jcowan: SRFI 144: "representable = same in the sense of eqv?"?
2023-04-07 09:25:21 -0400 < jcowan> no, the adjective is still wrong:  "expressible" is better
2023-04-07 09:26:15 -0400 < mnieper> And expressible = same-in-the-sense-of-eqv? ?
2023-04-07 09:30:23 -0400 < jcowan> Plainly not, since "X is expressible" cannot mean "X is the same in the sense of eqv?".  The same as what?
2023-04-07 09:36:57 -0400 < mnieper> X expressible using the default range and precision :<=> \exists real Y with default range and precision: (eqv? X Y)   ?
2023-04-07 09:39:55 -0400 < mnieper> I wonder whether the language using literal constants (which includes the results of string->number) is clearer and simpler.
2023-04-07 09:40:05 -0400 < acdw> is eval the best way to resolve a symbol into a value?
2023-04-07 09:41:13 -0400 < mnieper> Can you provide a bit more of a context?
2023-04-07 09:41:17 -0400 < mnieper> acdw: ^^
2023-04-07 09:42:21 -0400 < dTal> I'm imagining (letrec ((a 2) (s 'a)) (eval a))
2023-04-07 09:42:40 -0400 < acdw> like if I have a list of names of functions, what's the best way to call those functions? in a lisp 2 id do funcall. or yeah what dTal said
2023-04-07 09:42:45 -0400 < dTal> (eval s) sorry
2023-04-07 09:43:13 -0400 < mnieper> Scheme's `eval' cannot access the local environment.
2023-04-07 09:43:43 -0400 < mnieper> Every expression in evaluated in some global environment (which you can get by calling the `environment' procedure).
2023-04-07 09:44:01 -0400 < jcowan> Well, since R7RS does not require support for either non-e flags nor vertical bars, it's not very useful.
2023-04-07 09:44:02 -0400 < mnieper> dTal's example doesn't work in Scheme.
2023-04-07 09:44:05 -0400 < acdw> then the list of function thing then
2023-04-07 09:44:53 -0400 < mnieper> What's lexically bound cannot be retrieved at runtime.  The identifiers are erased.
2023-04-07 09:44:53 -0400 < dTal> Yeah okay it works in the top level environment but not in a letrec
2023-04-07 09:45:16 -0400 < mnieper> dTal: `eval' without a second argument is non-standard.
2023-04-07 09:46:03 -0400 < jcowan> This is equally true n CL.
2023-04-07 09:46:44 -0400 < mnieper> Something like (funcall 'car (cons 1 2)) doesn't exist in Scheme.
2023-04-07 09:46:52 -0400 < mnieper> Just write (car (cons 1 2)).
2023-04-07 09:49:48 -0400 < acdw> car has to be the procedure in that example, not the symbol naming the procedure. to resolve it to the procedure so I can apply it, is eval the best thing to do or is there something else?
2023-04-07 09:50:25 -0400 < mnieper> In 95% of the cases, `eval' is not the best thing to do.
2023-04-07 09:50:56 -0400 < mnieper> Where does the symbol "car" comes from in your example?
2023-04-07 09:51:17 -0400 < mnieper> Why don't you pass the procedure directly (instead of its symbolic name)?
2023-04-07 09:53:04 -0400 < mnieper> jcowan: Instead of mentioning non-standard extensions to R7RS, you could just refer to the lexical syntax for numbers given in 7.1.1 of R7RS.
2023-04-07 09:53:14 -0400 < acdw> I have a structure with a list of transformers for source text. right now I pass those in using list but I want to enable the user to customize them using the command line
2023-04-07 09:53:37 -0400 < acdw> so they'd be strings and I know how to convert those to functions
2023-04-07 09:53:42 -0400 < mnieper> jcowan: If an inexact real is denoted by this syntax, it is a flonum.
2023-04-07 09:54:10 -0400 < mnieper> acdw: Use a hash table.
2023-04-07 09:54:27 -0400 < mnieper> Store the symbols with their associated procedures there.
2023-04-07 09:54:58 -0400 < acdw> oh that could work! of course they wouldn't be able to pass any old function... but maybe that's a bad idea lol
2023-04-07 09:55:09 -0400 < mnieper> (funcall x arg* ...) => (apply (assert (hashtable-ref my-env x #f)) arg*)
2023-04-07 09:56:14 -0400 < acdw> awesome thank you
2023-04-07 09:58:42 -0400 < jcowan> I see.  But in any case, there is no guarantee that "3.0" represents an inexact real number.
2023-04-07 09:59:07 -0400 < jcowan> (in either R6 or R7)
2023-04-07 10:01:28 -0400 < mnieper> This is what R6RS says: "If the
2023-04-07 10:01:28 -0400 < mnieper> representation of a number object has no exactness prefix,
2023-04-07 10:01:28 -0400 < mnieper> the constant is inexact if it contains a decimal point, an
2023-04-07 10:01:28 -0400 < mnieper> exponent, or a nonempty mantissa width; otherwise it is
2023-04-07 10:01:32 -0400 < mnieper> exact."
2023-04-07 10:01:38 -0400 < mnieper> 3.0 contains a decimal point.
2023-04-07 10:03:56 -0400 < mnieper> R7RS: "If the written representation
2023-04-07 10:03:56 -0400 < mnieper> of a number has no exactness prefix, the constant is inexact
2023-04-07 10:03:56 -0400 < mnieper> if it contains a decimal point or an exponent. Otherwise,
2023-04-07 10:03:56 -0400 < mnieper> it is exact."
2023-04-07 10:04:10 -0400 < mnieper> So everything looks okay.
2023-04-07 10:11:11 -0400 < mnieper> Or do I miss something?
2023-04-07 10:17:29 -0400 < jcowan> All that says is that if 3.0 is the written representation of a number, it is inexact; but it nowhere says that 3.0 represents a number.
2023-04-07 10:20:27 -0400 < jcowan> 3.4 says "Implementations may support only a limited range of inexact number objects of any type, subject to the requirements of this section."
2023-04-07 10:20:44 -0400 < jcowan> So in principle the range may empty.
2023-04-07 10:21:37 -0400 < mnieper> R6RS defines the external representation for number objects in 4.2.8.
2023-04-07 10:21:54 -0400 < mnieper> According to this definition, "3.0" represents a number object.
2023-04-07 10:22:01 -0400 < sham1> An implementation with no inexact numbers would be very specialised to be useful. Like "running on microcontrollers" specialised
2023-04-07 10:27:56 -0400 < mnieper> jcowan: The range cannot be empty because 3.0 must evaluate some inexact number.  And real->flonum couldn't be defined with an empty range.
2023-04-07 10:28:11 -0400 < mnieper> s/some/to some/
2023-04-07 10:28:57 -0400 < jcowan> Why must it?  Must 3.0e4000 evaluate to some inexact number in the absence of +0.inf?
2023-04-07 10:29:56 -0400 < sham1> I feel that this requirement of making decimal numbers and numbers with exponents into inexact by default is silly
2023-04-07 10:30:16 -0400 < mnieper> (sham1: I think this is what most users would expect.)
2023-04-07 10:30:47 -0400 < sham1> Right, but it also precludes usage on platforms without good inexact representation
2023-04-07 10:31:06 -0400 < mnieper> jcowan: I think so (at least in the context of R6RS), barring raising an implementation-restriction violation.
2023-04-07 10:31:13 -0400 < sham1> Like as I said, microcontrollers, where you might not have an FPU of any kind
2023-04-07 10:32:12 -0400 < jcowan> Okay, so (inexact 3) raises an implementation restriction.
2023-04-07 10:38:21 -0400 < mnieper> I think this is allowed.
2023-04-07 10:38:48 -0400 < mnieper> But I am not sure whether the standard is consistent here.
2023-04-07 10:39:33 -0400 < mnieper> (real->flonum 3) must return a flonum "close" to 3.
2023-04-07 10:40:21 -0400 < mnieper> This flonum is an inexact real, so there is an inexact real "close" to 3.  Ergo, (inexact 3) cannot raise an exception of type &implementation-restriction.
2023-04-07 10:43:43 -0400 < jcowan> Well, if that argument is sound, then it shows that there must be at least one inexact real, say 0.0.
2023-04-07 10:44:05 -0400 < jcowan> Which is a flonum.
2023-04-07 10:46:26 -0400 < mnieper> The argument that there is at least a single inexact is simpler
2023-04-07 10:46:53 -0400 < mnieper> A procedure like real->flonum must have an non-empty codomain (as the domain is non-empty).
2023-04-07 10:47:27 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-07 10:53:58 -0400 < jcowan> At any rate this argument demonstrates that R6RS does not require that 3.0 is the representation of an inexact number object.
2023-04-07 10:55:32 -0400 < ecraven> why must 3.0 be an *inexact* number?
2023-04-07 10:55:44 -0400 < ecraven> why can't (some) flonums be exact?
2023-04-07 11:06:44 -0400 < mnieper> jcowan: It *is* a representation of an inexact number object in R6RS.  Only evaluation of such a constant could raise an exception.
2023-04-07 11:08:17 -0400 < mnieper> Anyway, this is besides the point of the SRFI 144 issue.  When I write 0.0 (and 0.0 is in the range my impl supports), I expect it to be a flonum.
2023-04-07 11:09:23 -0400 < mnieper> ecraven: By definition, flonums are inexact reals.
2023-04-07 11:09:33 -0400 < mnieper> (Definition = R6RS/SRFI 144)
2023-04-07 11:13:34 -0400 < gwatt> i'd imagine it also depends on your representation. If you have actual multi-precision floating point maybe it's feasible to have exact reals, but IEEE floating point can't even be trusted to exactly represent integers above 2^53
2023-04-07 11:16:09 -0400 < mnieper> #e3.0 is an exact real.
2023-04-07 11:17:10 -0400 < gwatt> erm, I meant exact reals that are also flonums
2023-04-07 11:19:21 -0400 < mnieper> These implementations would have to give these objects a different name if they want to remain compatible to R6RS/SRFI 144.
2023-04-07 11:19:33 -0400 < mnieper> s/want/wanted
2023-04-07 16:37:50 -0400 < mnieper> What are the 32-bit systems that still have a future?  Recently we talked about tagging here, and most of the tagging systems were invented when 32 bit systems still had to be supported.  I wonder whether one would design them differently today, taking advantage of more bits and stricter alignments.
2023-04-07 16:45:36 -0400 < dpk> 32-bit ARM is probably not going away for a while, due to embedded uses
2023-04-07 16:50:00 -0400 < mnieper> Okay, we should leave out the Schemes that are designed for embedded use (are there any?).
2023-04-07 16:52:18 -0400 < mnieper> For example, would you redesign Chicken's tagging system today? https://www.more-magic.net/posts/internals-data-representation.html
2023-04-07 16:52:42 -0400 < mnieper> (checking again tomorrow)
2023-04-07 16:55:23 -0400 < dpk> Armpit Scheme is made for ARM-based microcontrollers
2023-04-07 18:11:00 -0400 < gwatt> My company uses stm32 boards as real-time controllers for some hardware. Not using shceme though
--- Day changed Sat Apr 08 2023
2023-04-08 01:09:06 -0400 < mdhughes> Embedded, and there's still 32-bit Windows, yes?
2023-04-08 01:45:53 -0400 < mnieper> MS dropped 32-bit support for Windows AFAIK.
2023-04-08 03:42:36 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-08 03:51:27 -0400 < mdhughes> Best I can tell, they no longer ship 32-bit Win10 to OEMs, but you can still buy it to reinstall, and they support it.
2023-04-08 03:52:45 -0400 < mdhughes> Win11 is 64-bit only.
2023-04-08 10:39:49 -0400 < cow_2001> oh no https://codereview.stackexchange.com/questions/75172/split-string-for-r7rs
2023-04-08 10:51:33 -0400 < Zipheir> That's pretty old.
2023-04-08 10:53:51 -0400 < Zipheir> I don't know what they mean about there being no "efficient portable solution". Splitting a string, portably or not, involves allocating a bunch of new strings, unless you're using immutable strings.
2023-04-08 10:57:27 -0400 < Zipheir> (Or you're using an implementation that does CoW, I guess.)
2023-04-08 10:58:24 -0400 < cow_2001> i've found the Proust book! https://cs.uwaterloo.ca/~plragde/flaneries/LACI/Introduction.html
2023-04-08 11:02:41 -0400 < mnieper> The efficiency issue in that split-string question is about `string-ref'.
2023-04-08 11:03:06 -0400 < mnieper> Splitting a string at a delimiter should be at most O(n) in time.
2023-04-08 11:03:55 -0400 < mnieper> Without an O(1) guarantee of `string-ref', coding `split-string' in R7RS in not obvious as there is no `string-fold'.
2023-04-08 11:04:36 -0400 < Zipheir> Ah, OK. I thought they were arguing about space.
2023-04-08 11:05:14 -0400 < Zipheir> String ports seem like the best portable solution, then.
2023-04-08 11:05:51 -0400 < Zipheir> We *presume* that those aren't implemented with string-ref. :)
2023-04-08 11:06:11 -0400 < mnieper> One should measure the overhead of string ports.
2023-04-08 11:07:01 -0400 < mnieper> And compare it with list->string/string->list.
2023-04-08 11:08:25 -0400 < Zipheir> Yes.
2023-04-08 11:08:36 -0400 < mnieper> Or string-for-each and call/cc to short-circuit.
2023-04-08 11:09:19 -0400 < Zipheir> Now that's what I call a Schemely idea.
2023-04-08 11:09:33 -0400 < mnieper> BTW, is string-fold actually implementable in terms of string-for-each and set!?
2023-04-08 11:09:49 -0400 < Zipheir> I'm tempted to try.
2023-04-08 11:10:04 -0400 < mnieper> My first guess is that the mutation will leak.
2023-04-08 11:10:27 -0400 < Zipheir> Would fluid-let or similar do the trick?
2023-04-08 11:10:41 -0400 < mnieper> Not fluid-let, but liquid-let.
2023-04-08 11:10:58 -0400 < mnieper> But this assumes the existence of delimited continuations.
2023-04-08 11:12:01 -0400 < mnieper> fluid-let (like parameterize) doesn't allow to record a change across iterations.
2023-04-08 11:21:44 -0400 < Zipheir> I guess I don't understand the difference between fluid and liquid well enough.
2023-04-08 11:25:05 -0400 < mnieper> Fluids are just a syntactical variation of parameters.  Both have dynamic extent.
2023-04-08 11:25:33 -0400 < mnieper> Mutations to them, I mean.
2023-04-08 11:25:56 -0400 < mnieper> A parameterize inside for-each won't help you to maintain an accumulator.
2023-04-08 11:27:04 -0400 < mnieper> SRFI 39 allows changes to parameters to have indefinite extent (by calling them with one argument), but works basically like set! and exposes mutation.
2023-04-08 11:27:48 -0400 < mnieper> If you change a liquid, on the other hand, its value will be restored when continuations captured earlier are reinstated.
2023-04-08 11:30:03 -0400 < Zipheir> Thanks. I think I understand.
2023-04-08 11:31:05 -0400 < Zipheir> I suppose the goal of fluid-let and parameterize was to provide something like dynamic binding, not to avoid state leaks.
2023-04-08 11:31:07 -0400 < mnieper> The values of all liquids are part of the current continuation so to speak.
2023-04-08 12:56:45 -0400 < cow_2001> people should just write programs that work and then worry about overhead :|
2023-04-08 12:56:52 -0400 < cow_2001> be like a dog!
2023-04-08 12:57:40 -0400 < Zipheir> Sacrificing comprehensibility and simplicity for performance is a favorite pastime of programmers.
2023-04-08 12:58:00 -0400 < cow_2001> https://www.youtube.com/watch?v=7MX7pIuTNsw
2023-04-08 12:58:29 -0400 < cow_2001> i want to live by the wise words of limmy but sadly i do not
2023-04-08 13:01:08 -0400 < Zipheir> The late Joe Armstrong made a good point: "If you *really* want to make your program faster, it's simple: just wait ten years for the hardware to improve."
2023-04-08 13:01:33 -0400 < Zipheir> In the long run, maybe it's only algorithmic complexity that matters.
2023-04-08 13:01:34 -0400 < jcowan> Or wait 20 years and there will be no need for the program at all.
2023-04-08 13:01:47 -0400 < jcowan> "In the long run, we are all dead."
2023-04-08 13:02:02 -0400 < Zipheir> That's the ultimate in lazy evaluation.
2023-04-08 13:02:09 -0400 < mdhughes> In a billion years, the Sun expands and destroys your hardware.
2023-04-08 13:03:09 -0400 < Zipheir> Seriously, though, the benefits of software optimization are dwarfed by those of hardware improvements.
2023-04-08 13:03:51 -0400 < mdhughes> No so true anymore, Moore's law is in decline and may soon reverse.
2023-04-08 13:03:59 -0400 < Zipheir> True.
2023-04-08 13:04:14 -0400 < Zipheir> But computers are getting smaller.
2023-04-08 13:04:21 -0400 < mdhughes> Power costs rise, and even with more efficient CPUs like ARM, you might have to ration your power a lot more.
2023-04-08 13:06:00 -0400 < Zipheir> Sussman says the future is in propagators, and the Great Quux says it's in massively parallel functional programming.
2023-04-08 13:06:53 -0400 < Zipheir> At least, that's how I interpret what they've been saying.
2023-04-08 13:07:49 -0400 < Zipheir> And logic programming is an island in the setting sun.
2023-04-08 13:08:53 -0400 < mdhughes> Transmission costs, time, & data syncing make very parallel programming inefficient. Not a lot of languages even try to help with the problem.
2023-04-08 13:10:23 -0400 < cow_2001> Death The Ultimate
2023-04-08 13:11:05 -0400 < Zipheir> Hence Steele's emphasis on operations with nice algebraic properties. See, e.g., "How to Think About Parallelism--NOT!" https://www.youtube.com/watch?v=dPK6t7echuA
2023-04-08 13:12:12 -0400 < Zipheir> I think Fortress died (or was killed by Oracle), unfortunately.
2023-04-08 13:13:12 -0400 < cow_2001> wtf?! ocaml appeared in 1996?!
2023-04-08 13:13:47 -0400 < cow_2001> even after python
2023-04-08 13:14:37 -0400 < Zipheir> That makes sense. 1996 seems like the high water mark of the object-oriented fad.
2023-04-08 13:15:44 -0400 < cow_2001> i thought ocaml is sort of like haskell
2023-04-08 13:16:18 -0400 < Zipheir> They are both descended from ML.
2023-04-08 13:17:01 -0400 < Zipheir> Which, like Scheme, goes back to the early '70s.
2023-04-08 13:24:37 -0400 < cow_2001> and i thought object oriented is still strong
2023-04-08 13:26:38 -0400 < cow_2001> strong as in popular, not as in a good way of building anything, which i am too ignorant to judge
2023-04-08 13:26:38 -0400 < cow_2001> oh, the o in ocaml is literally "objective"
2023-04-08 13:26:39 -0400 < Zipheir> It's still ubiquitous in mainstream languages, but I think its popularity has been waning since the early aughts.
2023-04-08 13:27:36 -0400 < Zipheir> Look at a computer magazine from 1995 and see how many times "Java" appears on the front.
2023-04-08 13:28:01 -0400 < Zipheir> (Now, I guess, it's more "oh, more java...")
2023-04-08 13:31:37 -0400 < Zipheir> OOP encompasses a lot of different ideas and, also, a ton of jargon. I think the ideas have stayed and matured, but the jargon is (thankfully) going away.
2023-04-08 13:31:55 -0400 < gwatt> I think it's more that thinking about object oriented programming has changed. For a while everything was about Classical Inheritance.
2023-04-08 13:33:06 -0400 < mdhughes> You can't blame what happened with Java on Java or OOP. It's Andersen Consulting that did that.
2023-04-08 13:33:29 -0400 < gwatt> I don't know who that is
2023-04-08 13:34:30 -0400 < mdhughes> They're an IBM-trained pump-and-dump consulting company, uh, called "Accenture" now.
2023-04-08 13:35:20 -0400 < mdhughes> They underbid on giant projects, produce unbelievably awful work, then get paid again to "fix" it over and over until you're driven out of business. If it's a gov't contract, good news! They can't go out of business, just waste tax dollars forever.
2023-04-08 13:36:28 -0400 < mdhughes> You know the WidgetFactoryFactoryFactory jokes? That's not a joke. That's a dark pattern they invented, along with a lot of others, that facilitate dumping thousands of shitty consultants on a project.
2023-04-08 13:38:29 -0400 < mdhughes> Actual Java used sanely, can be… OK. It's fine, certainly better than writing C++. The scam is making Eclipse and then using that to scale up more idiots hitting Next on a wizard.
2023-04-08 13:40:32 -0400 < Zipheir> That reminds me a bit of the Bjarne Stroustroup "interview" about his real reasons for inventing C++.
2023-04-08 13:41:47 -0400 < wasamasa> there are in fact projects using Java sanely
2023-04-08 13:41:49 -0400 < mdhughes> I can believe C++ was a joke. I just can't figure out what kind of sick bastard would invent Swift.
2023-04-08 13:42:05 -0400 < wasamasa> their standard library for example has its moments of clarity
2023-04-08 13:42:32 -0400 < wasamasa> or the minimal stuff hackers produce for exploiting Java stuff
2023-04-08 13:42:57 -0400 < wasamasa> or things that need to be fast
2023-04-08 13:42:58 -0400 < Zipheir> A Little Java, A Few Patterns is a book of sane Java.
2023-04-08 13:43:52 -0400 < jcowan> Zipheir: link to this "interview"?
2023-04-08 13:44:36 -0400 < Zipheir> jcowan: It's mildly amusing. http://harmful.cat-v.org/software/c++/I_did_it_for_you_all
2023-04-08 13:47:42 -0400 < jcowan> Mildly is the word
2023-04-08 13:48:05 -0400 < cow_2001> i am happy to have joined this channel. :|
2023-04-08 13:48:48 -0400 < wasamasa> why, what's the matter
2023-04-08 13:49:09 -0400 < cow_2001> because i get all these stories
2023-04-08 13:49:27 -0400 < cow_2001> weird trivia of computing. it's fun.
2023-04-08 13:49:38 -0400 < wasamasa> why that emote then
2023-04-08 13:49:46 -0400 < cow_2001> i like it :|
2023-04-08 13:50:11 -0400 < cow_2001> <_<
2023-04-08 13:51:39 -0400 < Zipheir> Spock's only emote.
2023-04-08 13:52:01 -0400 < cow_2001> this is how i read text on my android phone http://0x0.st/HX2E.txt
2023-04-08 13:52:22 -0400 < cow_2001> with fbreader's text to speech
2023-04-08 14:05:44 -0400 < cow_2001> oh, so it was a fake
2023-04-08 14:05:51 -0400 < cow_2001> satire
2023-04-08 14:05:58 -0400 < mdhughes> IS IT, tho?
2023-04-08 14:06:15 -0400 < mdhughes> Nothing non-factual is ever said in that interview.
2023-04-08 14:06:35 -0400 < cow_2001> :|
2023-04-08 14:11:34 -0400 < cow_2001> "Quite frankly, even if  the choice of C were to do *nothing* but keep the C++ programmers out,  that in itself would be a huge reason to use C."
2023-04-08 14:12:15 -0400 < cow_2001> the recent addition of the `curl | sudo sh` installed rustlang pops to mind
2023-04-08 14:15:03 -0400 < mnieper> Costs of different programming languages: https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf
2023-04-08 14:16:05 -0400 < mnieper> You can wait 10 years until your program runs at one tenth of the time, or you can run 10 of your programs at the same time.
2023-04-08 14:18:41 -0400 < mnieper> The workload on our notebooks may not be relevant, but for something of the scale of Google or ChatGPT, the efficiency of the code makes a huge difference in environmental impact.
2023-04-08 14:19:17 -0400 < mdhughes> Clearly the solution from that test is to switch to Pascal.
2023-04-08 14:20:54 -0400 < mdhughes> I think they didn't run LuaJit, and I wonder about their "Lisp", SBCL with or without compiler, or what?
2023-04-08 14:24:54 -0400 < mdhughes> Energy efficiency on individual devices does matter; by definition they're less efficient than a big data center with centralized, conditioned power.
2023-04-08 14:25:33 -0400 < mdhughes> I expect a significant portion of some cities' grid load are individual computers, running Chrome and C++ programs.
2023-04-08 14:32:07 -0400 < cow_2001> huh. it had a non-pc page https://web.archive.org/web/20190809040556/http://harmful.cat-v.org:80/political-correctness
2023-04-08 14:32:17 -0400 < cow_2001> weird
2023-04-08 14:58:58 -0400 -!- mdhughes_ is now known as mdhughes
2023-04-08 16:09:40 -0400 < Zipheir> cow_2001: Interesting that the maintainer deleted that. That site's author died over 10 years ago.
2023-04-08 16:13:56 -0400 < Zipheir> It still has the quotes page, which is good reading. http://quotes.cat-v.org/programming/
2023-04-08 16:16:08 -0400 < cow_2001> 10 years ago :(
2023-04-08 16:16:23 -0400 < cow_2001> over
2023-04-08 16:16:58 -0400 < cow_2001> is that a wee case of memoryholing?
2023-04-08 16:18:50 -0400 < Zipheir> I suppose. uriel had some strong opinions (nothing heinous, IMO), but I think they should either preserve his site as it was or leave it to the Wayback Machine.
2023-04-08 16:22:15 -0400 < cow_2001> having opinions? we can't have that. to say nothing about expressing them publicly
2023-04-08 16:26:26 -0400 < Zipheir> Now, Erik Naggum may end up completely memory-holed. :)
2023-04-08 16:53:39 -0400 < cow_2001> wiki: Much of what he wrote was so full of sarcasm and irony that it could be difficult to understand what he truly believed in and what were general exaggerations made just to make a point.
2023-04-08 18:42:17 -0400 < tomhg> Hey. Happy eastern. Wishing you a close time with your fellows and tasks. *leaves*.
2023-04-08 23:57:56 -0400 < mdhughes> I love that Naggum existed so we have a measurable upper bound on being a dick.
2023-04-08 23:59:14 -0400 < mdhughes> He's the real reason LISP isn't popular. AI winter, curse of LISP, nope. One jerk on USENET could do a lot more damage and scare off any newbies.
--- Day changed Sun Apr 09 2023
2023-04-09 00:03:55 -0400 < mdhughes> It's weird CL didn't go full-in on Windows, tho. Both made by Unix-haters/not-understanders, VAX community pretty much all ended up on Windows.
2023-04-09 00:04:35 -0400 < mdhughes> Anyway. Coffee/breakfast then try to get back on topic.
2023-04-09 02:10:56 -0400 < Zipheir> Anger problems. His rants start out insightfully and spiral into incoherent rage.
2023-04-09 02:19:39 -0400 < mdhughes> Just grabbed a random post from the archive, starts with: didn't your parents feed you enough for your brain to develop?
2023-04-09 03:07:15 -0400 < Zipheir> They *sometimes* start out insightfully. :-/
2023-04-09 03:15:55 -0400 < Zipheir> His kind of antics wouldn't fly in any well-moderated channel today. Some parts of the old Internet weren't great.
2023-04-09 03:16:15 -0400 < Zipheir> Until tomorrow.
2023-04-09 03:16:21 -0400 < Zipheir> (Goodnight.)
2023-04-09 03:20:54 -0400 < mdhughes> We hadn't developed Cock-Punch-Over-IP yet, so people could start conversations like that.
2023-04-09 05:03:11 -0400 < aeth> pretty much every obscure, non-corporate language is Linux first
2023-04-09 05:03:20 -0400 < aeth> probably because Linux is/was the hobbyist OS
2023-04-09 05:04:14 -0400 < aeth> also, Windows and macOS each have their own languages that they push
2023-04-09 05:08:47 -0400 < aeth> oh, and probably because Linux is where you go where you really, really want control (some obscure tiling window manager or whatever) and that probably overlaps heavily with someone who makes their own programming language (or just implementation)
2023-04-09 05:14:55 -0400 < mdhughes> You mean Windows first. They still get the vast majority of developer money, and proprietary dev tools are all Windows-first/only.
2023-04-09 05:15:53 -0400 < mdhughes> Linux is home to some open-source things, and brainfuck and every other tiny joke lang, yes. And older obscure stuff. But even then, which Linux? Does it work on your distro?
2023-04-09 05:16:42 -0400 < mdhughes> Python's the best example here. Totally open source. Primary installer is for Windows, most of the docs & books are Windows first. Lutz doesn't know a command line unless it's cmd.exe
2023-04-09 05:18:58 -0400 < aeth> nah, if you want to see stuff that are genuinely Windows-first or even Windows-only, then just look at gamedev related stuff
2023-04-09 05:19:10 -0400 < aeth> goes way beyond installers
2023-04-09 05:19:30 -0400 < aeth> especially Python, where they almost certainly assume you already have it installed if you're not using Windows
2023-04-09 05:21:01 -0400 < aeth> and a lot of programming ecosystems are basically "just run Linux" (via WSL, which is why Microsoft made it in the first place)
2023-04-09 05:24:06 -0400 < aeth> Also, Python's downloader/installer is localized to whatever OS you're using (like most download pages), and the docs (unless they also use that sort of thing) seem to assume Unix. https://docs.python.org/3/tutorial/interpreter.html
2023-04-09 05:24:34 -0400 < aeth> "The Python interpreter is usually installed as /usr/local/bin/python3.11 on those machines where it is available; putting /usr/local/bin in your Unix shell’s search path..."
2023-04-09 05:27:33 -0400 < aeth> But clearly you know more than Microsoft, which spent a lot of resources on making WSL (two very different versions of it!) to address this very issue.
2023-04-09 05:32:01 -0400 < aeth> This is also probably why Microsoft spent resources on making VS Code, buying Github, making TypeScript, etc.
2023-04-09 05:36:03 -0400 < mdhughes> Every Python demo starts "apt python10 on ubuntu or pkg add python10 on arch or..." (no I don't care if I got those right)
2023-04-09 05:37:02 -0400 < mdhughes> WSL is embrace-extend-extinguish for Linux.
2023-04-09 05:37:37 -0400 < aeth> yes, just like OS/2
2023-04-09 05:38:27 -0400 < aeth> anyway, the programming ecosystem stuff that are almost entirely Windows-based that aren't related to MS languages are games stuff
2023-04-09 05:38:55 -0400 < aeth> probably because people prefer DX to OpenGL and because you're not missing much if you don't support Linux/Mac
2023-04-09 06:27:10 -0400 < wasamasa> even that is slowly changing though
2023-04-09 06:27:44 -0400 < wasamasa> thanks to people increasingly using engines that abstract all this stuff away
2023-04-09 06:27:56 -0400 < wasamasa> it feels like 50% of the games in my steam library use unity3d
2023-04-09 06:27:59 -0400 < wasamasa> it's ridiculous
2023-04-09 06:28:14 -0400 < dave0> bubble bobble is the best
2023-04-09 06:31:40 -0400 < mdhughes> Web tech and Unity have really brought the age of Flash games back.
2023-04-09 06:48:28 -0400 < wasamasa> well indeed
2023-04-09 06:48:36 -0400 < wasamasa> I wouldn't have expected C# to win
2023-04-09 06:48:46 -0400 < wasamasa> by virtue of everyone hating java applets
2023-04-09 07:14:11 -0400 < mdhughes> Fucking Oracle killed SUN and has been a bad steward, so the switch to Java WebStart never really happened.
2023-04-09 07:14:45 -0400 < mdhughes> Applets are suicidally dangerous because they use an open classloader. Whee, anyone can insert any code into your system.
2023-04-09 07:17:18 -0400 < sham1> Oracle's stewardship has been a mixed bag. I mean, Java WebStart getting essentially axed is sad but Oracle along with the other vendors (Including Microsoft incidentally enough) are doing some very nice things, like Project Loom and such
2023-04-09 07:17:52 -0400 < sham1> After adopting the 6-month release cycle the language has evolved quite rapidly
2023-04-09 07:20:14 -0400 < sham1> Part of Project Loom for example is giving Java essentially delimited continuations
2023-04-09 07:21:01 -0400 < mdhughes> I hate rapid language development, it's a scam to make you constantly rewrite your code and be beholden to a corporate master.
2023-04-09 07:21:50 -0400 < mdhughes> Like JS, where the ever-updating spec means you have to be current Chrome, or Safari or Firefox are 6-12 months "behind" if they want to be cautious and take security seriously.
2023-04-09 07:22:43 -0400 < mdhughes> Java 2 was pretty good. Really they should've stopped the language dev there. Made minor library fixes as needed.
2023-04-09 07:23:30 -0400 < mdhughes> Anon Inner Classes are an OK way to do lambdas, it's fine just really verbose.
2023-04-09 07:29:53 -0400 < mdhughes> Note also my feelings about Scheme revisions.
2023-04-09 07:31:35 -0400 < wasamasa> we should have stopped at R4RS?
2023-04-09 07:31:40 -0400 < mdhughes> But Swift is the worst of these. My Swift code broke on every single version.
2023-04-09 07:31:41 -0400 < mdhughes> https://docs.swift.org/swift-book/documentation/the-swift-programming-language/compatibility
2023-04-09 07:31:49 -0400 < wasamasa> lol
2023-04-09 07:32:08 -0400 < mdhughes> I'm OK with a decade or so per version.
2023-04-09 07:33:18 -0400 < mdhughes> Probably some new features are needed. R4RS lack of records, hashtables is pretty annoying, but you can make them with macros, because R4 has real macros.
2023-04-09 07:34:51 -0400 < mdhughes> Lack of libraries and Unicode (just barely existed before R4 was published) are more significant. R6 really stuck the landing on both.
2023-04-09 08:22:02 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-09 11:30:17 -0400 < cow_2001> okay, reading LACI and a lot of it goes way above my brain.
2023-04-09 11:38:12 -0400 < cow_2001> today i've learned that modus ponens is if A, and A implies B, then B
2023-04-09 11:40:44 -0400 < cow_2001> i guess my parents did not feed me enough for my brain to develop
2023-04-09 11:45:42 -0400 < Irvise_> LACI?
2023-04-09 11:49:18 -0400 < jcowan> mdhughes: R4RS did not standardize macros
2023-04-09 11:50:04 -0400 < mdhughes> > This appendix describes an extension to Scheme that al- lows programs to define and use new derived expression types. A derived expression type that has been defined using this extension is called a macro.
2023-04-09 11:50:24 -0400 < mdhughes> It is technically not in the main body of the spec, but it's in R4RS.
2023-04-09 11:53:36 -0400 < sham1> The later specs also have real macros
2023-04-09 11:53:48 -0400 < sham1> Maybe not procedural, but very much real
2023-04-09 11:54:53 -0400 < mdhughes> R3: > Scheme does not have any standard facility for defining new kinds of expressions. The ability to alter the syntax of the language creates numerous problems.
2023-04-09 11:55:25 -0400 < mdhughes> Well, shit, I can create numerous problems with just functions. May as well have the nice stuff, too.
2023-04-09 11:59:36 -0400 < cow_2001> Irvise_: he calls it a "stroll" https://cs.uwaterloo.ca/~plragde/flaneries/LACI/
2023-04-09 12:01:01 -0400 < cow_2001> a flânerie
2023-04-09 12:17:44 -0400 < Irvise_> cow_2001: neat, I did not know of this book. Thank you!
2023-04-09 12:24:49 -0400 < cow_2001> :D
2023-04-09 12:25:48 -0400 < cow_2001> Irvise_: a bit about its pedagogy https://youtu.be/jimmGDcTx4Y
2023-04-09 12:26:42 -0400 < cow_2001> (and other stuff, i don't remember)
2023-04-09 12:29:28 -0400 < cow_2001> i wish they haven't moved to lean in their global effort to codify math and stuck with coq just so i can hear mathematicians seriously talk about coq
2023-04-09 12:35:53 -0400 < Irvise_> Thanks for the link, I'll watch it :)
2023-04-09 12:36:46 -0400 < Irvise_> If you are intro proves and types, I would recommend Ada + SPARK for that ;) https://learn.adacore.com/
2023-04-09 12:37:06 -0400  * Irvise_ is extremely biased towards Ada/SPARK.
2023-04-09 12:37:06 -0400 < cow_2001> another talk. don't know if there is anything covered here that isn't in the racketcon one https://youtu.be/LQhn71FSLOw
2023-04-09 12:38:03 -0400 < Irvise_> I find the fusion between Ada and Scheme to be the best out there :P
2023-04-09 12:39:28 -0400 < cow_2001> there is a fusion?
2023-04-09 12:40:15 -0400 < cow_2001> i haven't finished k&r. was somewhere at the reverse polish calculator
2023-04-09 12:40:41 -0400 < jcowan> Of course, Lisp REPLs are forward polish calculators.
2023-04-09 12:40:49 -0400 < cow_2001> what i am trying to say is that i am not very good with lower level stuff
2023-04-09 12:41:15 -0400 < cow_2001> i am not very good with any level stuff, but this one in particular
2023-04-09 12:47:29 -0400 < Irvise_> By fusion I mean the combined use of Ada/SPARK and Scheme. Each for their own strenghts.
2023-04-09 12:54:53 -0400 < cow_2001> oh oops.
2023-04-09 12:55:27 -0400 < cow_2001> this makes me nostalgic for pascal
2023-04-09 13:40:45 -0400 < Zipheir> mnieper: Our discussion yesterday has me wondering if some kind of portable string cursor library could be done with captured continuations from a string traversal.
2023-04-09 13:41:42 -0400 < Zipheir> I think it's possible, but traversing backwards from a cursor seems very difficult.
2023-04-09 15:55:24 -0400 < mnieper> Zipheir: It would probably be more efficient if the cursor were implemented as a pair of lists.
2023-04-09 15:55:55 -0400 < mnieper> Moving from left to right would move the top element of the right list to the top of the left list.
2023-04-09 16:03:47 -0400 < Zipheir> Sounds like a zipper.
2023-04-09 16:04:53 -0400 < Zipheir> That's another good idea. Those StackExchange folks who said "there's no efficient portable solution" to string operations weren't thinking hard enough.
2023-04-09 16:19:40 -0400 < mnieper> Compared to O(1) string-ref, it is not very space-efficient.
2023-04-09 16:20:15 -0400 < mnieper> Ah, didn't know that two lists in such a situations are called a zipper.  Thanks.
2023-04-09 17:05:49 -0400 < Zipheir> With zipper-cursors, string-ref should still be O(1) in space, right? Creating the cursor (with string-cursor-start, or whatever) that's O(n).
2023-04-09 17:06:20 -0400 < Zipheir> It's obviously a waste of space compared to byte-offset cursors, but it is portable.
2023-04-09 17:06:34 -0400 < mnieper> I meant the constant before the O(1). :)
2023-04-09 17:07:43 -0400 < mnieper> If you don't care about it, just do string->list and list->string everywhere. :)
2023-04-09 17:09:51 -0400 < Zipheir> Oh, and here's Huet's original paper on zippers https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf  He states that it's probably an old, undocumented trick for "pure" traversals.
2023-04-09 17:10:34 -0400 < Zipheir> Well, this is *one* (minor) case in which Haskell's strings-are-character-lists design makes things easier.
2023-04-09 17:13:58 -0400 < jcowan> Except nobody in Haskell uses that kind of strings much any more.
2023-04-09 17:15:49 -0400 < Zipheir> The standard hasn't caught up, though.
2023-04-09 17:16:30 -0400 < Zipheir> (It may be a losing battle to pretend that GHC Haskell isn't the de facto standard.)
2023-04-09 18:46:39 -0400 < jcowan> It seems to be intentional.  The difference between Haskell 98 and Haskell 2010 is five new features (one of them named but not documented) and two removed features.  Pretty feeble.
2023-04-09 18:48:45 -0400 < jcowan> Apparently there were supposed to be annual reports after that, but in fact the next report (which didn't materialize as a report, just a GHC feature bundle) wasn't until 2021.
2023-04-09 19:07:24 -0400 < Zipheir> Pretty unfortunate.
--- Day changed Mon Apr 10 2023
2023-04-10 02:42:55 -0400 < lockywolf> wasamasa: we should have just stopped
2023-04-10 03:23:46 -0400 -!- mode/#scheme [+o Zipheir] by ChanServ
2023-04-10 03:27:15 -0400 -!- mode/#scheme [-o Zipheir] by ChanServ
2023-04-10 03:27:26 -0400 < Zipheir> Hopefully grettke has stopped bouncing.
2023-04-10 04:26:41 -0400 < lockywolf> dpk: you don't have https on nonceword.org, do you?
2023-04-10 04:54:52 -0400 < dpk> no
2023-04-10 04:55:19 -0400 < dpk> i'm curious what on earth is on that domain which you want to access via HTTPS :D
2023-04-10 04:55:33 -0400 < dpk> there's nothing there except the silly landing page with the Alice quote
2023-04-10 05:04:30 -0400 < wasamasa> but what if someone insisted on using HTTPS for everything
2023-04-10 05:35:29 -0400 < lockywolf> dpk: there are also ads :)
2023-04-10 06:28:35 -0400 < dpk> lockywolf: not put there by me
2023-04-10 06:29:43 -0400 < sham1> I think that's the entire point. That it'd be good to make it https as to not have ads put in by ISPs and the like
2023-04-10 06:31:09 -0400 < dpk> i refer the right honourable gentleman to http://n-gate.com/software/2017/07/12/0/
2023-04-10 06:34:26 -0400 < sham1> The thing that's very offensive to me about that ngate page is that the text is in comic sans
2023-04-10 06:34:44 -0400 < sham1> We indeed can't both be right, and this is just disgusting
2023-04-10 06:34:51 -0400 < lockywolf> What do Schemers think about sexp syntaxes for Python? which one is better, sexpy or hylang?
2023-04-10 06:35:04 -0400 < sham1> Band-aid
2023-04-10 06:35:21 -0400 < sham1> While you might gain a nicer syntax, you're still working with python fundamentally
2023-04-10 06:35:45 -0400 < lockywolf> https://pypi.org/project/bandaid/ ?
2023-04-10 06:36:14 -0400 < sham1> I meant that hy and such is a bandaid over Python's real issues
2023-04-10 06:46:24 -0400 < sham1> Arguing about syntax is like the greatest case of bikeshedding you can really have
2023-04-10 08:28:47 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-10 09:09:38 -0400 < pinoaffe> yes and no: as long as one single colour is picked, it doesn't really matter which, but if someone wants to paint the shed in a hideous amalgamation of mismatched colours, it would be horrible to have to look at it all day
2023-04-10 10:32:49 -0400 < jcowan> I have a lot of bookshelves covering two walls.  The color mismatch of the book spines has never bothered me.
2023-04-10 10:33:02 -0400 < jcowan> (THough I know there are people who buy books by color and size)
2023-04-10 10:33:50 -0400 < jcowan> pinoaffe: ^^
2023-04-10 10:34:31 -0400 < jcowan> Anyway, macros (which is the main point of sexp notations) are precisely bandaids.
2023-04-10 10:34:50 -0400 < jcowan> But we like them anyway
2023-04-10 11:36:15 -0400 < Zipheir> "I just want leather-bound books to go with my leather-upholstered furniture. These say £25, so I'll take them." "Are they leather-bound pounds?" "What?" "I need leather-bound pounds to go with my leather wallet." (Black Books)
2023-04-10 11:36:36 -0400 < acdw> lmao
2023-04-10 11:41:11 -0400 < Zipheir> Hah, I forgot that line. "They're real leather?" "They're real Dickens." https://www.youtube.com/watch?v=lllUSIUJE4M
2023-04-10 13:03:58 -0400 < jcowan> There is a (fictional) legal case about Mr. Haddock, who paid his taxes by writing a cheque on the side of a cow
2023-04-10 13:04:31 -0400 < jcowan> To the London and Literary Bank, Limited
2023-04-10 13:04:31 -0400 < jcowan> Pay the Collector of Taxes, who is no gentleman, or Order, the sum of fifty seven pounds £57/0/0 (and may he rot!)
2023-04-10 13:04:31 -0400 < jcowan> ALBERT HADDOCK
2023-04-10 13:05:38 -0400 < jcowan> https://en.wikipedia.org/wiki/Board_of_Inland_Revenue_v_Haddock
2023-04-10 13:19:42 -0400 < mnieper> jcowan: Macros work best with some kind of regular syntax, but the syntax need not be given by s-expressions.
2023-04-10 13:22:29 -0400 < jcowan> In principle, no.
2023-04-10 13:23:50 -0400 < jcowan> dpk: Needless to say, I agree with 100% of that page.  However, I foresee a future in which all browsers cease to support HTTP because all ISPs are compromised.
2023-04-10 13:33:55 -0400 < mdhughes> That would make developing web software pretty hard.
2023-04-10 13:34:20 -0400 < mdhughes> But the current warn-insecure could get even stronger, like a dialog the first time you hit any such site.
2023-04-10 13:37:12 -0400 < Zipheir> I think the n-gate response to the "content integrity" argument is poor: "If people don't want to see my site with random trash inserted into it, they can choose not to access it through broken and/or compromised networks." That may involve leaving your country, which your government may not like even if you can afford it.
2023-04-10 13:39:06 -0400 < Zipheir> It's not a serious argument, but a list of stubborn talking points. "I don't wanna do it, so here's something that sounds like a rebuttal".
2023-04-10 13:39:59 -0400 < jcowan> mdhughes: That wouldn't affect developing web software, just deploying it.
2023-04-10 13:40:22 -0400 < mdhughes> VPNs are real things.
2023-04-10 13:40:40 -0400 < mdhughes> And almost nobody puts an SSL cert on their localhost.
2023-04-10 13:42:33 -0400 < mdhughes> Deploying, nobody has a hard time getting https up anymore. I barely care and it took me like 15 minutes first time to get my dev site secured.
2023-04-10 13:43:27 -0400 < jcowan> When Chrome, Edge, Firefox stop supporting HTTP, people's computers will probably come with certs already installed for localhost use.
2023-04-10 13:44:23 -0400 < mdhughes> Well that's just fine for me, since I use Safari.
2023-04-10 13:44:46 -0400 < mdhughes> (or WebKitNightly, if I'm adventurous)
2023-04-10 13:45:58 -0400 < jcowan> Sure, and for some purposes I use Dillo.  But then you are no longer publishing, you are "privating".
2023-04-10 13:46:02 -0400 < dpk> mdhughes: aiui browsers already have some kind of recognition that localhost connections are secure even over HTTP, even if they don't show the 🔒
2023-04-10 13:46:19 -0400 < Zipheir> Everything's going to be Chromium with a skin, at this rate.
2023-04-10 13:48:16 -0400 < dpk> jcowan: i fear you are right, but we are still thankfully some way from that happening
2023-04-10 13:48:54 -0400 < mdhughes> Also, while n-gate was a fun regular diatribe on h4xx0rz n00z by our much-esteemed leader of all paren-based languages PG, it's been defunct for 2 years now.
2023-04-10 13:52:21 -0400 < Zipheir> Perhaps a better response to the integrity argument is that HTTPS Everywhere just shifts the battle to a new field. If you're on a compromised network, you have to use their browser app or certificate chain.
2023-04-10 13:53:42 -0400 < Zipheir> In the extreme, you only get to use devices certified by The Good Guys.
2023-04-10 13:54:32 -0400 < Zipheir> That's not currently a good argument against providing HTTPS, of course.
2023-04-10 13:55:57 -0400 < Zipheir> (Allegedly, the old Windows 7 Vietnamese language pack came with a government-required keylogger. It's not that far-fetched.)
2023-04-10 13:57:44 -0400 < mnieper> Zipheir: That sounds like what Apple is doing (to some extent).  People seem to be happy with it.
2023-04-10 14:02:13 -0400 < cow_2001> consider every two algorithms f and g, expressed in lambda calculus, for which every input x, f(x) = g(x). can f and g have two different lambda calculus normal forms?
2023-04-10 14:02:39 -0400 < cow_2001> i suspect that bubblesort and quicksort would have two different normal forms
2023-04-10 14:02:45 -0400 < cow_2001> <_<
2023-04-10 14:03:08 -0400 < cow_2001> they are two different computations
2023-04-10 14:03:47 -0400 < cow_2001> but is it really so? i don't know for a fact it is
2023-04-10 14:03:57 -0400 < cow_2001> i may be wrong
2023-04-10 14:04:30 -0400 < cow_2001> i may also be misunderstanding lambda calculus normal form
2023-04-10 14:30:59 -0400 < cow_2001> i wish i could stick types on top of definitions :|
2023-04-10 14:31:37 -0400 < cow_2001> i was fighting with some bug in this simple exercise for a whole hour until i found that i missed an argument
2023-04-10 14:32:03 -0400 < cow_2001> well, maybe i should have ran the code outside of srfi-64's test-equal
2023-04-10 14:32:11 -0400 < cow_2001> that might have solved the problem
2023-04-10 14:32:38 -0400 < cow_2001> it was one of the recursion calls where i forgot to add one of the arguments i added to the definition
2023-04-10 14:33:30 -0400 < cow_2001> (define (f a b c) ... (f a b c) ...) to (define (f z a b c) ... (f a b c) ...)
2023-04-10 15:23:18 -0400 < Zipheir> "If you have a procedure with ten parameters, you probably missed some." (Perlis epigram #11)
2023-04-10 15:26:49 -0400 < cow_2001> ~;~
2023-04-10 15:27:08 -0400 < cow_2001> i was just following orders!
2023-04-10 15:27:26 -0400 < cow_2001> exercises 1.30 to 1.33
2023-04-10 15:29:03 -0400 < cow_2001> the last one was (define (filtered-accumulate predicate? combiner bull-value term a next b) …)
2023-04-10 15:29:14 -0400 < cow_2001> null--value
2023-04-10 15:29:18 -0400 < cow_2001> err
2023-04-10 15:30:31 -0400 < cow_2001> https://git.sr.ht/~kakafarm/sicp/tree/master/item/sicp/solutions/1_33.scm#L12
2023-04-10 16:13:46 -0400 < jcowan> "bull-value" is good.  I was half wondering if this was an attempt to solve bull-cow games
2023-04-10 16:41:02 -0400 < sham1> 10-argument procedures… at some point you start to wonder whether you either want keywords or a builder pattern. Probably both depending on the situation
2023-04-10 16:41:29 -0400 < acdw> maybe smaller functions
2023-04-10 16:41:34 -0400 < acdw> tho idk what a builder pattern is
2023-04-10 16:42:17 -0400 < sham1> Of course, smaller procedures is an option for most things
2023-04-10 16:42:53 -0400 < acdw> indeet
2023-04-10 16:44:36 -0400 < Zipheir> sham1: Another option is a structured argument (e.g. "configuration" records).
2023-04-10 16:44:38 -0400 < sham1> As for the builder pattern, coming from an OO background, I'd think something like the following would work: (chain (complex-operation-initial-arg-object 'params) (complex-operation-foo 'value-foo _) (complex-operation-bar 'value-bar _) … (complex-operation-execute _))
2023-04-10 16:45:00 -0400 < acdw> oh
2023-04-10 16:45:17 -0400 < acdw> i think i tend toward structured arguments
2023-04-10 16:45:24 -0400 < Zipheir> Dynamically-bound parameters are another (blunt-edged) approach.
2023-04-10 16:45:25 -0400 < sham1> Zipheir: this'd basically be that except that you'd construct the configuration record "piecewise" in some sense
2023-04-10 16:45:27 -0400 < dpk> we have a monad SRFI for this :D
2023-04-10 16:45:37 -0400 < Zipheir> Also state monads.
2023-04-10 16:45:38 -0400 < dpk> https://srfi.schemers.org/srfi-165/srfi-165.html
2023-04-10 16:45:50 -0400 < Zipheir> sham1: That makes sense.
2023-04-10 16:46:30 -0400 < acdw> are scheme monads more like open face sandwiches
2023-04-10 16:46:53 -0400 < sham1> For example I'd do something like the following for Scheme-esque process spawning
2023-04-10 16:48:09 -0400 < sham1> (chain (process-spawner-program-from-path "ls") (process-spawner-args "-lh" _) (process-spawner-spawn _) (process-spawner-get-ouput _)) ; or something like this, I haven't exactly thought this through
2023-04-10 16:49:17 -0400 < sham1> Of course, for the "add arguments for the process spawner" the spawner would have to be the first argument, so more like (process-spawner-add-args _ "-lh") but I suppose you get the gist
2023-04-10 16:50:57 -0400 < sham1> One might also imagine more "complex" operations like "add this port as the input/output/error of this process" or whatever
2023-04-10 16:51:31 -0400 < Zipheir> acdw: They're like monads everywhere. The syntactic sugare is a bit different, though; things like 'computation-with' are not idiomatic to me (yet).
2023-04-10 16:51:45 -0400 < Zipheir> *sugar
2023-04-10 16:51:56 -0400 < acdw> mm yeah. i mean i never got .. the math of monads really
2023-04-10 16:52:15 -0400 < acdw> tho i spose i've made some in scheme .... like, the chaining things thorugh and if it's #f it short-circuites
2023-04-10 16:52:21 -0400 < Zipheir> The idea is simple, but there are a lot of foundations.
2023-04-10 16:52:39 -0400 < Zipheir> Most functional programmers have invented the maybe and state monads.
2023-04-10 16:53:04 -0400 < Zipheir> cf. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
2023-04-10 16:54:20 -0400 < Zipheir> "In fact, faced with various problems in functional programming you would have been led, inexorably, to certain solutions, all of which are examples of monads."
2023-04-10 16:55:42 -0400 < sham1> Except for the name "monad"
2023-04-10 16:56:54 -0400 < Zipheir> Yes. Unless you're a Leibniz fan.
2023-04-10 17:00:25 -0400 < acdw> monad, more like gonad amirite
2023-04-10 17:58:38 -0400 < cow_2001> i am so sorry https://cat-milk.github.io/Anime-Girls-Holding-Programming-Books/
2023-04-10 17:58:47 -0400 < acdw> are ye tho
2023-04-10 17:59:11 -0400 < cow_2001> Well………
2023-04-10 18:00:06 -0400 < cow_2001> no scheme or guile or chaz or………
2023-04-10 18:00:16 -0400 < cow_2001> oh, there is lisp
2023-04-10 18:48:33 -0400 -!- drewdomi is now known as DrewDomi
2023-04-10 18:48:38 -0400 -!- DrewDomi is now known as drewdomi
2023-04-10 18:48:41 -0400 -!- drewdomi is now known as DrewDomi
2023-04-10 18:48:43 -0400 -!- DrewDomi is now known as drewdomi
2023-04-10 18:52:09 -0400  * tomhg is very occupied. Hopefully you lovely schemers had a good eastern. Hopefully I am IRC-cloaked. Will see you in a bit; Let me know if I am giving myself away via IRC.
2023-04-10 19:16:38 -0400 < drewdomi> hello everyone!!
2023-04-10 21:22:05 -0400 < lockywolf> Is there some http library for Scheme? Like python-requests?
2023-04-10 21:22:35 -0400 < lockywolf> I think, snow-chibi is just wrapping around curl, which is acceptable, but maybe there is something better?
2023-04-10 21:33:39 -0400 -!- devmsv_ is now known as devmsv
2023-04-10 21:45:43 -0400 < mdhughes> For http, I open a socket; https, curl is just a lot easier.
2023-04-10 22:06:20 -0400 -!- devmsv_ is now known as devmsv
2023-04-10 22:26:43 -0400 -!- devmsv_ is now known as devmsv
--- Day changed Tue Apr 11 2023
2023-04-11 07:40:01 -0400 < drewdomi> Hello!!
2023-04-11 07:40:12 -0400 < mnieper> Hi!
2023-04-11 07:41:18 -0400 < drewdomi> before I read SICP is it better read Simply Scheme?
2023-04-11 07:44:00 -0400 < drewdomi> mnieper, ???
2023-04-11 07:44:34 -0400 < mnieper> You mean this: https://doc.lagout.org/programmation/Lisp/Scheme/Simply%20Scheme%20Introducing%20Computer%20Science%202d%20ed%20-%20Brian%20Harvey%20%2C%20Matthew%20Wright.pdf?
2023-04-11 07:44:35 -0400 < rudybot> https://teensy.info/ekYywQkjxV
2023-04-11 07:47:12 -0400 < drewdomi> mnieper, yes
2023-04-11 07:47:12 -0400 < mnieper> Why don't you try to read SICP (slowly) and work through the exercises first?  If you really get stuck, you can take a step back or ask here.
2023-04-11 07:47:20 -0400 < mnieper> Depends on your background, of course.
2023-04-11 07:47:44 -0400 < drewdomi> my background is Javascript, lol
2023-04-11 07:47:54 -0400 < mnieper> Which is not necessarily bad!
2023-04-11 07:48:14 -0400 < drewdomi> YEAH, two function languages
2023-04-11 07:48:25 -0400 < drewdomi> the paradim is the same
2023-04-11 07:49:43 -0400 < mnieper> If you want to learn Scheme as a practical programming language, you should also take a look at "The Scheme Programming Language": https://www.scheme.com/tspl4/.
2023-04-11 07:50:06 -0400 < wasamasa> JS is certainly not a "function language"
2023-04-11 07:50:22 -0400 < mnieper> I think they meant "functional".
2023-04-11 07:50:32 -0400 < wasamasa> dysfunctional perhaps
2023-04-11 07:50:36 -0400 < drewdomi> yes, i write wrong
2023-04-11 07:50:46 -0400 < drewdomi> its functional
2023-04-11 07:50:57 -0400 < wasamasa> not at all
2023-04-11 07:51:05 -0400 < mnieper> drewdomi: For TSPL, Chez Scheme probably works best to try out the examples and work at the REPL.
2023-04-11 07:51:05 -0400 < wasamasa> it has closures, that's seemingly it
2023-04-11 07:51:49 -0400 < wasamasa> while you can write it in such a style, it's first and foremost a prototype-based object-oriented language
2023-04-11 07:51:50 -0400 < mnieper> wasamasa: It has functions as first class objects, so you can easily program in a functional style in Javascript.
2023-04-11 07:52:01 -0400 < wasamasa> which means it's a multi-paradigmatic language
2023-04-11 07:52:17 -0400 < wasamasa> so very different from languages where functional style is the default or the only way of doing things
2023-04-11 07:52:37 -0400 < mnieper> wasamasa: Under your strict definition, Scheme is neither a functional language.
2023-04-11 07:52:44 -0400 < drewdomi> you can code in different styles with JS
2023-04-11 07:52:52 -0400 < wasamasa> scheme is an example of "functional style is the default"
2023-04-11 07:53:07 -0400 < jobol> TLSP is using R6RS? no?
2023-04-11 07:53:11 -0400 < mnieper> wasamasa: That depends on the programmer.
2023-04-11 07:53:24 -0400 < mnieper> jobol: Yes, which is not a bad thing.
2023-04-11 07:53:27 -0400 < wasamasa> if you take all the scheme code out there, you'll reach the conclusion the programmers not doing that are in the minority
2023-04-11 07:53:33 -0400 < wasamasa> hence functional style is the default
2023-04-11 07:54:15 -0400 < jobol> mnieper, it is not compatible with R7RS
2023-04-11 07:54:17 -0400 < mnieper> wasamasa: If you take all JS programmers minus the script kiddies and "frontend developers", who knows what the numbers then are.
2023-04-11 07:54:30 -0400 < wasamasa> if you're being biased, yes, you get biased results
2023-04-11 07:54:35 -0400 < wasamasa> but those people count, too
2023-04-11 07:54:40 -0400 < mnieper> jobol: Mostly.  But R7RS(-small) is not the measure-stick anyway.
2023-04-11 07:54:46 -0400 < wasamasa> they're legitimate programmers
2023-04-11 07:54:55 -0400 < wasamasa> despite how you may feel about them
2023-04-11 07:55:40 -0400 < mnieper> jobol: It took me some time to appreciate this, but I came to the conclusion that R6RS is the better programming language than R7RS-small.  (And it is more advanced and expressive.)
2023-04-11 07:56:38 -0400 < mnieper> wasamasa: What I wanted to point out is that categorizing a programming language by what the majority of programmers do with it, is not that useful.
2023-04-11 07:56:49 -0400 < wasamasa> it absolutely is, you avoid disappointments
2023-04-11 07:57:04 -0400 < drewdomi> The last scheme update is 10 years ago?, is it a problem?
2023-04-11 07:57:08 -0400 < wasamasa> like, if you expect JS to be anywhere like scheme, you're in for a big disappointment
2023-04-11 07:57:52 -0400 < mnieper> wasamasa: Assume that Scheme suddenly becomes mainstream and someone develops a hyper-super-duper-cool OOP system for it... could this mean that Scheme is no longer as "functional" as it currently is?
2023-04-11 07:58:05 -0400 < mnieper> drewdomi: No problem.
2023-04-11 07:58:32 -0400 < wasamasa> probably not, because you'd need to convince everyone else to use it because the existing code is unlikely to change to that OOP style
2023-04-11 07:58:32 -0400 < mnieper> The last big change in the C programming language happened 1999.
2023-04-11 07:58:49 -0400 < mnieper> Smaller changes since then.
2023-04-11 07:58:52 -0400 < jobol> mnieper, R6RS lieded to R7RS(-small) for good reasons too
2023-04-11 07:59:01 -0400 < jobol> led?
2023-04-11 07:59:03 -0400 < wasamasa> hence why languages usually get stuck in their initial design phase
2023-04-11 07:59:07 -0400 < wasamasa> people hate change
2023-04-11 07:59:31 -0400 < wasamasa> even something as comparatively small as being disciplined about text vs bytes in the python2->python3 transition
2023-04-11 07:59:50 -0400 < wasamasa> or R5RS->R6RS, lol
2023-04-11 08:00:11 -0400 < wasamasa> if that led to big time dispute, I doubt an OOP system will make the cut
2023-04-11 08:00:48 -0400 < mnieper> jobol: led.  If you reread the arguments that were raised against R6RS, you will eventually see that many of them were based on misconceptions.
2023-04-11 08:01:08 -0400 < mnieper> wasamasa: The OOP system would be provided as a library.
2023-04-11 08:01:26 -0400 < wasamasa> yes, so what?
2023-04-11 08:01:36 -0400 < wasamasa> the same thing can be said about all features outside the standard
2023-04-11 08:02:00 -0400 < wasamasa> if they can be provided as a library, they probably should
2023-04-11 08:03:02 -0400 < wasamasa> I think one of the mistakes is assuming it's purely about technical reasons and ignoring the social ones
2023-04-11 08:03:06 -0400 < mnieper> wasamasa: My argument was that such a library and a new majority of new Scheme programmers ("assuming Scheme becomes a mainstream language") could change a lot.  Not among us, of course.
2023-04-11 08:03:55 -0400 < wasamasa> suppose the mainstream language happened, I don't think it would be under the existing "Scheme" name
2023-04-11 08:03:57 -0400 < mnieper> In any case, SICP also exists in a JS version: https://sourceacademy.org/sicpjs/index
2023-04-11 08:04:10 -0400 < mnieper> drewdomi: Might also be interesting for you: ^^
2023-04-11 08:04:14 -0400 < wasamasa> yes, in an impressively tortured style
2023-04-11 08:04:27 -0400 < wasamasa> using ternary because if is not an expression, lol
2023-04-11 08:04:46 -0400 < mnieper> wasamasa: I think your attitude is too negative.
2023-04-11 08:04:49 -0400 < wasamasa> it's kind of a parody of the statement that code should be readable and incidentally executable
2023-04-11 08:05:26 -0400 < mnieper> You don't have to convince me that Scheme is better.
2023-04-11 08:06:12 -0400 < wasamasa> they could have at least tried to write idiomatic JS and explain how it's different, rather than pretending it's scheme
2023-04-11 08:06:27 -0400 < wasamasa> but then the resulting book wouldn't be SICP
2023-04-11 08:09:25 -0400 < drewdomi> I think I will read the second edition in scheme
2023-04-11 08:09:44 -0400 < drewdomi> because i want to know this world in LISP, lol
2023-04-11 08:10:02 -0400 < wasamasa> note that writing lisp in allcaps has been obsolete for like 50 years
2023-04-11 08:10:17 -0400 < mnieper> drewdomi: As to the Scheme standards: R6RS is from 2007; R7RS(small) is from 2013.  The more advanced and precise standard is R6RS.  An R7RS(large) encompassing R7RS(small) and R6RS is planned.  The universally agreed upon standard is R5RS (or even R4RS).  Both R6RS and R7RS(small) are successors to R5RS.
2023-04-11 08:10:49 -0400 < drewdomi> too old, lol
2023-04-11 08:11:01 -0400 < wasamasa> your use of "LISP" is too old
2023-04-11 08:11:15 -0400 < drewdomi> ahhh
2023-04-11 08:11:31 -0400 < drewdomi> lisp is newer so?
2023-04-11 08:12:12 -0400 < wasamasa> for example scheme stopped this allcaps business in the 70ies
2023-04-11 08:14:08 -0400 < drewdomi> is there something make an maintained is scheme?
2023-04-11 08:14:10 -0400 < mnieper> drewdomi: Different implementations support different standards (but, thankfully, they are not too different so if you learn one dialect, understand the other is easy).  I use Chez Scheme (an R6RS implementation) because it is one if not the most efficient Scheme implementation (sometimes by a magnitude) and has been very carefully written and tested.  (As a topping, it supports native threads.)
2023-04-11 08:15:36 -0400 < mnieper> drewdomi: I can't parse your question.
2023-04-11 08:16:16 -0400 < jobol> guile 3 is also a good choice for starting
2023-04-11 08:17:31 -0400 < mnieper> It doesn't have the same quality as Chez, though.
2023-04-11 08:18:47 -0400 < mnieper> To be fair, one should add that Chez started its life as a commercial compiler, so probably a lot more money (developer hours) went into it than into other impls.
2023-04-11 08:22:44 -0400 < wasamasa> drewdomi: to be fair, the standard being stable means there is a lot less churn going on compared to stuff like JS
2023-04-11 08:23:33 -0400 < wasamasa> drewdomi: the bigger problem is that the communities are rather balkanized, so you end up having to DIY when you run out of existing solutions
2023-04-11 08:24:15 -0400 < mnieper> The good point wrt less churn going on is that you won't feel you have to rewrite your program every 2 years because things are then done "differently"/
2023-04-11 08:24:22 -0400 < mnieper> s//./
2023-04-11 08:24:30 -0400 < mnieper> (whatever)
2023-04-11 08:25:20 -0400 < drewdomi> okay
2023-04-11 08:25:54 -0400 < drewdomi> I think I understand
2023-04-11 08:25:57 -0400 < mnieper> wasamasa: That's why I like implementations that warn you when you don't write standard-compliant code (and that don't encourage you to like Guile, for example).  It should lead to less balkanization.
2023-04-11 08:27:05 -0400 < drewdomi> if I learn scheme I can use it in a bunch of dialets of lisp, the core is the almost the same
2023-04-11 08:27:13 -0400 < drewdomi> it's like C C++ C#
2023-04-11 08:27:45 -0400 < mnieper> Even closer.
2023-04-11 08:28:17 -0400 < mnieper> More like C89 and C11, say.
2023-04-11 08:28:37 -0400 < mnieper> s/C89/K&R C
2023-04-11 08:29:21 -0400 < drewdomi> okay, comcepts is the same
2023-04-11 08:30:19 -0400 < drewdomi> in the guile bibliography there's the SICP
2023-04-11 08:30:26 -0400 < mnieper> You can add Racket to the mix.
2023-04-11 08:30:43 -0400 < drewdomi> racket is great
2023-04-11 08:31:06 -0400 < drewdomi> i will use DrRacket to code in scheme
2023-04-11 08:31:14 -0400 < drewdomi> with the #lang/scheme
2023-04-11 08:31:20 -0400 < mnieper> It supports R5RS and R6RS out of the box.
2023-04-11 08:31:59 -0400 < drewdomi> thanks guys
2023-04-11 08:32:06 -0400 < mnieper> For SICP, use #lang sicp
2023-04-11 08:32:16 -0400 < drewdomi> i will study a lot now, lol
2023-04-11 09:08:28 -0400 < cow_2001> so the best way to learn an ISO C is K&R, right?
2023-04-11 09:08:43 -0400 < cow_2001> i've been somewhere in the rpn calc
2023-04-11 09:09:42 -0400 < cow_2001> drewdomi: i'm doing sicp right now!
2023-04-11 09:22:33 -0400 < cow_2001> drewdomi: good luck!
2023-04-11 09:39:13 -0400 < cow_2001> does learning ada makes one think low levely the same way as c?
2023-04-11 09:40:05 -0400 < drewdomi> cow_2001, thanks
2023-04-11 09:40:11 -0400 < cow_2001> c is extremely popular while ada looks to me very niche
2023-04-11 09:40:29 -0400 < wasamasa> no, they're fundamentally different languages
2023-04-11 09:40:41 -0400 < wasamasa> ada very much feels like pascal, but with a significantly more expressive type system
2023-04-11 09:40:56 -0400 < wasamasa> C plays fast and loose with semantics
2023-04-11 09:41:25 -0400 < cow_2001> you can if (anything_at_all) {…}
2023-04-11 09:41:37 -0400 < wasamasa> while you could try to use ada to write general-purpose software, the ecosystem is significantly tilted towards paying customers
2023-04-11 09:41:48 -0400 < cow_2001> "towards paying customers"
2023-04-11 09:41:51 -0400 < wasamasa> yup
2023-04-11 09:42:00 -0400 < cow_2001> shoot! i won't starve :(
2023-04-11 09:42:52 -0400 < wasamasa> https://www.adacore.com/about-spark
2023-04-11 09:43:09 -0400 < wasamasa> note the big pricing button
2023-04-11 09:43:52 -0400 < Irvise_> wasamasa: Ada(Core) is changing :) they are opening a ton of tools and they have ditched their own toolchain. GCC/GNAT is the way to go.
2023-04-11 09:44:04 -0400 < Irvise_> SPARK is also 1000000% open ;)
2023-04-11 09:44:29 -0400 < cow_2001> wait wait, you mean that the tools are priced? i thought it's all about consulting
2023-04-11 09:44:40 -0400 < wasamasa> there are pro versions of them
2023-04-11 09:44:44 -0400 < cow_2001> oh no
2023-04-11 09:44:52 -0400 < cow_2001> like pycharm
2023-04-11 09:44:56 -0400 < Irvise_> cow_2001: re: low-level Ada. No, Ada abstracts hardware away like a champ. It is, imho, much much better than C at low level stuff.
2023-04-11 09:45:10 -0400 < Irvise_> The IDE is also open :)
2023-04-11 09:45:28 -0400 < wasamasa> it's much like the open core business model you see with stuff like gitlab
2023-04-11 09:45:39 -0400 < cow_2001> :|
2023-04-11 09:45:58 -0400 < Irvise_> It is true that a PRO version exists (LTS, advance toolchains, advance analysis tools, private beta testing...)
2023-04-11 09:46:48 -0400 < cow_2001> no exceptions
2023-04-11 09:46:54 -0400 < cow_2001> in spark pro
2023-04-11 09:47:03 -0400  * cow_2001 raises fist
2023-04-11 09:47:15 -0400 < cow_2001> i HATE those damned runtime exceptions!
2023-04-11 09:47:43 -0400 < Irvise_> https://github.com/AdaCore/gnat-llvm
2023-04-11 09:47:44 -0400 < Irvise_> https://github.com/AdaCore/spark2014
2023-04-11 09:47:44 -0400 < Irvise_> https://github.com/AdaCore/gnatstudio
2023-04-11 09:47:46 -0400 < cow_2001> why even build a language with exceptions where things explode
2023-04-11 09:48:10 -0400 < Irvise_> SPARK does allow local exception handling nowdays.
2023-04-11 09:49:21 -0400 < Irvise_> What wasamasa quotes used to be true. But in the past few years, they have loosend their hand toward (true) open source a lot. They even started switching some.of their major libraries from GPLv3 to Apache v2 ^^
2023-04-11 10:12:05 -0400 < Irvise_> cow_2001: some exception do happen. For example, memory allocation may fail. SPARK uses execption for force the correct (or at least intentional and explicit) handling of such error. That is why dynamic memory allocation used to be forbidden in safety critical applications.
2023-04-11 10:13:23 -0400 < cow_2001> rocket ships go boom
2023-04-11 10:13:46 -0400 < cow_2001> i hear elon put javascript on his control panels
2023-04-11 10:18:27 -0400 < drakonis> https://twitter.com/atomicthumbs/status/1032939617404645376 relevant
2023-04-11 10:18:49 -0400 < drakonis> https://nitter.net/atomicthumbs/status/1032939617404645376 this url is better
2023-04-11 10:21:56 -0400 < cow_2001> such sights to show us ~;~
2023-04-11 10:22:36 -0400 < cow_2001> yeah, nitter is so much easier to read
2023-04-11 10:23:25 -0400 < cow_2001> i love this Pinhead quote
2023-04-11 10:23:36 -0400 < cow_2001> i try to use it whenever i can
2023-04-11 10:26:25 -0400 < mnieper> Irvise_: switching from GPL to Apache may mean less open source in the long run.
2023-04-11 10:57:32 -0400 < Irvise_> I am aware. But most complaints towards AdaCore were related to their strict GPL-only policy. All they published, from compilers to low level tools was GPL-only (not even LGPL).
2023-04-11 11:15:04 -0400 < cow_2001> how do i walk / list directories in a standard way?
2023-04-11 11:16:24 -0400 < wasamasa> you check the SRFIs for this
2023-04-11 11:16:38 -0400 < wasamasa> then you realize there is no usable implementation of the SRFI you need
2023-04-11 11:16:52 -0400 < wasamasa> then you start writing a SRFI for directory manipulation
2023-04-11 11:17:21 -0400 < cow_2001> :|
2023-04-11 11:17:39 -0400 < cow_2001> ~;~
2023-04-11 11:17:39 -0400 < wasamasa> I'm specifically referring to SRFI-170
2023-04-11 11:18:16 -0400 < wasamasa> hm, gauche, loko and stklos claim to implement this
2023-04-11 11:18:26 -0400 < wasamasa> gauche perhaps, the other two I cannot really imagine to implement this
2023-04-11 11:18:28 -0400 < cow_2001> are you one of the authors O_O?
2023-04-11 11:18:31 -0400 < wasamasa> no
2023-04-11 11:18:39 -0400 < wasamasa> I do not understand POSIX nearly well enough
2023-04-11 11:19:06 -0400 < wasamasa> it's just one of these recurring patterns when people ask about writing portable scheme code
2023-04-11 11:19:21 -0400 < cow_2001> posix is portable enough
2023-04-11 11:19:26 -0400 < wasamasa> yes, but scheme isn't
2023-04-11 11:20:00 -0400 < wasamasa> what you could do instead is use cond-expand and implementation-specific features
2023-04-11 11:20:20 -0400 < cow_2001> "no code for module (srfi srfi-170)" D:<
2023-04-11 11:20:27 -0400 < gwatt> cow_2001: If the scheme you're using has a way to do what you want, use that directly. Don't go out of your way to be portable
2023-04-11 11:21:56 -0400 < cow_2001> oh well
2023-04-11 11:21:57 -0400 < acdw> portable? i didn't even knowable
2023-04-11 11:22:59 -0400 < wasamasa> cond-expand is how CL does all those things
2023-04-11 11:24:31 -0400 < gwatt> I though CL used #+ and #- to do feature switching
2023-04-11 11:24:32 -0400 < cow_2001> okay, guile all the way
2023-04-11 11:24:35 -0400 < cow_2001> sigh
2023-04-11 11:24:37 -0400 < wasamasa> it's the same concept
2023-04-11 11:24:49 -0400 < gwatt> ah, I thought you meant that CL literally had a cond-expand form
2023-04-11 11:24:54 -0400 < wasamasa> well, no
2023-04-11 11:24:58 -0400 < wasamasa> perhaps in some library
2023-04-11 11:25:17 -0400 < wasamasa> but I know that CHICKEN did it the other way around and added #+ and #- for less verbose usage of cond-expand
2023-04-11 11:25:43 -0400 < wasamasa> for all practical purposes, they're equivalent in power
2023-04-11 11:26:50 -0400 < mnieper> cond-expand will break sooner or later.
2023-04-11 11:27:08 -0400 < cow_2001> File Walk With Me
2023-04-11 11:28:22 -0400 < gwatt> mnieper: what do you mean by that?
2023-04-11 11:29:31 -0400 < mnieper> cow_2001: Write a small library (for your preferred impl) that encapsulates the impl-specific stuff and just exports a procedure like directory-fold or so.  Then you just have to replace the impl of that library when you change your system.
2023-04-11 11:30:33 -0400 < mnieper> gwatt: Something like (cond-expand (chibi ...) (guile ...) ...) assumes how stuff works in the implementations at the time of writing.  This is not future-proof.
2023-04-11 11:30:44 -0400 < wasamasa> but that's the same issue with libraries
2023-04-11 11:30:56 -0400 < wasamasa> if you do not update the library code and the functionality changes, your library is broken
2023-04-11 11:31:13 -0400 < wasamasa> the only difference is encapsulation being better, lol
2023-04-11 11:31:41 -0400 < mnieper> Published libraries should (eventually) have versions.  R6RS supports this for a reason.
2023-04-11 11:31:46 -0400 < wasamasa> lol
2023-04-11 11:31:52 -0400 < mnieper> ?
2023-04-11 11:31:55 -0400 < wasamasa> in the face of SRFIs not being versioned...
2023-04-11 11:32:02 -0400 < wasamasa> this seems like a bold statement to make
2023-04-11 11:32:12 -0400 < mnieper> SRFIs have a final version.
2023-04-11 11:32:25 -0400 < wasamasa> yes and the process for fixing seriously broken SRFIs is bad
2023-04-11 11:32:28 -0400 < gwatt> mnieper: I thought the point of cond-expand was that you had fine-grained features, not just detecting the implementation
2023-04-11 11:32:54 -0400 < wasamasa> you cannot retract them and will have to wait until someone goes through the SRFI process again and every user changes to a new SRFI
2023-04-11 11:32:56 -0400 < mnieper> gwatt: This is not how it is usually used.  Most people check for implementations.
2023-04-11 11:33:13 -0400 < wasamasa> yup, given the usual lack of other things to test for
2023-04-11 11:33:27 -0400 < wasamasa> let's hope nobody implements autoconf for scheme
2023-04-11 11:33:54 -0400 < mnieper> autoconf has some valid points (and some warts as well).
2023-04-11 11:34:36 -0400 < wasamasa> like, if I have a cond-expand for a bug in a scheme system, I doubt I can detect the issue at cond-expand time
2023-04-11 11:34:56 -0400 < mnieper> gwatt: With a procedural macro system, cond-expand is not really needed as one can then do (arbitrary) choices at compile-time.
2023-04-11 11:35:22 -0400 < mnieper> wasamasa: What is cond-expand time?
2023-04-11 11:35:27 -0400 < mnieper> cond-expand is static.
2023-04-11 11:35:46 -0400 < wasamasa> I guess macro expansion time
2023-04-11 11:36:17 -0400 < wasamasa> unless I can use a macro to register a cond-expand feature and then test for that...
2023-04-11 11:36:33 -0400 < wasamasa> I do not see cond-expand being fine-grained enough to offer more than testing for an implementation
2023-04-11 11:37:02 -0400 < mnieper> That's my point.
2023-04-11 11:37:08 -0400 < mnieper> Cond-expand is a non-solution.
2023-04-11 11:37:11 -0400 < wasamasa> lol
2023-04-11 11:37:15 -0400 < wasamasa> good enough for me
2023-04-11 11:38:00 -0400 < wasamasa> better than going through the hoops of writing library code doing exactly the same workaround
2023-04-11 11:39:00 -0400 < mnieper> Cond-expand is a good example for a feature piled on top because its functionality (at least when procedural macros are available) can be subsumed by more powerful (derived!) constructs.
2023-04-11 11:42:53 -0400 < wasamasa> yes, for an implementor this may be true, for a user it's more important that this feature was available as early as possible because it otherwise cannot be used for feature testing if the implementations do not have it
2023-04-11 11:43:41 -0400 < wasamasa> I also realized that the library solution does not do anything about automatically loading up the correct code depending on the implementation
2023-04-11 11:43:58 -0400 < mnieper> I don't understand.  If an implementation does not have this feature, how is cond-expand then helpful?
2023-04-11 11:44:31 -0400 < wasamasa> if an implementation decides to not have cond-expand because it can be implemented by the user, then that implementation is not going to benefit from a user-provided cond-expand
2023-04-11 11:45:33 -0400 < mnieper> The user-provided cond-expand-like thing has to be implemented portably, of course.  That's the whole point.
2023-04-11 11:46:19 -0400 < mnieper> "Automatically loading up the correct code depending on the implementation" is an installer question.  R[67]RS do not define any mapping from library names to source code (locations).
2023-04-11 11:46:39 -0400 < wasamasa> yes, this is a major impediment in writing portable code
2023-04-11 11:47:02 -0400 < wasamasa> cond-expand avoids that issue by virtue of not requiring a separate library
2023-04-11 11:50:10 -0400 < mnieper> Why is this a major impediment in writing portable code?
2023-04-11 11:50:33 -0400 < wasamasa> because it penalizes the practice of modularizing code
2023-04-11 11:51:10 -0400 < wasamasa> every time you modularize code, you inflict needless pain upon yourself because you need to make sure it works on every supported implementation
2023-04-11 11:51:29 -0400 < mnieper> If you write portable code, it does by definition.
2023-04-11 11:51:39 -0400 < wasamasa> and with the self-inflicted limitation of not using cond-expand, things get even more painful
2023-04-11 11:52:38 -0400 < wasamasa> the logical extreme of this would have you write your own build tools and very strictly separate your modules per implementation à la plan9
2023-04-11 11:52:57 -0400 < acdw> wasamasa: yeah i've been trying to make my code modular w scheme and oo boy it's rough
2023-04-11 11:53:41 -0400 < mnieper> wasamasa: The portable modules, you don't have to separate.
2023-04-11 11:54:02 -0400 < mnieper> And the truly non-portable ones, well, you have to know anywhere where to install them for a particular implementation.
2023-04-11 11:54:32 -0400 < mnieper> Or which extension you have to give them.
2023-04-11 11:54:37 -0400 < wasamasa> no, for the portable ones you need to worry about load paths/file extensions instead
2023-04-11 11:55:22 -0400 < wasamasa> I have a demo of how involved it is to support 7 different R7RS implementations using a Makefile and shell script for running the program
2023-04-11 11:55:41 -0400 < wasamasa> it's a program that doesn't even start to use implementation-specific functionality, but it papers over implementation bugs
2023-04-11 11:56:01 -0400 < mnieper> You still don't have separate the modules when they are portable in your source code.
2023-04-11 11:56:19 -0400 < wasamasa> no, but people really want to
2023-04-11 11:56:31 -0400 < wasamasa> ask acdw for example and his experience with how to structure a scheme project
2023-04-11 11:57:08 -0400 < mnieper> We have tools like snow or akku.
2023-04-11 11:57:12 -0400 < wasamasa> the experience sort of reminds me of the pain of having to use namespacing prefixes in elisp for every top-level identifier
2023-04-11 11:57:32 -0400 < wasamasa> yes, as usual the solution is to not actually support everything (snow seems to be pretty much only tested with chibi)
2023-04-11 11:57:50 -0400 < acdw> i honestly don't mind using namespacing prefixes, but i also haven't written large emacs packages
2023-04-11 11:58:11 -0400 < wasamasa> it does get old at some point, although I did come up with a solution to spare me most of the typing
2023-04-11 11:58:26 -0400 < acdw> one of hte problems is even in where to put files -- chicken won't go into directories, like package/module/submodule.scm for (package module submodule), but cyclone /requires/ that structure
2023-04-11 11:58:35 -0400 < acdw> wasamasa: yeah i figured it would lol
2023-04-11 11:58:36 -0400 < wasamasa> I've solved that with symlinks
2023-04-11 11:58:43 -0400 < acdw> oh that's smart
2023-04-11 11:58:47 -0400 < wasamasa> it's very ugly, but it works
2023-04-11 11:58:55 -0400 < acdw> but also... it should be like, agreed upon
2023-04-11 11:59:00 -0400 < mnieper> wasamasa: A compiled-only Scheme may not even know what to do with source files (so compilation of them would be a prerequisite before installing anything).
2023-04-11 11:59:13 -0400 < wasamasa> absolutely correct point, yes
2023-04-11 11:59:28 -0400 < acdw> there's not even anywhere that talks about the diff b/w ss, sld, scm, sls files afaict
2023-04-11 11:59:36 -0400 < acdw> i finally figured it out but lord it took some time
2023-04-11 11:59:55 -0400 < mnieper> Scheme implementations usually document how they find and load libraries.
2023-04-11 12:00:39 -0400 < mnieper> It is probably not the right way to put the modules for different systems into the same folder (see chicken <-> cyclone).
2023-04-11 12:00:54 -0400 < mnieper> An installer can create symlinks, for example.
2023-04-11 12:00:59 -0400 < acdw> the problem is there's a gulf b/w what the right way is and what the real way is
2023-04-11 12:01:03 -0400 < wasamasa> yup
2023-04-11 12:01:09 -0400 < acdw> and b/w what different impls /think/ the right way is
2023-04-11 12:01:34 -0400 < wasamasa> it's both a difference between academia/real world and every different interpretation of real world
2023-04-11 12:01:35 -0400 < mnieper> acdw: There need not be a "right way".  Each impl gets its own directory.
2023-04-11 12:02:29 -0400 < acdw> oh yeah that's not a pain in the ass /s
2023-04-11 12:02:42 -0400 < mnieper> On my Ubuntu system I have, for example, /usr/share/chibi and /usr/lib/csv9.4/...
2023-04-11 12:02:53 -0400 < acdw> oh i'm talking about per-project
2023-04-11 12:03:03 -0400 < acdw> i don't want a project/chicken/ .... project/chibi/... etc
2023-04-11 12:03:20 -0400 < acdw> should just be project/file.scm project/lib/file.scm or w/e
2023-04-11 12:03:31 -0400 < wasamasa> yes, but that is what the portable projects try to do, assuming they even get as far as trying to work on more than an implementation
2023-04-11 12:03:44 -0400 < acdw> yeah
2023-04-11 12:03:45 -0400 < mnieper> acdw: You have your source code once, say in /project/src and when you do make, depending on the configuation, it stores something in /build to run with your impl.
2023-04-11 12:04:18 -0400 < mnieper> /project/build
2023-04-11 12:04:29 -0400 < acdw> or different impls could come to some understanding about "hey maybe it's a good idea to have libraries laid out this one way" and like, it'd just work
2023-04-11 12:04:54 -0400 < acdw> i'm just grousing really. i am new to scheme and don't know anything about the internal politics and such
2023-04-11 12:05:02 -0400 < wasamasa> no, I do not see this happen any time soon
2023-04-11 12:05:07 -0400 < wasamasa> it's likelier someone writes a build tool
2023-04-11 12:05:13 -0400 < mnieper> Don't mix source code with built code.  (The built code could just be a copy of the source code, of course.)
2023-04-11 12:05:43 -0400 < acdw> sounds like org-mode "literate" programming
2023-04-11 12:05:58 -0400 < mnieper> That is very far fetched, I think.
2023-04-11 12:06:42 -0400 < acdw> it's taking another step away from the final run program
2023-04-11 12:07:29 -0400 < mnieper> I can only repeat myself.  A generic Scheme may need precompilation.
2023-04-11 12:08:49 -0400 < wasamasa> yes, hence why my solution has a Makefile
2023-04-11 12:09:38 -0400 < mnieper> And this Makefile will have to know about the different supported impls anyway.  Because the command-line parameters are not standardized.
2023-04-11 12:10:29 -0400 < msavoritias> That sounds like autotools. And having seen that horror recently please no
2023-04-11 12:11:01 -0400 < mnieper> What sounds like autotools?
2023-04-11 12:12:35 -0400 < msavoritias> To have a build system that tries to guess directories, command line parameters, features etc.
2023-04-11 12:12:45 -0400 < msavoritias> And me having to describe and maintain that file
2023-04-11 12:12:46 -0400 < mnieper> Not to guess, but knows.
2023-04-11 12:13:02 -0400 < msavoritias> It sounds like hell to me personally
2023-04-11 12:13:43 -0400 < mnieper> I don't understand.  If you want your Makefile to support, say, gauche and chicken, you need to know how to call them to write some Makefile rules.
2023-04-11 12:15:16 -0400 < mnieper> (NB: I don't share your undifferentiated aversion against the Autotools, but that's a completely different point.)
2023-04-11 12:15:17 -0400 < wasamasa> what makes autotools terrible is that they automatically generate files
2023-04-11 12:15:34 -0400 < msavoritias> I mean that i would rather attempt to standardize as much as i can. Before starting to see about a build system
2023-04-11 12:15:42 -0400 < Oxyd> Ideally it would be the other way around. You'd write standard Scheme code, and the various implementations would know how to deal with that.
2023-04-11 12:15:52 -0400 < msavoritias> Or that yeah
2023-04-11 12:15:53 -0400 < wasamasa> for autoconf it's running the entire battery of relevant tests which may take longer than subsequent compilation of the files
2023-04-11 12:16:17 -0400 < mnieper> wasamasa: How often do you run ./configure when you develop?
2023-04-11 12:16:18 -0400 < msavoritias> My aversion to autotools is because i saw the makefile and configure and stuff of guile
2023-04-11 12:16:28 -0400 < wasamasa> mnieper: with emacs I have to run it quite often
2023-04-11 12:16:30 -0400 < mnieper> wasamasa: ./configure also has a cache
2023-04-11 12:16:41 -0400 < msavoritias> And its a such a downgrade from the guile/guix experience
2023-04-11 12:16:42 -0400 < wasamasa> it's ridiculous really
2023-04-11 12:17:14 -0400 < wasamasa> the project I'm referring to lives at https://github.com/kanaka/mal/tree/master/impls/scheme and is hand-written files, so it's a lot easier to manage in comparison
2023-04-11 12:17:31 -0400 < msavoritias> (Plus the makefile and configure and stuff are long and have a completely different syntax)
2023-04-11 12:17:55 -0400 < mnieper> msavoritias: Makefile.am's written for Automake are typically a lot cleaner than Makefiles.
2023-04-11 12:18:03 -0400 < wasamasa> the benefits of generating files become more apparent when the Makefile is long and repetitive
2023-04-11 12:19:32 -0400 < mnieper> The output of Autotools is to be considered binary files.  If you complain about that, you will also complain about compilers.
2023-04-11 12:20:26 -0400 < msavoritias> Makefile.am seems long too.
2023-04-11 12:20:40 -0400 < mnieper> Which one?
2023-04-11 12:20:44 -0400 < wasamasa> I thought it's Makefile.in
2023-04-11 12:20:51 -0400 < msavoritias> The guile one
2023-04-11 12:20:55 -0400 < msavoritias> Sorry guix
2023-04-11 12:21:09 -0400 < mnieper> Makefile.am is for Automake (+ Autoconf).
2023-04-11 12:21:17 -0400 < mnieper> The typical configuration.
2023-04-11 12:21:49 -0400 < mnieper> msavoritias: Do you want to code all the standard Makefile targets by hand?
2023-04-11 12:22:39 -0400 < mnieper> Guile's Makefile(.am) is pretty brief: https://git.savannah.gnu.org/cgit/guile.git/tree/Makefile.am
2023-04-11 12:23:34 -0400 < msavoritias> What i would want probably is a scheme syntax build system that i can make what i intent to do. In a few lines. And the build system takes care of it for me
2023-04-11 12:23:57 -0400 < msavoritias> Yeah that one is smaller
2023-04-11 12:24:51 -0400 < mnieper> You shouldn't look at the generated Makefiles (which even work with a standard POSIX make).
2023-04-11 12:24:59 -0400 < mnieper> The source files are Makefile.am and configure.ac.
2023-04-11 12:26:18 -0400 < mnieper> If you want to understand the system and see the jewels hidden under the dust of Perl and M4: https://www.google.de/books/edition/Autotools_2nd_Edition/3Vv6DwAAQBAJ?hl=de&gbpv=1&dq=inauthor:%22John+Calcote%22&printsec=frontcover
2023-04-11 12:26:18 -0400 < rudybot> https://teensy.info/hZ3Xhz4GsT
2023-04-11 12:26:27 -0400 < mnieper> This book, I can really recommend.
2023-04-11 12:27:26 -0400 < mnieper> My complaint with the Autotools is that they are C/C++-centric.  You won't find pre-written tests/rules/... for Scheme.
2023-04-11 12:27:53 -0400 < msavoritias> Thats the thing i dont. I would rather use meson or something.
2023-04-11 12:28:37 -0400 < msavoritias> And as i said i would rather standardize stuff. From my understanding autotools is like this because there are no standards in operating systemt
2023-04-11 12:28:53 -0400 < msavoritias> Or the languages it supports
2023-04-11 12:29:15 -0400 < msavoritias> At least with meson i get python to make the build files
2023-04-11 12:30:57 -0400 < mnieper> Some things you can't standardize without restricting systems too much.
2023-04-11 12:31:15 -0400 < mnieper> Like assuming that all systems can execute Scheme source files directly.
2023-04-11 12:32:05 -0400 < mnieper> (Which is not even a good approach because it means that the expansion time will come on top of your run time.)
2023-04-11 12:40:13 -0400 < Oxyd> Executing a Scheme source directly isn't that different from running a Scheme program that does (load "a-scheme-source.scm"), so I don't think requiring that would be terribly onerous to implementations.
2023-04-11 13:02:40 -0400 < mnieper> load isn't standardized in a portable way.
2023-04-11 13:04:12 -0400 < mnieper> wasamasa: acdw: msavoritias: I fully agree that it would be best if each system shipped with an installer taking standardized command-line arguments and that can read a standardized directory layout.
2023-04-11 13:10:22 -0400 < acdw> that would be nice indeed
2023-04-11 14:16:57 -0400 < mnieper`> Are the "purely functional random-access pairs and lists" of SRFI 101 compatible with set-car! and set-cdr!?
2023-04-11 14:17:49 -0400 < mnieper`> The SRFI says that implementations are encouraged to use ra-pairs as their primary pair representattion.
2023-04-11 14:23:24 -0400 < Zipheir> The sample implementation isn't.
2023-04-11 14:24:32 -0400 < mnieper`> But would the sample implementation work if the pair records had mutable fields?
2023-04-11 14:30:17 -0400 < Zipheir> It would, but I'm not sure if the structure would work correctly if they were mutated.
2023-04-11 14:31:16 -0400 < mnieper`> The latter is my question (and let's put questions about sharing aside).
2023-04-11 14:32:06 -0400 < mnieper`> When the (conceptual) cdr is modified, the implementation could, in principle, do different things depending on whether the new value is a pair or an atom.
2023-04-11 14:33:25 -0400 < gwatt> set-car! seems like it would be fine to add, set-cdr! has complications
2023-04-11 14:33:25 -0400 < mnieper`> So, could ra-pairs be made standard pairs in Scheme? It would help a lot against accidentally quadratic code.
2023-04-11 14:34:19 -0400 < mnieper`> Currently, append is O(n) in the first argument, but it shouldn't be, for example.
2023-04-11 14:37:30 -0400 < Zipheir> As gwatt says, I think set-cdr! is guaranteed to break the RA lists.
2023-04-11 14:37:58 -0400 < Zipheir> Those operations would indeed have to do different things.
2023-04-11 14:39:04 -0400 < Zipheir> It's silly that SRFI 101 suggests making RA lists the default but doesn't address mutation.
2023-04-11 14:39:32 -0400 < mnieper`> I haven't found anything about that in the mailing list archive.
2023-04-11 14:40:42 -0400 < Zipheir> A similar argument could be made for finger trees, but I'm not sure anyone would want something that complex in place of basic lists.
2023-04-11 14:41:07 -0400 < mnieper`> (Of course, I believe that mutation of pairs should at some point be removed from the standard, but SRFI 101 is based on R6RS, which has, although deprecated, mutable pairs.)
2023-04-11 14:41:49 -0400 < mnieper`> Isn't a finger tree just one way to implement ra lists?
2023-04-11 14:42:55 -0400 < Zipheir> Among other things.
2023-04-11 14:43:32 -0400 < Zipheir> Finger trees are an amazing general-purpose structure, though they are rather complex.
2023-04-11 14:43:58 -0400 < Zipheir> wklew has done a nice Guile implementation https://git.sr.ht/~wklew/seq
2023-04-11 15:04:59 -0400 < mnieper`> That looks good.
2023-04-11 15:06:02 -0400 < mnieper`> Benchmarks vs regular lists for the operations that are efficient with regular lists would be interesting.
2023-04-11 15:07:56 -0400 < Zipheir> The documentation for Haskell's finger tree library claims that finger trees are slower for some list uses (esp. stacks). https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Sequence.html
2023-04-11 15:08:11 -0400 < wklew> It's actually portable R7RS, not just Guile. The documentation needs to be rewritten though, the API totally changed.
2023-04-11 15:08:27 -0400 < wklew> I did run some benchmarks of append, which you can find in that repo.
2023-04-11 15:08:39 -0400 < wklew> It's really fast basically
2023-04-11 15:08:53 -0400 < Zipheir> wklew: Thanks.
2023-04-11 15:09:41 -0400 < mnieper`> That append is fast vs usual append is clear.
2023-04-11 15:09:46 -0400 < Zipheir> wklew: I prefer your implementation to Haskell's, which is horrendously complicated.
2023-04-11 15:10:13 -0400 < mnieper`> I wonder about, say, consing a million elements and then cdring them.
2023-04-11 15:10:25 -0400 < mnieper`> Things that work blazingly fast with naive lists.
2023-04-11 15:10:28 -0400 < wklew> That would be another good benchmark
2023-04-11 15:10:48 -0400 < mnieper`> It would be great if the overhead of your impl would be small.
2023-04-11 15:11:35 -0400 < wklew> It's supposed to be the same amortized complexity, and anecdotally it seems pretty fast, but would be good to confirm
2023-04-11 15:11:47 -0400 < mnieper`> It would also be nice to have an R6RS impl as well (it is probably mostly repackaging what you have).
2023-04-11 15:11:55 -0400 < wklew> If you want to try it, you should be able to load up sized.sld without too much trouble
2023-04-11 15:12:31 -0400 < mnieper`> What is sized.sld?
2023-04-11 15:12:50 -0400 < wklew> size annotated finger trees
2023-04-11 15:12:59 -0400 < wklew> the mot generally useful one
2023-04-11 15:13:03 -0400 < wklew> most*
2023-04-11 15:14:51 -0400 < wklew> Zipheir: re Haskell impl: it is vwry complicated, an absolutely massive source file. They seem to really be pushing it to the point where I wonder if a different structure would be better. I tried to translate the Applicative interface, but it's a horrible mess.
2023-04-11 15:16:10 -0400 < Zipheir> wklew: That's unfortunate. The Applicative interface is interesting.
2023-04-11 15:18:15 -0400 < wklew> I tried to keep the scheme API to the minimum necessary to derive more specialized functions. The issue is that there's usually a more efficient version that involves a million case statements for every possible orientation of the tree :/
2023-04-11 15:18:52 -0400 < mnieper`> wklew: Does the module approach in your source code work with inlining in general?
2023-04-11 15:19:25 -0400 < wklew> I have no idea, it's basically a hacky way to approximate ML module functors
2023-04-11 15:19:40 -0400 < mnieper`> I think it does produce the same overhead as runtime arguments.
2023-04-11 15:20:13 -0400 < mnieper`> If you want the efficiency of ML functors, I think you have to work at the syntactic level.
2023-04-11 15:21:05 -0400 < wklew> Maybe. I think you end up with some duplicated stuff in the environment, but I tried to minimize that in how things are organized. But it shouldn't add much runtime overhead.
2023-04-11 15:21:05 -0400 < mnieper`> An ML functor becomes a macro.
2023-04-11 15:21:28 -0400 < wklew> Everything is defined statically in sized.sld for example
2023-04-11 15:21:41 -0400 < wklew> Er, at the top level I mean
2023-04-11 15:22:51 -0400 < mnieper`> But the procedures are "not well-known" in compiler-jargon.
2023-04-11 15:23:28 -0400 < mnieper`> It is basically (define whatever <some expression to calculate at runtime>)
2023-04-11 15:23:35 -0400 < wklew> Oh I see. That's something to reconsider then.
2023-04-11 15:24:44 -0400 < mnieper`> It currently makes the code a bit hard to read (I had to understand your modules first), for no apparent benefit.  But I think you can easily turn your modules into macros.
2023-04-11 15:25:17 -0400 < wklew> There's only a handful of useful concrete finger trees, so it doesn't seem right to have the user provide the annotation as a parameter (e.g. size)
2023-04-11 15:25:39 -0400 < wklew> That's why I didn't just make it an extra constructor arg, for example
2023-04-11 15:37:52 -0400 < mnieper`> BTW, today it occurred to why it was important that set-car!/set-cdr! were put in their own library by R6RS (and eval as well); otherwise it would not have been statically determinable whether code uses set-car!/set-cdr! as unhygienic macros can forge identifier references.
2023-04-11 15:38:02 -0400 < mnieper`> s/to/to me
2023-04-11 15:45:31 -0400 < wklew> I think my original thought was to use syntax-case for the modules. But I wanted it to be portable R7RS, and I don't think syntax-rules would be enough to generate the specialized definitions.
2023-04-11 15:46:59 -0400 < mnieper`> Make it portabe R7RS-large :)
2023-04-11 15:47:25 -0400 < wklew> Yeah (:
2023-04-11 15:48:14 -0400 < mnieper`> That has syntax-case.
2023-04-11 15:48:52 -0400 < mnieper`> But are you sure that syntax-rules does not suffice?
2023-04-11 15:51:22 -0400 < wklew> It's been a while since I looked. I'll see.
2023-04-11 15:52:10 -0400 < mnieper`> Or make it portable R6RS.
2023-04-11 15:53:05 -0400 < wklew> synyax-case is pretty widely adopted anyway
2023-04-11 15:54:26 -0400 < mnieper`> It just remains to convince the Chicken people.
2023-04-11 15:55:34 -0400 < dTal> we'll need a fluent Chicken speaker then. I only speak basic Chicken - "bok bok bok", "braaaak", that sort of thing
2023-04-11 15:55:50 -0400 < wklew> Lol. Chicken has its own module system conveniently.
2023-04-11 15:56:36 -0400 < acdw> chicken!
2023-04-11 15:57:21 -0400 < Zipheir> CHICKEN has R7RS libraries, if you use the appropriate egg.
2023-04-11 15:59:25 -0400 < mnieper`> I was talking about syntax-case.
2023-04-11 15:59:33 -0400 < acdw> https://isotropic.org/papers/chicken.pdf speaking of chicken
2023-04-11 15:59:37 -0400 < Zipheir> I was responding to wklew.
2023-04-11 15:59:56 -0400 < Zipheir> Cross-talk is a fact of life on IRC.
2023-04-11 16:06:11 -0400 < mnieper`> This time, it wasn't cross-talk.  I thought that wklew meant that he can implement static ML functors with Chicken's module system.
2023-04-11 16:14:53 -0400 < Zipheir> Hmm, I wonder.
2023-04-11 16:18:29 -0400 < sham1> CHICKEN crosses (cross-talks) the road (the channel)
2023-04-11 16:26:39 -0400 < cow_2001> mnieper huh! i've seen a special form cond-something that checks which implementation you're using
2023-04-11 16:27:32 -0400 < acdw> is there any ed25519 library in scheme ?
2023-04-11 16:30:07 -0400 < sham1> Probably not. Best you'd probably have is FFI to a "native" crypto library
2023-04-11 16:30:37 -0400 < acdw> cool
2023-04-11 16:31:17 -0400 < acdw> maybe i can just spurt out the string from blob->string into a file
2023-04-11 16:31:27 -0400 < amirouche> acdw: did you look into weinholt's industria library on gitlab?
2023-04-11 16:31:31 -0400 < acdw> i haven't
2023-04-11 16:31:54 -0400 < amirouche> there is several low level primitive for working with edfoobar stuff ;)
2023-04-11 16:32:03 -0400 < mnieper`> https://gitlab.com/weinholt/industria
2023-04-11 16:32:05 -0400 < acdw> ooo
2023-04-11 16:33:18 -0400 < amirouche> in fact, it was a feature request of mine, but I did not use it, yet.
2023-04-11 16:34:35 -0400 < acdw> oh base64 encoded
2023-04-11 16:34:43 -0400 < amirouche> s/I did not use it, yet/I do not use it, yet/
2023-04-11 16:36:00 -0400 < acdw> course the only problem is it's r6rs lol (i'm using chicken)
2023-04-11 16:37:04 -0400 < wasamasa> yup
2023-04-11 16:37:22 -0400 < wasamasa> I'd take a look at the existing nacl/sodium stuff
2023-04-11 16:37:29 -0400 < wasamasa> that should have ed25519
2023-04-11 16:37:52 -0400 < acdw> i was looking at tweetnacl, not on there: http://wiki.call-cc.org/eggref/5/tweetnacl ... unless i just have to base64 encode it lol
2023-04-11 16:37:56 -0400 < acdw> which is possible
2023-04-11 16:43:29 -0400 < wasamasa> the point of nacl/tweetnacl is not having to worry about the used algorithms
2023-04-11 16:44:57 -0400 < wasamasa> so relying on it for a specific algorithm feels kinda wrong
2023-04-11 16:46:21 -0400 < acdw> ahhh
2023-04-11 16:46:32 -0400 < acdw> i just wanted a small key... i think i was misunderstanding a few things
2023-04-11 16:47:00 -0400 < acdw> i can def save to and from a file with base64 encodign
2023-04-11 16:47:07 -0400 < acdw> well or with just bytes too of course
2023-04-11 17:36:20 -0400 < amirouche> re bootstrapping a functional package manager, look at:
2023-04-11 17:36:23 -0400 < amirouche> https://trofi.github.io/posts/240-nixpkgs-bootstrap-intro.html
2023-04-11 17:36:48 -0400 < amirouche> tl;dr: they are seeds made by nixpkgs that can be re-used
2023-04-11 17:37:02 -0400 < amirouche> anyway, that look way too much work
2023-04-11 17:37:05 -0400 < amirouche> :)
2023-04-11 17:37:23 -0400 < amirouche> I need to find another yak to shave
2023-04-11 17:38:55 -0400 < amirouche> I lost the train of thought that lead me to finding that article
2023-04-11 17:38:57 -0400 < amirouche> x')
2023-04-11 22:04:09 -0400 -!- hugo- is now known as hugo
--- Day changed Wed Apr 12 2023
2023-04-12 01:38:24 -0400 < mnieper> wklew: You can also use the R7RS library system together with the library-level include form to express parameterized libraries.
2023-04-12 01:41:12 -0400 < flatwhatson> what's this library-level include form?
2023-04-12 01:42:11 -0400 < flatwhatson> i'm missing context, does some scheme implement this?
2023-04-12 01:43:10 -0400 < mnieper> This is standard.
2023-04-12 01:43:51 -0400 < mnieper> (define-library (foo) (export ...) (include "...") ...)
2023-04-12 01:44:05 -0400 < mnieper> R7RS 5.6.1
2023-04-12 01:44:52 -0400 < flatwhatson> oh, how does that give you parameterized libraries?
2023-04-12 01:46:56 -0400 < sham1> Well, you could for example use that with cond-expand and get parameterization that way
2023-04-12 01:48:19 -0400 < mnieper> The libraries are not parameterized on the fly, but say you want to define a mapping for strings and one for symbols and would like to inline string=? and symbol?, you include the same body in two libraries but just change an import: (rename string=? =?) to (rename symbol=? =?)
2023-04-12 01:48:26 -0400 < mnieper> And the body works with the abstract =?
2023-04-12 01:48:53 -0400 < flatwhatson> ah, ok, that makes sense
2023-04-12 01:48:59 -0400 < mnieper> This is how templating would be done in C (not in C++) as well.
2023-04-12 01:51:42 -0400 < flatwhatson> i got excited about first-class libraries for a second there
2023-04-12 01:58:44 -0400 < mnieper> Fully first-class modules (that are modules existing at runtime) can already be done (e.g. through a hash table mapping symbols to values); more interesting are modules at compile-time (so you get all optimizations).
2023-04-12 01:59:00 -0400 < mnieper> See here: https://cisco.github.io/ChezScheme/csug9.5/syntax.html#./syntax:h5
2023-04-12 01:59:17 -0400 < mnieper> These modules are also implemented in Unsyntax.
2023-04-12 01:59:58 -0400 < mnieper> The original paper is this one: https://legacy.cs.indiana.edu/~dyb/pubs/popl99.pdf
2023-04-12 02:01:17 -0400 < flatwhatson> nice, thanks, i didn't know chez had this already
2023-04-12 02:03:19 -0400 < sham1> An implementation should also be able to make it so that libraries can be manipulated in a first-class manner
2023-04-12 02:03:52 -0400 < mnieper> If you impl supports "load", it often supports loading library definitions.
2023-04-12 02:05:48 -0400 < mnieper> s/you/your
2023-04-12 02:09:54 -0400 < flatwhatson> right, we have first-class modules in guile for example, but i hadn't seen something like abstract-module built on top
2023-04-12 02:10:31 -0400 < flatwhatson> scheme48 has interfaces, but r6rs and r7rs have nothing of the sort
2023-04-12 02:11:41 -0400 < mnieper> Mostly except for local imports, you can build a module system with syntax-case.
2023-04-12 02:14:57 -0400 < flatwhatson> so are these "abstract-module" and "implement" macros provided by chez? or they're just an example of the power of the module form?
2023-04-12 02:16:30 -0400 < mnieper> I think they are examples of the power of syntax-case together with one primitive module form.
2023-04-12 02:19:22 -0400 < flatwhatson> s48 module system even has type signatures: https://www.s48.org/cgi-bin/hgwebdir.cgi/s48-stable/file/tip/scheme/sort/interfaces.scm
2023-04-12 03:43:25 -0400 -!- Netsplit *.net <-> *.split quits: Bionicbabelfish, turlando, choas, epony, micro, pyro, even4void, phileasfogg, koluacik, renormalist,  (+1 more, use /NETSPLIT to show all of them)
2023-04-12 03:43:28 -0400 -!- Netsplit over, joins: choas
2023-04-12 04:08:02 -0400 < drewdomi> hello
2023-04-12 04:12:20 -0400  * amirouche waves
2023-04-12 04:12:32 -0400 < amirouche> hello drewdomi
2023-04-12 04:12:36 -0400  * sham1 particles
2023-04-12 04:12:37 -0400 < amirouche> are you new around?
2023-04-12 04:26:49 -0400 < drewdomi> amirouche, i am
2023-04-12 04:28:59 -0400 < mnieper`> drewdomi: What have you discovered since we talked yesterday?
2023-04-12 04:31:02 -0400 < drewdomi> mnieper`, it's difficult
2023-04-12 04:34:16 -0400 < mnieper`> What is the first difficult concept for you?
2023-04-12 04:36:34 -0400 < drewdomi> the book "Simply Scheme" has files with some function, simply.scm etc
2023-04-12 04:37:17 -0400 < drewdomi> https://github.com/dyoo/simply-scheme/blob/master/private/simply.scm
2023-04-12 04:37:40 -0400 < drewdomi> how can I use this?
2023-04-12 04:37:52 -0400 < wasamasa> depends, what scheme implementation did you choose?
2023-04-12 04:38:10 -0400 < wasamasa> chances are you can use something like (include "simply.scm") or (load "simply.scm")
2023-04-12 04:39:07 -0400 < drewdomi> I want to use racket
2023-04-12 04:39:30 -0400 < mnieper`> It seems to be written for MzScheme (which later became Racket).
2023-04-12 04:40:09 -0400 < mnieper`> At least the README references MzScheme.
2023-04-12 04:40:18 -0400 < wasamasa> personally, I'd search for someone having a racket-adjusted version
2023-04-12 04:40:23 -0400 < wasamasa> maybe there's even a language pack
2023-04-12 04:41:00 -0400 < drewdomi> how can I adjust to racket implementation?
2023-04-12 04:41:04 -0400 < mnieper`> Otherwise start directly with SICP, for which Racket has built-in support: https://docs.racket-lang.org/sicp-manual/SICP_Language.html
2023-04-12 04:41:41 -0400 < wasamasa> https://docs.racket-lang.org/manual@simply-scheme/index.html
2023-04-12 04:41:42 -0400 < mnieper`> drewdomi: If you are learning Scheme, I wouldn't try adjusting it now as it would distract you from more important things.
2023-04-12 04:42:09 -0400 < mnieper`> wasamasa: Ah, cool!
2023-04-12 04:42:24 -0400 < wasamasa> so if you've somehow installed the language pack, you can just use #lang simply
2023-04-12 04:42:32 -0400 < wasamasa> I mean, #lang simply-scheme
2023-04-12 04:45:23 -0400 < drewdomi> let me see it
2023-04-12 04:48:33 -0400 < drewdomi> i have an error
2023-04-12 04:51:54 -0400 < drewdomi> Is it better I read SICP in JS?
2023-04-12 04:52:15 -0400 < wasamasa> lol
2023-04-12 04:52:18 -0400 < drewdomi> I'm considering now, lol
2023-04-12 04:52:25 -0400 < wasamasa> probably not
2023-04-12 04:52:32 -0400 < wasamasa> but I dunno, not nearly enough data on this
2023-04-12 04:52:40 -0400 < wasamasa> I hate the idea of SICP in JS out of principle
2023-04-12 04:52:47 -0400 < drewdomi> lol
2023-04-12 04:53:04 -0400 < drewdomi> whats the principe?
2023-04-12 04:53:07 -0400 < wasamasa> you see, I've been introduced to scheme in university by a lecturer who freely mixed text and exercises from both SICP and HtDP
2023-04-12 04:53:20 -0400 < wasamasa> this was extremely confusing until I actually went to the library and read HtDP
2023-04-12 04:53:28 -0400 < wasamasa> there was no consistency at all
2023-04-12 04:54:00 -0400 < wasamasa> rewriting SICP in JS with as little effort as possible to stay close to the original material is probably just as confusing for people who want to learn JS
2023-04-12 04:54:09 -0400 < wasamasa> because this is not how JS code usually looks like
2023-04-12 04:55:24 -0400 < drewdomi> wasamasa, is it more teorical about CS, right
2023-04-12 04:55:55 -0400 < wasamasa> the book was never about learning a language, yes
2023-04-12 04:55:59 -0400 < drewdomi> then they don't use pratical JS code
2023-04-12 04:56:13 -0400 < wasamasa> but the JS code in this book is pretty much abuse
2023-04-12 04:56:25 -0400 < drewdomi> wasamasa, why?
2023-04-12 04:56:40 -0400 < wasamasa> it's closer to what a compiler would output in an attempt to obfuscate the meaning
2023-04-12 04:57:11 -0400 < wasamasa> anyone actually knowing scheme could tell what it's trying to do, everyone else would be just confused
2023-04-12 04:57:28 -0400 < drewdomi> lol
2023-04-12 04:57:38 -0400 < mnieper`> wasamasa: Have you a good example from the SICP/JS book to post here?
2023-04-12 04:57:57 -0400 < wasamasa> the translation of cond to several ternaries is the earliest example I can think of
2023-04-12 04:59:45 -0400 < mnieper`> Where can I find it (I don't want to search the whole book)?
2023-04-12 05:00:08 -0400 < wasamasa> I'm currently going through the first chapter
2023-04-12 05:00:08 -0400 < drewdomi> So it's better start directly read SICP first?
2023-04-12 05:00:10 -0400 < mnieper`> Ah, I found an example.
2023-04-12 05:00:18 -0400 < mnieper`> drewdomi: SICP is a great book!
2023-04-12 05:00:52 -0400 < drewdomi> mnieper`, I want to learn CS
2023-04-12 05:01:05 -0400 < mnieper`> Then go with SICP.
2023-04-12 05:01:07 -0400 < mnieper`> https://docs.racket-lang.org/sicp-manual/Installation.html
2023-04-12 05:01:09 -0400 < wasamasa> https://sourceacademy.org/sicpjs/1.1.6
2023-04-12 05:01:34 -0400 < wasamasa> "In JavaScript, we express a case analysis with multiple cases by nesting conditional expressions as alternative expressions inside other conditional expressions"
2023-04-12 05:01:43 -0400 < mnieper`> wasamasa: deriv in 2.3.2
2023-04-12 05:02:12 -0400 < wasamasa> oh yes
2023-04-12 05:02:25 -0400 < wasamasa> I'm still a bit surprised you can just chain ternaries
2023-04-12 05:02:38 -0400 < wasamasa> they do not even mention the word
2023-04-12 05:03:00 -0400 < drewdomi> wasamasa, it's bad, lol
2023-04-12 05:03:09 -0400 < mnieper`> Why don't they just pull return into the ternaries so that they become if/else ifs?
2023-04-12 05:03:37 -0400 < wasamasa> because then they're no longer expressions, but statements
2023-04-12 05:03:47 -0400 < wasamasa> then you can no longer pretend it's functional programming
2023-04-12 05:04:27 -0400 < wasamasa> I haven't looked beyond chapter 1 of the rewrite (and haven't progressed beyond chapter 2 of the original in terms of exercises)
2023-04-12 05:06:12 -0400 < mnieper`> wasamasa: You can still pretend that it is functional language.  return just gets come call/cc-like semantics.
2023-04-12 05:06:25 -0400 < mnieper`> s/language/programming
2023-04-12 05:06:49 -0400 < drewdomi> IS How to Design Programs in racket, right?
2023-04-12 05:07:01 -0400 < mnieper`> Yes.
2023-04-12 05:07:41 -0400 < mnieper`> There is also something in German: https://www.deinprogramm.de/sdp/
2023-04-12 05:07:52 -0400 < wasamasa> that seems obsolete though
2023-04-12 05:08:14 -0400 < drewdomi> thx to everyone!
2023-04-12 05:08:21 -0400 < mnieper`> wasamasa: Re functional programming: begin is not banned from Scheme either.
2023-04-12 05:08:26 -0400 < mnieper`> wasamasa: What is obsolete?
2023-04-12 05:08:31 -0400 < wasamasa> deinprogramm
2023-04-12 05:08:42 -0400 < wasamasa> it mentions htdp as the book for a sister project
2023-04-12 05:09:07 -0400 < mnieper`> The last version of "Schreibe Dein Programm!" is from February, 2023.
2023-04-12 05:10:47 -0400 < wasamasa> huh
2023-04-12 05:12:09 -0400 < mnieper`> Hardly outdated.
2023-04-12 06:31:44 -0400 < cow_2001> oh god so many obnoxious cryptocurrency ponzi scammers
2023-04-12 06:54:04 -0400 < flatwhatson> obnoxious cryptocurrency ponzi scheme
2023-04-12 07:25:17 -0400 < cow_2001> flatwhatson: sigh
2023-04-12 07:30:36 -0400 < wklew> mneiper: I did not think of just renaming and including. I usually avoid include since it seems to work differently depending on the scheme. Or maybe it's just broken in guile.
2023-04-12 07:37:47 -0400 < mnieper`> Library-level include usually works better than body-local include.
2023-04-12 07:38:34 -0400 < mnieper`> In some sense, it is not portable as the filename->source mapping is not defined by the standard.
2023-04-12 07:39:05 -0400 < mnieper`> But it ususally works if the included file is in the same directory as the library definition file.
2023-04-12 07:40:30 -0400 < mnieper`> Racket's include is much more sophisticated: https://docs.racket-lang.org/reference/include.html
2023-04-12 07:44:20 -0400 < wklew> Right. I don't think there's even a filename->source mapping for import, it just happens to exist in the schemes I use (mostly guile and chibi).
2023-04-12 07:45:02 -0400 < wklew> Not in the standard I mean
2023-04-12 07:51:00 -0400 < mnieper`> A difference is that import takes abstract library names, not concrete-looking filenames.
2023-04-12 09:12:11 -0400 < wklew> True, I just noticed that. What is the difference between include and include-library-definitions?
2023-04-12 09:17:11 -0400 < mnieper`> include is for the body of the library.
2023-04-12 09:17:30 -0400 < mnieper`> include-library-definitions splice into the library definition itself.
2023-04-12 09:17:53 -0400 < mnieper`> E.g. the file included by include-library-definitions may contain (export ...) (import ...) (begin ...)
2023-04-12 09:18:38 -0400 < mnieper`> Think of include (at the library definition level) as include-library-declarations but then wrapped into begin.
2023-04-12 09:18:58 -0400 < wklew> I see, thanks
2023-04-12 09:19:00 -0400 < mnieper`> s/include-library-definitions/include-library-declarations in some of the text above
2023-04-12 09:19:13 -0400 < wklew> Yeah my mistake
2023-04-12 09:19:27 -0400 < mnieper`> I always have think twice myself! :)
2023-04-12 09:21:27 -0400 < mnieper`> One may argue whether this stuff belongs into the language proper (or whether it should be part of a build/package manager).  It makes an R7RS library definition not self-contained; this is different to R6RS's library form.  I always imagine `define-library' to be a macro that expands into `library'.  This may or may not be the case for a concrete impl, but effectively it works this way.
2023-04-12 09:23:20 -0400 < wklew> I would love something like the first class modules from Chez you posted earlier
2023-04-12 09:23:38 -0400 < mnieper`> Use Chez or Unsyntax!
2023-04-12 09:24:07 -0400 < amirouche> modules are first class in Chez or Unsyntax?
2023-04-12 09:24:23 -0400 < mnieper`> In Unsyntax I re-implemented Chez's module form.
2023-04-12 09:24:31 -0400 < amirouche> Maybe that is another definiion of first class
2023-04-12 09:24:46 -0400 < mnieper`> First-class at expansion-time, so to speak.
2023-04-12 09:42:48 -0400 < wklew> Well include seems to work perfectly!
2023-04-12 09:42:58 -0400 < wklew> That's a whole bunch of ugly code I can scrap
2023-04-12 09:43:14 -0400 < amirouche> what is it?
2023-04-12 09:45:21 -0400 < wklew> I wrote a finger tree library, and want to be able to specialize the generic implementation based on a parameter at expansion time
2023-04-12 09:45:47 -0400 < wklew> So you can reuse the definitions to define different concrete finger trees, but not incur any run-time overhead
2023-04-12 09:55:23 -0400 < amirouche> perfection is the limit!
2023-04-12 09:55:34 -0400 < amirouche> Any ETA on a release?
2023-04-12 09:56:08 -0400 < amirouche> a lot of people around here have been looking for a good finger tree implementation, I am sure it will make more than one happy
2023-04-12 10:11:07 -0400 < mnieper`> Just taking a look at the finger-tree paper.  It is funny how computer scientists invent new language.  First, they use mathematical language, speaking of monoids, and then they add terms like "reduce" to the mix.  Bimodule or something like this would be a better term.
2023-04-12 10:13:27 -0400 < amirouche> wklew: I am serious :)
2023-04-12 10:20:34 -0400 < jcowan> mnieper`: Look at the definition of "cross product" in the relational algebra sometime.  It's not a cross product, and this is openly acknowledged up front.
2023-04-12 10:21:04 -0400 < wklew> I need to rewrite the API docs, and then add a few more concrete examples (the ones from the paper). Then it would be great to have people test it in different implementations.
2023-04-12 10:24:47 -0400 < mnieper`> jcowan: I don't want to argue about the meaningfulness of established terms (many are not meaningful).  My point was about inventing new ad-hoclanguage in a formal setting when there are already terms.  It is about recognition.  And the power of category language.
2023-04-12 10:25:28 -0400 < sham1> Most programmers would probably be more familiar with reductions than bimodules
2023-04-12 10:26:05 -0400 < cow_2001> i need somebody to acknowledge my effort :| https://git.sr.ht/~kakafarm/sicp/
2023-04-12 10:26:11 -0400 < acdw> good job
2023-04-12 10:26:16 -0400 < cow_2001> acdw: D:<
2023-04-12 10:26:30 -0400 < acdw> what i did the thing u asked
2023-04-12 10:26:58 -0400 < cow_2001> acdw: it's both good and bad! took you about 6 seconds to reply, but it also took you about 6 seconds to reply
2023-04-12 10:29:55 -0400 < acdw> oh
2023-04-12 10:30:04 -0400 < acdw> okay i'll actually look at it :(
2023-04-12 10:30:08 -0400 < acdw> :P* sorry typo
2023-04-12 10:31:41 -0400 < acdw> cow_2001: what impl have you programmed in ? just curious
2023-04-12 10:31:42 -0400 < cow_2001> you don't have to, just... you know... it would be appreciated if you can!
2023-04-12 10:31:45 -0400 < cow_2001> guile
2023-04-12 10:31:51 -0400 < acdw> nice
2023-04-12 10:32:03 -0400 < cow_2001> it's not complete
2023-04-12 10:32:10 -0400 < cow_2001> still in chapter 3.1
2023-04-12 10:32:30 -0400 < mnieper`> sham1: But then you probably don't start talking about monoids.  And left/right reduction is explained anyway, so it could also have been explained using proper terms.  "Associativity" was mentioned for monoids, but in the right/left reduction section the crucial point of non-associativity is buried under informal language of "nesting".
2023-04-12 10:32:31 -0400 < acdw> i never finished, so no spo[ilers!
2023-04-12 10:32:46 -0400 < cow_2001> acdw: Gandalf dies!
2023-04-12 10:32:51 -0400 < mnieper`> I don't mind informal language, not at all, but sometimes computer scientists produce strange mixtures.
2023-04-12 10:32:55 -0400 < acdw> cow_2001: nooooooooo
2023-04-12 10:33:09 -0400 < cow_2001> and they walk and walk and walk
2023-04-12 10:33:48 -0400 < sham1> [mnieper](https://matrix.to/#/@mnieper:libera.chat): honestly, I wouldn't be sorry at all if more CS papers weren't just mathematics papers in a trenchcoat and with false glasses
2023-04-12 10:33:54 -0400 < sham1> Oh ffs
2023-04-12 10:33:55 -0400 < Oxyd> I feel that monoids are more well known that bimodules. I've certainly heard of monoids, but not of bimodules.
2023-04-12 10:34:00 -0400 < acdw> cow_2001: looks good to me!
2023-04-12 10:34:14 -0400 < cow_2001> acdw: https://www.youtube.com/watch?v=DgMnCLHQuqc
2023-04-12 10:34:29 -0400 < sham1> So much for perfect IRC bridging
2023-04-12 10:34:33 -0400 < mnieper`> Biaction instead of bimodule would also be a suitable term.
2023-04-12 10:35:23 -0400 < acdw> cow_2001: hell yeah
2023-04-12 11:45:39 -0400 < jcowan> mnieper`: What is "proper terminology" depends on who's reading it.  James Iry's wisecrack "A monad is just a monoid in the category of endofunctors, what's the problem?" is indicative of this.
2023-04-12 11:46:01 -0400 < jcowan> To a mathematician, it is true and obvious.  To a computer scientist who is not a mathematician, it is obnoxious gatekeeping.
2023-04-12 11:50:11 -0400 < jcowan> Similarly, if I define velleity as the weakest level of volition, I am quite correct, but not very helpful if you haven't studied volition theory.
2023-04-12 12:00:53 -0400 < mnieper`> jcowan: I didn't say that one didn't need to define the terms used.
2023-04-12 12:01:25 -0400 < mnieper`> I was just surprised about the imbalance.
2023-04-12 12:06:05 -0400 < Zipheir> jcowan: I'd say that using a complicated, wordy mathematical concept is justified if it connects your new example to an established body of theory.
2023-04-12 12:07:58 -0400 < Zipheir> Of course, if you don't need that theory, using the "hard words" might not be worth it.
2023-04-12 12:08:25 -0400 < Zipheir> "By the way, this is a bimodule" might be sufficient.
2023-04-12 12:09:00 -0400 < Zipheir> Otherwise... https://abstrusegoose.com/211
2023-04-12 13:48:00 -0400 < mnieper`> www.r6rs.org now has https (and a faster server).
2023-04-12 13:48:18 -0400 < mnieper`> The files are now hosted on our presence on Codeberg.
2023-04-12 13:48:58 -0400 < mnieper`> jcowan: Should we create an r7rs page on Codeberg as well so that r7rs.org no longer needs to redirect into your personal repo on GitHub?
2023-04-12 13:51:24 -0400 < acdw> should I learn r6rs?
2023-04-12 13:52:08 -0400 < Zipheir> Are the R7RS "God dockets" still going to be voted on?
2023-04-12 13:53:12 -0400 < mnieper`> acdw: It's worth it.  The core and a lot of other stuff is the same as R7RS.
2023-04-12 13:53:56 -0400 < mnieper`> The record system is more powerful as is the macro system.
2023-04-12 13:54:16 -0400 < mnieper`> And it has some more built-in features like hash tables.
2023-04-12 13:54:42 -0400 < acdw> ooo
2023-04-12 13:55:04 -0400 < mnieper`> The condition system makes systematic raising and catching exceptions viable.
2023-04-12 13:59:28 -0400 < acdw> i'm guessing chez?
2023-04-12 14:00:25 -0400 < wasamasa> chez is like, the only reason I'd bother learning R6RS
2023-04-12 14:00:32 -0400 < mnieper`> For R6RS, I suggest Chez.
2023-04-12 14:01:10 -0400 < mnieper`> wasamasa: Have you learned it?
2023-04-12 14:01:13 -0400 < wasamasa> nope
2023-04-12 14:01:19 -0400 < Zipheir> There's also Guile and Racket's R6RS mode.
2023-04-12 14:02:38 -0400 < mnieper`> wasamasa: So how can you tell that Chez would be the only reason?
2023-04-12 14:02:59 -0400 < mnieper`> Guile is only 90% standard-compliant, and Racket maybe 95%.
2023-04-12 14:03:14 -0400 < wasamasa> all I'm saying is that the other reasons I've seen so far have not convinced me
2023-04-12 14:03:33 -0400 < mnieper`> To learn a dialect, I would use an implementation that is complete.
2023-04-12 14:04:37 -0400 < Zipheir> There is not a great deal one has to change from other Scheme dialects to write R6RS, IME.
2023-04-12 14:05:37 -0400 < acdw> cool beans
2023-04-12 14:05:49 -0400 < acdw> course chez isn't working immediately with geiser, lol
2023-04-12 14:05:58 -0400 < acdw> probably need to restart emacs
2023-04-12 14:06:02 -0400 < wasamasa> that's not really the fault of chez
2023-04-12 14:06:08 -0400 < acdw> lol yeah
2023-04-12 14:06:23 -0400 < wasamasa> geiser works very well with guile, in comparison all other implementations of the scheme bits look terrible
2023-04-12 14:07:01 -0400 < mnieper`> Geiser works with Chez.
2023-04-12 14:07:07 -0400 < acdw> yeah i just restarted emacs, this is nice
2023-04-12 14:07:12 -0400 < mnieper`> You just have to install Geiser from the devel channel.
2023-04-12 14:07:18 -0400 < Zipheir> I used it with CHICKEN a couple years back to do The Little Prover (in which the editor interface is desperately needed). It worked well enough.
2023-04-12 14:07:29 -0400 < acdw> it works okay with CHICKEN yeah
2023-04-12 14:07:49 -0400 < wasamasa> I tried it occasionally with CHICKEN and the (performance) bugs convinced me to not to bother
2023-04-12 14:07:51 -0400 < mnieper`> But the Chez REPL itself is also fantastic.
2023-04-12 14:08:00 -0400 < acdw> honestly i just want a scheme with decent library things that compiles to native binary
2023-04-12 14:08:05 -0400 < wasamasa> with chez I'd stick to the terminal due to line editor
2023-04-12 14:08:21 -0400 < wasamasa> if this were #emacs, parsnip would invoke the ,just factoid
2023-04-12 14:08:25 -0400 < Zipheir> Yeah, the Chez REPL is sufficient.
2023-04-12 14:08:44 -0400  * acdw goes to put the ,just factoid in #emacds
2023-04-12 14:08:56 -0400 < acdw> i'm a pretty lazy programmer, but then again, i'm doing this all for fun
2023-04-12 14:09:09 -0400 < Zipheir> Is there anything that Emacs fans *don't* do in Emacs?
2023-04-12 14:09:21 -0400 < acdw> i don't cook my dinner ... yet
2023-04-12 14:09:28 -0400 < acdw> C-u 425 M-x bake
2023-04-12 14:09:49 -0400 < acdw> of course you have to (setq bake-temperature-units 'F) first
2023-04-12 14:09:58 -0400 < Zipheir> Hah.
2023-04-12 14:16:03 -0400 < mnieper`> Emacs is my IRC client.
2023-04-12 14:16:18 -0400 < sham1> Although the preferred interface would be Customize since that actually changes the scale used (can't hook onto setq but you can hook onto custom-set-variable)
2023-04-12 14:16:38 -0400 < sham1> Err, customize-set-variable
2023-04-12 14:17:11 -0400 < mnieper`> Are there oven-local variables in Emacs 30+?
2023-04-12 14:17:31 -0400 < sham1> And that's a useful thing to note for Emacs at large. The use of setq might break things, although since 3rd party stuff bothers even less with Customize than stuff in Emacs proper, that's a moot point
2023-04-12 14:21:15 -0400 < acdw> mnieper`: oh taht's a good questions
2023-04-12 15:35:03 -0400 < wklew> .oven_locals.el
2023-04-12 15:36:47 -0400 < sham1> I'm sure someone has a) bought an IoT oven and b) tried to hack Emacs to communicate with it
2023-04-12 15:36:52 -0400 < sham1> Smart ovens exist, after all
2023-04-12 15:45:27 -0400 < jcowan> Zipheir: The Committee B docket will certainly be voted on.
2023-04-12 15:45:54 -0400 < jcowan> I don't see any principle for determining what batteries are included and excluded that is superior to voting.
2023-04-12 15:46:11 -0400 < jcowan> The same may apply to Committee E
2023-04-12 15:58:30 -0400 < sham1> I'll try to bring up more ideas to the repo once I have less university stuff to attend to
2023-04-12 15:59:09 -0400 < sham1> For E
2023-04-12 16:00:27 -0400 < Zipheir> jcowan: Good to hear.
2023-04-12 16:13:28 -0400 < Zipheir> It would be good to replace lambda* with SRFI 232 in Eos, or add it as an alternative.
2023-04-12 16:26:23 -0400 < jcowan> What is Eos?
2023-04-12 16:41:29 -0400 < Zipheir> Was it renamed? https://github.com/johnwcowan/r7rs-work/blob/master/ColorDockets.md#user-content-eos-docket-portable-not-srfis
2023-04-12 16:41:30 -0400 < rudybot> https://teensy.info/w3h1UgdHUG
2023-04-12 16:50:46 -0400 < mnieper> Zipheir: What is  the other lambda*?
2023-04-12 16:51:33 -0400 < Zipheir> mnieper: curried, which you helped design.
2023-04-12 16:52:11 -0400 < mnieper> I mean the alternative.
2023-04-12 16:52:20 -0400 < mnieper> As you write replace.
2023-04-12 16:52:57 -0400 < Zipheir> The alternatives are Hemann's original lambda* or the (improved, I think) SRFI 232 'curried'.
2023-04-12 16:56:20 -0400 < Zipheir> I guess there's not much reason to bring it up now. If at some point lambda* is due to be voted on, SRFI 232 should be mentioned.
2023-04-12 17:06:19 -0400 < mnieper> Zipheir: Thanks.
2023-04-12 17:07:22 -0400 < mnieper> I wonder how much use it is in isolation (as a portable addon library) if all standard procedures are not curried.
2023-04-12 17:08:59 -0400 < Zipheir> I don't know. I'm a bit ambivalent toward curried/lambda* these days. I just noticed it was on the Eos docket.
2023-04-12 17:10:10 -0400 < acdw> eye of scheme
2023-04-12 17:10:42 -0400 < mnieper> Your SRFI gives the example of add*, which had to be defined explicitely so that currying is enabled as the ordinary + is not enabled.
2023-04-12 17:11:58 -0400 < mnieper> An interface as in SRFI 26 could help (by using a prefix similar to "cut") so that procedures can be curried on the fly.
2023-04-12 17:12:46 -0400 < mnieper> E.g. (c fold <args>) curries fold and partially applies <args>.
2023-04-12 17:13:02 -0400 < mnieper> We may have discussed this on the mailing list already.
2023-04-12 17:16:11 -0400 < Zipheir> I don't remember discussing that. It's worth thinking about.
2023-04-12 17:17:48 -0400 < mnieper> It is too late for me to think about whether this works with c not knowing how many arguments fold takes... probably not :(
2023-04-12 17:26:36 -0400 < jcowan> Sorry, I was distracted
2023-04-12 18:37:50 -0400 < flatwhatson> lambda* and define* are used heavily in guile for optional & keyword handling, seems unfortunate to have a naming conflict like this
2023-04-12 18:38:15 -0400 < Zipheir> That's why we didn't use those names in SRFI 232.
2023-04-12 18:38:35 -0400 < Zipheir> (Instead, it's 'curried' and 'define-curried'.)
2023-04-12 18:40:13 -0400 < flatwhatson> ah :)
2023-04-12 18:41:12 -0400 < Zipheir> '*' can mean just about anything in a Scheme name.
2023-04-12 18:41:29 -0400 < flatwhatson> yeah, and best left free for users imo
2023-04-12 18:42:14 -0400 < flatwhatson> it's kind of lazy naming shortcut if it's part of your api
2023-04-12 18:43:35 -0400 < Zipheir> For a long time, Haskell standard libraries have used a single-quote similarly (e.g. foldl and foldl'). There, however, it usually means "the strict version".
2023-04-12 18:43:59 -0400 < Zipheir> That's a bit confusing, though.
2023-04-12 18:44:05 -0400 < flatwhatson> haskell is guilty of extremely lazy procedure naming everywhere
2023-04-12 18:44:26 -0400 < flatwhatson> wtf is a <*>
2023-04-12 18:44:58 -0400 < Zipheir> I'm not even sure how to pronounce it.
2023-04-12 18:45:19 -0400 < Zipheir> (I've heard "ap" and "ap over".)
2023-04-12 18:46:03 -0400 < flatwhatson> instead of doing the somewhat difficult job of coming up with a succinct but useful name for my procedure, i like to just draw some abstract ascii art
2023-04-12 18:47:31 -0400 < Zipheir> A completely reasonable approach if you're programming on a blackboard.
2023-04-12 18:47:48 -0400 < flatwhatson> at least you can say "foo"
2023-04-12 18:50:07 -0400 < Zipheir> There is some question of what a good name for an infix procedure looks like. "A foo B" is a bit odd compared with "A * B".
2023-04-12 18:51:42 -0400 < Zipheir> Bird and Wadler, who had a lot of influence on early Haskell, preferred ⊕, ⊖, and ⊙ for custom infix functions. I think that--or, at least, its ASCII facsimile--stuck, for better or worse.
2023-04-12 18:52:35 -0400 < flatwhatson> a lot of the infix-ness in haskell feels arbitrary, at least from a schemer perspective where infix is mostly unnecessary
2023-04-12 18:54:03 -0400 < flatwhatson> (compose a b c d) is much nicer than a . b . c . d
2023-04-12 18:55:36 -0400 < flatwhatson> but yeah i guess it all stems from the attempt to make the code resemble the mathematical notation
2023-04-12 20:37:03 -0400 < ZombieChicken> Probably a silly question, but is there a compatability layer to run Scheme code in Emacs?
2023-04-12 20:37:11 -0400 < ZombieChicken> I'm fairly open regard which Scheme
2023-04-12 20:37:46 -0400 < wasamasa> no
2023-04-12 20:38:05 -0400 < wasamasa> the other way around has been attempted with scheme and CL though
2023-04-12 20:38:27 -0400 < wasamasa> that is, implementing an emacs on top of them or an elisp compatibility layer or elisp evaluator
2023-04-12 20:38:34 -0400 < wasamasa> which gives such integration for free
2023-04-12 20:39:28 -0400 < wasamasa> for example one of the motivations for guilemacs was free access to guile libraries
2023-04-12 20:39:33 -0400 < mdhughes> You can use edwin in MIT Scheme.
2023-04-12 20:40:33 -0400 < wasamasa> yeah, that's another emacs implemented with scheme
2023-04-12 20:40:43 -0400 < wasamasa> and finally, jmacs with kawa
2023-04-12 20:47:45 -0400 < flatwhatson> geiser is a way to run scheme code in emacs
2023-04-12 20:49:20 -0400 < ZombieChicken> flatwhatson: I am just trying to avoid mucking about with emacsisms. Learning I can't (define name (lambda ...)) is making my head hurt
2023-04-12 20:50:15 -0400 < flatwhatson> are you trying to write elisp, but want it to be scheme? as wasamasa says, unfortunately not
2023-04-12 20:53:46 -0400 < ZombieChicken> pretty much, yep
2023-04-12 20:54:05 -0400 < ZombieChicken> probably should dig that editor out of the code pile and get it into something resembling working order
2023-04-12 20:54:20 -0400 < wasamasa> hahaha
2023-04-12 20:54:39 -0400 < ZombieChicken> What?
2023-04-12 20:54:54 -0400 < wasamasa> well then, I hope working on that editor doesn't become more of a time sink than the editor infamous for being a time sink
2023-04-12 20:55:07 -0400 < flatwhatson> writing text editors is the dark souls of computer science
2023-04-12 20:55:20 -0400 < ZombieChicken> I cannot imagine it could be more of a pain than Emacs
2023-04-12 20:55:25 -0400 < wasamasa> I dunno about text editors, but game engines, sure
2023-04-12 20:55:31 -0400 < ZombieChicken> flatwhatson: What? Easy once you get the pattern down?
2023-04-12 20:55:54 -0400 < wasamasa> so many genuinely skilled programmers never finishing a game because they'd rather write the one and only game engine
2023-04-12 20:56:39 -0400 < ZombieChicken> Keep in mind people speedrun all three Dark Soul's games back-to-back.
2023-04-12 20:56:48 -0400 < ZombieChicken> Pretty sure Nethack is harder
2023-04-12 20:58:54 -0400 < flatwhatson> i was thinking more philosophically, a continuous stream of cursed undead attempting to end the age of emacs
2023-04-12 20:59:11 -0400 < flatwhatson> who knows, maybe you're the chosen one
2023-04-12 20:59:37 -0400 < ZombieChicken> I highly doubt that.
2023-04-12 21:00:17 -0400 < ZombieChicken> That hydra will always have another head, regardless of how many you hack off
2023-04-12 21:00:20 -0400 < flatwhatson> a portable edwin would be great
2023-04-12 21:01:11 -0400 < flatwhatson> more ambitiously, nyxt but in scheme
2023-04-12 21:01:18 -0400 < ZombieChicken> flatwhatson: I have a very crappy 'library' that has some of the basics in it, just lacking a real GUI and the like. It's line-oriented and uses a vector
2023-04-12 21:02:43 -0400 < ZombieChicken> never used edwin, either. I'm basing it roughly off ed
2023-04-12 21:03:52 -0400 < flatwhatson> imo it's highly likely that a from-scratch editor is going to suck
2023-04-12 21:04:03 -0400 < flatwhatson> edwin already exists as a scheme clone of emacs, even if it's a bit dusty
2023-04-12 21:04:10 -0400 < ZombieChicken> One learns from failure
2023-04-12 21:06:20 -0400 < acdw> ZombieChicken: ooo I was wanting to work on that too. a vector does make more sense than a list
2023-04-12 21:07:29 -0400 < flatwhatson> until you want to insert text in the middle
2023-04-12 21:08:49 -0400 < acdw> oh yeah I guess so. have to make a new vector eh
2023-04-12 21:09:02 -0400 < flatwhatson> there are much better data structures for this purpose, like ropes or gap buffers
2023-04-12 21:09:20 -0400 < acdw> that requires me looking up what those are :p
2023-04-12 21:10:19 -0400 < flatwhatson> one does not simply replace emacs
2023-04-12 21:11:17 -0400 < acdw> oh I just wanted to rewrite ed
2023-04-12 21:18:21 -0400 < ZombieChicken> my append-after-line function is 21 lines, and yeah, it gets a bit messy
2023-04-12 21:19:19 -0400 < ZombieChicken> flatwhatson: One could always build the vector BASIC-style; only put lines in every 10 entries, and drop NUL entries on writing
2023-04-12 21:19:23 -0400 < ZombieChicken>  /s
2023-04-12 21:21:47 -0400 < flatwhatson> now you're back to a linear scan for line numbers
2023-04-12 21:25:37 -0400 -!- JudgeChicken is now known as ZombieChicken
2023-04-12 21:25:41 -0400 < ZombieChicken> there we go
2023-04-12 21:37:28 -0400 < ZombieChicken> Ropes do look fairly interesting
2023-04-12 21:37:34 -0400 < ZombieChicken> I'll have to look at that
2023-04-12 22:08:12 -0400 < acdw> hmm
2023-04-12 22:48:38 -0400 < wklew> Ah, we've stumbled on another finger tree
2023-04-12 22:55:23 -0400 < acdw> sounds disturbing
2023-04-12 23:29:24 -0400 < jcowan> better than being fingered by a tree
--- Day changed Thu Apr 13 2023
2023-04-13 02:36:08 -0400 < mdhughes> !yt evil dead tree
2023-04-13 06:41:27 -0400 < shawnw> Hmm. Trying to install guile 3.0.9 in /usr/local, but running /usr/local/bin/guile reports the same (older) version as in /ujsr/bin.
2023-04-13 08:25:22 -0400 < shawnw> Fixed that problem (Except now the /usr/bin/guile is saying it's 3.0.9), which allowed me to make some progress on a project, only to run into an 8 year old bug stopping include from working ( https://debbugs.gnu.org/cgi/bugreport.cgi?bug=21613 ). Sigh.
2023-04-13 08:38:35 -0400 < flatwhatson> shawnw: seems a simple workaround would be to put your included file in a subdir
2023-04-13 08:46:10 -0400 < shawnw> That doesn't fix the problem.
2023-04-13 08:47:01 -0400 < flatwhatson> right, reading more closely it's a bit trickier
2023-04-13 08:48:08 -0400 < flatwhatson> why are you using include?  if you're just trying to modularize your code, there are better non-broken options
2023-04-13 08:48:19 -0400 < shawnw> And even if it did, this is an existing project by someone else that works on a few R7RS schemes already and I don't want to make major changes to its structure in this attempt to port it to guile.
2023-04-13 08:48:31 -0400 < flatwhatson> ah, ok
2023-04-13 08:48:48 -0400 < shawnw> It uses include because that's what R7RS define-library uses.
2023-04-13 08:49:00 -0400 < flatwhatson> yep makes sense
2023-04-13 13:18:38 -0400 < cow_2001> hurrah! guile does it from the right! https://git.sr.ht/~kakafarm/sicp/tree/master/item/sicp/tests/3_8.scm
2023-04-13 13:19:26 -0400 < cow_2001> finally chapter 3.2
2023-04-13 13:20:31 -0400 < cow_2001> which means i was wrong!
2023-04-13 13:20:55 -0400 < wasamasa> are you referring to evaluation order?
2023-04-13 13:21:20 -0400 < cow_2001> yes!
2023-04-13 13:21:32 -0400 < wasamasa> that's unspecified in scheme
2023-04-13 13:21:33 -0400 < cow_2001> i expected it to be from left to right
2023-04-13 13:21:35 -0400 < cow_2001> yes
2023-04-13 13:21:36 -0400 < wasamasa> in CL it's specified
2023-04-13 13:21:42 -0400 < wasamasa> in elisp, no idea
2023-04-13 13:21:57 -0400 < wasamasa> but the occasional time you need a specific evaluation order, use code that specifies it
2023-04-13 13:22:01 -0400 < cow_2001> (define) are done in order, right?
2023-04-13 13:22:04 -0400 < cow_2001> also let*?
2023-04-13 13:22:10 -0400 < wasamasa> read the standard
2023-04-13 13:22:13 -0400 < cow_2001> oh
2023-04-13 13:22:16 -0400 -!- dTal is now known as DTAL
2023-04-13 13:22:26 -0400 < wasamasa> seriously, read it
2023-04-13 13:22:31 -0400 < wasamasa> it's short
2023-04-13 13:22:49 -0400 < wasamasa> even R6RS is shorter than stuff like CL, JS, C, ...
2023-04-13 13:23:31 -0400 < wasamasa> here's an example of a procedure with specified evaluation order: https://srfi.schemers.org/srfi-1/srfi-1.html#map-in-order
2023-04-13 13:23:33 -0400 < cow_2001> 88 pages
2023-04-13 13:24:26 -0400 < wasamasa> yeah, that's nothing compared to the 1072 pages of CLTL
2023-04-13 13:24:30 -0400 < cow_2001> D:<
2023-04-13 13:24:55 -0400 < wasamasa> I wonder how many pages the R7RS-large SRFIs occupy so far
2023-04-13 13:24:59 -0400 < cow_2001> okay
2023-04-13 13:25:12 -0400 -!- DTAL is now known as dTal
2023-04-13 13:25:18 -0400 < wasamasa> several people claim that if they're done pumping them out, it will be more than CL has
2023-04-13 13:25:25 -0400 < cow_2001> i've been putting off reading the spec for a while now
2023-04-13 13:25:40 -0400 < cow_2001> these kind of things were always spooky to me
2023-04-13 13:25:41 -0400 < wasamasa> it's a bit weird to read, especially parts like how the macro system works
2023-04-13 13:26:18 -0400 < cow_2001> let's do it in parts, then
2023-04-13 13:26:29 -0400 < wasamasa> keep it handy as toilet lecture :>
2023-04-13 13:26:44 -0400 < wasamasa> I remember poring over the R5RS one several times until it eventually clicked
2023-04-13 13:27:08 -0400 < cow_2001> for a moment i thought you've written "porting over"
2023-04-13 13:27:11 -0400 < wasamasa> unlike a textbook, the standard is self-referential, so several reads are probably required
2023-04-13 13:28:36 -0400 < wasamasa> it's probably easier to remember which procedures always do things in order
2023-04-13 13:29:33 -0400 < cow_2001> you can always nest things if you're especially paranoid
2023-04-13 13:29:46 -0400 < wasamasa> yes, I use let* sometimes for this reason
2023-04-13 13:30:01 -0400 < wasamasa> which can be implemented in terms of nested let
2023-04-13 13:30:02 -0400 < cow_2001> okay, first paragraph done!
2023-04-13 13:30:53 -0400 < cow_2001> is there an r7rs in html form somewhere?
2023-04-13 13:31:03 -0400 < amirouche> https://scheme.rs
2023-04-13 13:31:03 -0400 < cow_2001> wait, i've got the internet
2023-04-13 13:31:11 -0400 < amirouche> I read there is another one, but I forgot the URL
2023-04-13 13:31:35 -0400 < cow_2001> oooooh!
2023-04-13 13:31:47 -0400 < amirouche> feel free to make feedback here (I put those pages together, that is only the second iteration ;)
2023-04-13 13:32:00 -0400 < amirouche> what are you looking for? there is also the procedure index somewhere
2023-04-13 13:32:05 -0400 < cow_2001> it looks a bit like… gemini!
2023-04-13 13:32:21 -0400 < wasamasa> the website linked above is a bit more than a HTML version
2023-04-13 13:32:24 -0400 < amirouche> see https://index.scheme.org/
2023-04-13 13:32:50 -0400 < wasamasa> whereas the scheme index I'm struggling to find a usecase for
2023-04-13 13:33:39 -0400 < cow_2001> https://index.scheme.org looks FANTASTIC!
2023-04-13 13:33:51 -0400 < cow_2001> it has a search thing
2023-04-13 13:34:01 -0400 < wasamasa> it looks pretty, but in terms of usability, nope
2023-04-13 13:34:07 -0400 < cow_2001> hmm
2023-04-13 13:34:14 -0400 < amirouche> yes!
2023-04-13 13:35:16 -0400 < amirouche> btw I and someone (Maxime?) are working on a Scheme hyperspec, that should solve all the problem on Earth
2023-04-13 13:35:34 -0400 < amirouche> ahem... sorry,,, it will just make Scheme easier to learn, and discover
2023-04-13 13:35:37 -0400 < wasamasa> feels like someone tried to learn several java search engine technologies and was looking for text to index with them
2023-04-13 13:36:17 -0400 < cow_2001> https://scheme.rs/discourse/ this comes out of nowhere
2023-04-13 13:36:24 -0400 < amirouche> yes :-)
2023-04-13 13:36:35 -0400 < amirouche> (On a related note I am lost about R7RS process..)
2023-04-13 13:36:59 -0400 < amirouche> wklew: did you find you way around the absence of module?
2023-04-13 13:38:02 -0400 < cow_2001> oh, index is not THE reference, it's just a searchable list of stuff
2023-04-13 13:38:55 -0400 < wasamasa> yeah
2023-04-13 13:39:01 -0400 < wasamasa> of function signatures mostly
2023-04-13 13:39:08 -0400 < amirouche> (module (abc def ijk) (define abc 1337) (define def 2006) (define ijk 3343)) can be translated into (define abc) (define def) (define ijk) (let () (set! abc 1337) (set! def 2006) (set! ijk 3343))
2023-04-13 13:39:19 -0400 < amirouche> as long as there is no macros involved ^ wklew
2023-04-13 13:39:40 -0400 < amirouche> that sometime used in chez scheme code, mit, and slib
2023-04-13 13:39:43 -0400 < cow_2001> it's good, though. reminds me of the haskell one
2023-04-13 13:39:56 -0400 < amirouche> the haskell equivalent of what?
2023-04-13 13:39:56 -0400 < cow_2001> hoogle?
2023-04-13 13:40:01 -0400 < wasamasa> ah yes
2023-04-13 13:40:05 -0400 < wasamasa> that would explain the design
2023-04-13 13:40:06 -0400 < cow_2001> https://hoogle.haskell.org/
2023-04-13 13:40:10 -0400 < amirouche> got it tx
2023-04-13 13:40:21 -0400 < cow_2001> i loved hoogle when i dabbled
2023-04-13 13:40:33 -0400 < amirouche> you do not know everything padawan!
2023-04-13 13:40:36 -0400 < acdw> I found r6rs in tex so I want to texinfo it
2023-04-13 13:40:45 -0400 < wasamasa> lol
2023-04-13 13:40:51 -0400 < cow_2001> i'm a perpetual newbie
2023-04-13 13:41:07 -0400 < cow_2001> acdw: O_O
2023-04-13 13:43:02 -0400 < amirouche> there is also identifier search across akku packages, with something like: https://html.duckduckgo.com/html/?q=site:https://akkuscm.org/identifiers/%20string-join
2023-04-13 13:43:06 -0400 < amirouche> that will look for string-join
2023-04-13 13:43:24 -0400 < wasamasa> ddg is not involved though, right
2023-04-13 13:43:36 -0400 < acdw> cow_2001: I hope I can anyway lol
2023-04-13 13:44:10 -0400 < wasamasa> isn't the thing with texinfo that it's a distinct language that compiles to either tex or info?
2023-04-13 13:44:39 -0400 < cow_2001> okay, pandoc --from html --to epub doesn't look TOO bad, maybe
2023-04-13 13:44:51 -0400 < acdw> aw damn is it?
2023-04-13 13:44:59 -0400 < amirouche> that is a perfect moment, to tell that I have been thinking about the "content-addressable Scheme code" again, I keep thinking about it day, and night but can't put together code about it. I will need to put myself in front of blank page, and write things down, and start coding at some point... there is a strange excitement about it, that push me away for some reason. It could be... wait for it...
2023-04-13 13:45:01 -0400 < acdw> i have no idea to be honest
2023-04-13 13:45:02 -0400 < amirouche> legendary ;)
2023-04-13 13:45:04 -0400 < wasamasa> yes, that is it
2023-04-13 13:45:07 -0400 < wasamasa> it's an odd duck
2023-04-13 13:45:09 -0400 < acdw> oh lol
2023-04-13 13:45:20 -0400 < wasamasa> the direction is texinfo->tex and texinfo->info
2023-04-13 13:45:23 -0400 < cow_2001> http://0x0.st/H8on.epub
2023-04-13 13:45:29 -0400 < cow_2001> 9fd5ccbfa373f6eb6ecbcb375548e4102d95c2a8c360913796eddf2ac2b93d9e
2023-04-13 13:45:32 -0400 < cow_2001> sha256
2023-04-13 13:45:33 -0400 < wasamasa> tex->texinfo requires assistance by brain.exe and/or pandoc
2023-04-13 13:45:51 -0400 < acdw> i'm bummed that apparently "native code binary" in chez scheme means that it compiles to a .so that you can then turn into a boot file that can be run by a renamed petite chez
2023-04-13 13:46:07 -0400 < acdw> so i think i'm sticking with CHICKEN or something
2023-04-13 13:46:30 -0400 < acdw> lol
2023-04-13 13:46:39 -0400 < wasamasa> I mean, that sounds like a deployment problem
2023-04-13 13:46:40 -0400 < amirouche> ?!
2023-04-13 13:47:13 -0400 < amirouche> Give me a moment
2023-04-13 13:47:18 -0400 < amirouche> I will clean the mess
2023-04-13 13:47:21 -0400 < wasamasa> and petit chez is supposed to be fast for an interpreter
2023-04-13 13:47:26 -0400 < acdw> yeah
2023-04-13 13:47:30 -0400 < wasamasa> unlike csi
2023-04-13 13:47:31 -0400 < amirouche> For some technical reason, my name is every on those pages
2023-04-13 13:47:38 -0400 < acdw> the boot up time is non trivial tho
2023-04-13 13:47:43 -0400 < wasamasa> well that sucks
2023-04-13 13:48:21 -0400 < acdw> hello world takes .446s
2023-04-13 13:48:28 -0400 < wasamasa> isn't there something like the python/guile/CL approach of compiling source files as they're loaded and using the result when running the source file the next time?
2023-04-13 13:48:37 -0400 < mnieper> acdw: Chez does compile to machine code.
2023-04-13 13:48:56 -0400 < mnieper> You can package its output into an executable binary.
2023-04-13 13:49:07 -0400 < wasamasa> yeah, there's at least one hacky script doing this
2023-04-13 13:49:11 -0400 < acdw> yeah that it does mnieper, but i couldn't find anywhere to package it into the executable
2023-04-13 13:49:26 -0400 < acdw> looking at chez website
2023-04-13 13:49:27 -0400 < wasamasa> https://github.com/gwatt/chez-exe
2023-04-13 13:49:27 -0400 < amirouche> acdw: look into chez-exe, and a wanna be better chez-exe @ https://github.com/letloop/cli
2023-04-13 13:49:28 -0400 < mnieper> acdw: Are you on GNU/Linux or Windows?
2023-04-13 13:49:41 -0400 < acdw> mnieper: gnu/linux
2023-04-13 13:49:42 -0400 < amirouche> good question
2023-04-13 13:49:50 -0400 < acdw> oh damn wasamasa thanks
2023-04-13 13:49:51 -0400 < mnieper> Then you don't need any chez-exe hack.
2023-04-13 13:49:59 -0400 < mnieper> It's all in the box.
2023-04-13 13:50:05 -0400 < acdw> oh lol
2023-04-13 13:50:33 -0400 < wasamasa> chez-exe shouldn't be a replacement for a traditional batch-compile workflow though
2023-04-13 13:50:44 -0400 < wasamasa> it's a deployment/packaging tool after all
2023-04-13 13:50:47 -0400 < acdw> can you point me to directions mnieper? i looked at chez's website in chapter 2 and tried what it said but it's like, yeah you need to make an .so and then you can rename the petite binary to the name of your boot file and have the boot file somewhere else
2023-04-13 13:51:06 -0400 < mnieper> give me a second
2023-04-13 13:51:31 -0400 < acdw> thank you :)
2023-04-13 13:51:50 -0400 < acdw> i was looking at r6rs and honeslty it looks totally fine for what i want to use scheme for, hoenstly maybe better since it has a few more batteries
2023-04-13 13:52:15 -0400 < amirouche> I am eager to read how marc does it
2023-04-13 13:52:57 -0400 < wasamasa> acdw: I'm sure I've asked you this before, but what exactly do you plan to do with scheme?
2023-04-13 13:53:30 -0400 < acdw> script mostly, but work my way up to bigger projects
2023-04-13 13:53:36 -0400 < wasamasa> the batteries in something like R6RS/R7RS are sufficient for building basic interpreters/compilers
2023-04-13 13:53:55 -0400 < wasamasa> or following infamous CS courses
2023-04-13 13:54:01 -0400 < acdw> yeah i was thinking of going for cyclone as well
2023-04-13 13:54:03 -0400 < amirouche> letloop's cli does what you want anyway
2023-04-13 13:54:09 -0400 < acdw> just no geiser integration (tho i could write that i spose)
2023-04-13 13:54:17 -0400 < wasamasa> beyond that you need SRFIs and other people's code
2023-04-13 13:54:43 -0400 < acdw> yeah
2023-04-13 13:54:44 -0400 < wasamasa> so having a clear idea what libraries you want helps with the decision because it makes clear how much code you have to port or even write yourself
2023-04-13 13:54:54 -0400 < mnieper> acdw: Geiser has Chez integration.
2023-04-13 13:55:04 -0400 < acdw> it does! pretty good chez integration even
2023-04-13 13:55:13 -0400 < cow_2001> wasamasa: infamous CS courses!
2023-04-13 13:55:14 -0400 < wasamasa> like, if you want to perform HTTP requests or use TLS or subprocesses, that reduces the amount of implementations you can use
2023-04-13 13:55:31 -0400 < amirouche> letloop is a chez scheme wrapper, you can use only the letloop compile subcommand once you want to ship your project
2023-04-13 13:55:37 -0400 < cow_2001> this one almost made me buy a fez hat
2023-04-13 13:55:48 -0400 < acdw> wasamasa: yeah that's the truth
2023-04-13 13:55:49 -0400 < wasamasa> maybe you want to talk to some database without having to use FFI
2023-04-13 13:55:59 -0400 < cow_2001> he really should sell Scheme fezes https://fez-o-rama.com/
2023-04-13 13:56:04 -0400 < wasamasa> or implement some weirdo wire protocol predating REST APIs
2023-04-13 13:56:05 -0400 < acdw> omg he should
2023-04-13 13:56:48 -0400 < mnieper> acdw: Back to executables: You write a short Scheme script as follows:
2023-04-13 13:56:55 -0400 < mnieper> (import (chezscheme))
2023-04-13 13:57:03 -0400 < mnieper> (compile-file-message #f)
2023-04-13 13:57:10 -0400 < mnieper> (compile-imported-libraries #t)
2023-04-13 13:57:14 -0400 < cow_2001> this one https://en.wikipedia.org/wiki/Knights_of_the_Lambda_Calculus
2023-04-13 13:57:21 -0400 < mnieper> (generate-wpo-files #t)
2023-04-13 13:57:24 -0400 < cow_2001> but maybe it's trademarked
2023-04-13 13:57:43 -0400 < wasamasa> I completely missed that reference in SEL
2023-04-13 13:57:54 -0400 < wasamasa> I spotted the lisp, yes, but not the rest
2023-04-13 13:57:57 -0400 < cow_2001> wasamasa: :D
2023-04-13 13:58:02 -0400 < mnieper> (compile-program "PROGRAM-FILE.sps" "PROGRAM-FILE.so")
2023-04-13 13:58:35 -0400 < mnieper> (compile-whole-program "PROGRAM-FILE.wpo" "EXECUTABLE-FILE")
2023-04-13 13:58:40 -0400 < acdw> also can yall explain to me the difference b/w .ss, .sps, .sls files? or is that in the r6rs spec
2023-04-13 13:58:51 -0400 < mnieper> acdw: One step at a time
2023-04-13 13:59:00 -0400 < wasamasa> scheme source, scheme program source, scheme library source, ...
2023-04-13 13:59:10 -0400 < cow_2001> okay, i think i'll go on a walk. thanks everyone!
2023-04-13 13:59:13 -0400 < mnieper> .sps is the typical extension for an R6RS top-level program (your main program)
2023-04-13 14:00:01 -0400 < acdw> ahh
2023-04-13 14:00:26 -0400 < mnieper> When you add "#!/usr/bin/env scheme-script" at the top of your main program (the .sps file), the whole process copies it as the first line of your binary so that the Linux kernel knows which file it has to use to run the executable.
2023-04-13 14:00:44 -0400 < mnieper> The rest of the output will just be binary gibberish
2023-04-13 14:01:14 -0400 < amirouche> re compiling chez code, letloop cli does that and does it better, give it a try, it is one second experiment.
2023-04-13 14:01:37 -0400 < wasamasa> you know, maybe you should call it something else if it's not letloop-specific
2023-04-13 14:01:52 -0400 < mnieper> Where compiled C programs (usually) need some shared libs to work, Chez's binary output need its own runtime (which should be linked to scheme-script).
2023-04-13 14:02:08 -0400 < acdw> yeah
2023-04-13 14:02:35 -0400 < acdw> as opposed to say CHICKEN which compiles to C and then can statically link itself
2023-04-13 14:02:39 -0400 < acdw> if you wan tot
2023-04-13 14:02:40 -0400 < acdw> to
2023-04-13 14:02:51 -0400 < acdw> i guess i'm a newbie with software like, packaging and development
2023-04-13 14:03:03 -0400 < mnieper> When the Linux kernel loads an ELF file (the typical output of a C compiler), it (usually) also hands over the actual interpretation to another program (the dynamic loader).
2023-04-13 14:03:10 -0400 < wasamasa> yes, I've done this out of laziness because the server I'm deploying to is slow and runs a different version than the computer I'm developing on
2023-04-13 14:03:21 -0400 < wasamasa> that gave me 5M binaries doing very simple networking tasks
2023-04-13 14:03:29 -0400 < wasamasa> I guess it's better than go
2023-04-13 14:03:41 -0400 < amirouche> everybody needs to start somewhere :)
2023-04-13 14:03:55 -0400 < mnieper> The nice thing with the setup I explained is that Chez then only rebuilds the libraries when needed.
2023-04-13 14:04:14 -0400 < mnieper> It has its own "Make" built-in.
2023-04-13 14:04:33 -0400 < acdw> mnieper: whence the .wpo file?
2023-04-13 14:04:34 -0400 < mnieper> You can even give it a different build than source directory if you have VPATH set-up.
2023-04-13 14:05:08 -0400 < mnieper> For maximum efficiency.  The compiler is so blazingly fast that WPO is usually the best choice.
2023-04-13 14:05:33 -0400 < acdw> i think i missed a line in your copy-paste, it complains there is no wpo file
2023-04-13 14:05:53 -0400 < acdw> nope i lied b/c i was wrong
2023-04-13 14:06:08 -0400 < gwatt> "wpo" stand for "whole program optimization", and enabled faster compiled code, as well as putting everything in one file.
2023-04-13 14:06:09 -0400 < mnieper> You know what, I am going to set up a small repo to show working code.
2023-04-13 14:06:10 -0400 < amirouche> cow_2001: look scheme.rs/scheme.rs.epub
2023-04-13 14:06:34 -0400 < gwatt> You need to have (generate-wpo-files #t) before you run (compile-program ...)
2023-04-13 14:06:43 -0400 < mnieper> acdw: If you have 5 minutes
2023-04-13 14:06:48 -0400 < amirouche> that is what I did
2023-04-13 14:06:59 -0400 < amirouche> What is the problem with letloop cli ?
2023-04-13 14:07:03 -0400 < acdw> i copy-pasted the thing, it worked now
2023-04-13 14:07:19 -0400 < acdw> i was building everything in a bin/ folder and thought .wpo would be in the top folder
2023-04-13 14:07:23 -0400 < acdw> b/c i wasn't thinking, lol
2023-04-13 14:08:25 -0400 < acdw> it worked! thanks :) still takes a while to boot tho
2023-04-13 14:08:34 -0400 < acdw> tho with longer running programs that will matter less
2023-04-13 14:08:37 -0400 < mnieper> How long?
2023-04-13 14:09:00 -0400 < acdw> 0.461 seconds for hello world
2023-04-13 14:09:54 -0400 < amirouche> cow_2001: the epub works on my iphone
2023-04-13 14:10:02 -0400 < amirouche> but firefox epub reading is struggling
2023-04-13 14:10:58 -0400 < acdw> that epub doesn't work at all for me
2023-04-13 14:11:49 -0400 < gwatt> acdw: IIRC much of that is inflating the .boot files. How long does `petite < /dev/null` take?
2023-04-13 14:12:15 -0400 < acdw> 0.270s
2023-04-13 14:12:19 -0400 < acdw> yeah i figured a lot of it was that
2023-04-13 14:12:34 -0400 < amirouche> Probably mnieper ignored me, but still acdw what marc is describing we have already talked about, the cli, I had to put together, it to avoid to have those convos all the time about how to do basic things. In a couple of week you will come back with how to do profiling, how to generate coverage, how to set optimization level etc... what leloop does
2023-04-13 14:13:10 -0400 < acdw> letloop looks like a cloud thing?
2023-04-13 14:13:36 -0400 < acdw> oh i see, the cli
2023-04-13 14:13:38 -0400 < amirouche> acdw: na, that is subproject, letloop/cli is just a command line wrapper around what marc described, and more
2023-04-13 14:14:04 -0400 < wasamasa> the name is still pretty bad
2023-04-13 14:14:12 -0400 < wasamasa> even if you chop off the letloop bit
2023-04-13 14:14:29 -0400 < acdw> /cli? :P
2023-04-13 14:14:46 -0400 < amirouche> acdw: what reader do you use for the epub?
2023-04-13 14:15:08 -0400 < acdw> it opened in ... evince i think? I was going to open it in nov.el so let me try that too
2023-04-13 14:15:30 -0400 < mnieper> acdw: https://gitlab.com/nieper/chez-example-program
2023-04-13 14:16:06 -0400 < amirouche> I shoud coordinate with Vincent to properly fix that, but since the R7RS/R6RS bis is complicated story, I think I will do nothing until that settle down
2023-04-13 14:16:07 -0400 < acdw> amirouche: yeah nov.el totally freked out
2023-04-13 14:16:21 -0400 < wasamasa> hrhr
2023-04-13 14:16:22 -0400 < amirouche> acdw: indeed, ios book struggle too at the end
2023-04-13 14:16:25 -0400 < amirouche> meh
2023-04-13 14:16:31 -0400 < mnieper> amirouche: I haven't yet found the time to look at letloop/cli
2023-04-13 14:16:32 -0400 < amirouche> nevermind, forget about it
2023-04-13 14:16:54 -0400 < amirouche> acdw: I mean, the epub is broken, the pdf is broken.
2023-04-13 14:17:05 -0400 < amirouche> mnieper: feedback welcome :)
2023-04-13 14:17:06 -0400 < wasamasa> yes
2023-04-13 14:17:08 -0400 < acdw> mnieper: thanks so much!@
2023-04-13 14:17:13 -0400 < wasamasa> nov.el intentionally doesn't support invalid files
2023-04-13 14:17:29 -0400 < mnieper> acdw: The hello world in my example just needs 0,044s
2023-04-13 14:17:33 -0400 < wasamasa> and the first (and hopefully last) error is a missing title
2023-04-13 14:17:36 -0400 < acdw> wasamasa: yeah it was invalid
2023-04-13 14:17:52 -0400 < acdw> mnieper: let me try your example. my program was looking at (command-line)
2023-04-13 14:17:54 -0400 < mnieper> And 0,023s user
2023-04-13 14:18:18 -0400 < mnieper> Just type make && ./main
2023-04-13 14:19:07 -0400 < mnieper> The compiled code just occupies 3927 bytes.
2023-04-13 14:19:42 -0400 < acdw> still takes the same amount of time on my machine
2023-04-13 14:19:47 -0400 < acdw> which means it's my machine! yaaayyy
2023-04-13 14:20:29 -0400 < acdw> mine takes up 3933 bytes, so it must be those extra 6 bytes that spend 10x the time :P
2023-04-13 14:21:40 -0400 < mnieper> rofl
2023-04-13 14:21:54 -0400 < mnieper> What CPU do you have?
2023-04-13 14:22:05 -0400  * mnieper checking his.
2023-04-13 14:22:10 -0400 < wasamasa> actually, the title thing was a warning, hm
2023-04-13 14:22:23 -0400 < wasamasa> I can navigate the EPUB just fine
2023-04-13 14:23:07 -0400 < wasamasa> amirouche: you may want to fix all the errors epubcheck is reporting
2023-04-13 14:23:23 -0400 < mnieper> acdw: /proc/cpuinfo says 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz here.
2023-04-13 14:23:23 -0400 < mnieper>
2023-04-13 14:24:09 -0400 < acdw> mnieper: Intel(R) Core(TM) i7-10510U CPU @ 1.80GHz
2023-04-13 14:24:29 -0400 < acdw> ah there ya go, you have a faster clock or ... whatever
2023-04-13 14:24:56 -0400 < wasamasa> computer goes brrrer
2023-04-13 14:25:08 -0400 < acdw> lmao
2023-04-13 14:25:28 -0400 < acdw> my computer has also been mad at me today so maybe that's why hello world is taking longer
2023-04-13 14:27:54 -0400 < mnieper> acdw: The CPUs shouldn't make much of a difference; I am not even sure that mine runs ever at 2.8 GHz when I start the hello-world program because I am currently running on batteries.
2023-04-13 14:28:09 -0400 < acdw> hm well, who knows then! :P
2023-04-13 14:28:13 -0400 < acdw> i'll keep playing with chez
2023-04-13 14:28:34 -0400 < mnieper> Give your computer a good night of sleep. :)
2023-04-13 14:28:44 -0400 < mnieper> Do you like TSPL to learn Scheme?
2023-04-13 14:28:53 -0400 < wasamasa> you sure it's not some silly mistake that makes things recompile on every run?
2023-04-13 14:30:16 -0400 < Zipheir> Dybvig's writing is precise, but not fun to read.
2023-04-13 14:30:25 -0400 < acdw> what's TSPL?
2023-04-13 14:30:38 -0400 < gwatt> could also be difference in disk speed. Spinning rust vs SSD vs NVME
2023-04-13 14:30:47 -0400 < gwatt> acdw: The Scheme Programming Language
2023-04-13 14:30:53 -0400 < acdw> ohhh i haven't
2023-04-13 14:30:56 -0400 < gwatt> https://scheme.com/tspl4/
2023-04-13 14:31:14 -0400 < acdw> wasamasa: i did exactly what mnieper did
2023-04-13 14:31:28 -0400 < wasamasa> did you try the repo linked above?
2023-04-13 14:31:31 -0400 < gwatt> It documents R6RS, so pretty good for chez
2023-04-13 14:32:13 -0400 < acdw> i did
2023-04-13 14:32:23 -0400 < acdw> gwatt: i'll have to check it out :)
2023-04-13 14:32:39 -0400 < acdw> wasamasa: i git clone <repo>; cd <repo>; make ; time ./main
2023-04-13 14:33:27 -0400 < mnieper> Zipheir: Things like this are always fun to read: https://www.scheme.com/tspl4/examples.html#./examples:h10
2023-04-13 14:34:13 -0400 < mnieper> gwatt: "spinning rust" is great; have never heard this before!
2023-04-13 14:34:18 -0400 < Zipheir> Wow.
2023-04-13 14:34:52 -0400 < Zipheir> "As a brief example... unification!"
2023-04-13 14:34:55 -0400 < mnieper> Zipheir: I don't need Alyssa P. Hacker in every book. :)
2023-04-13 14:35:01 -0400 < Zipheir> The info density is high.
2023-04-13 14:35:21 -0400 < Zipheir> I prefer elegant writing over concrete.
2023-04-13 14:36:02 -0400 < Zipheir> _Gödel's Proof_ by Nagel and Newman is one of my benchmarks for nice exposition.
2023-04-13 14:36:07 -0400 < Zipheir> So is K & R.
2023-04-13 14:37:14 -0400 < Zipheir> A nicely-written book, unfortunately out of print, is _Scheme and the Art of Programming_, by Springer and Friedman.
2023-04-13 14:37:19 -0400 < cow_2001> okay, 6%. errors section. i haven't really catched any errors yet, so it goes high above over my brain. i did in python, but not in scheme.
2023-04-13 14:37:21 -0400 < mnieper> I didn't know about Nagel/Newman
2023-04-13 14:37:37 -0400 < Zipheir> Gödel's Proof is a great little book.
2023-04-13 14:38:01 -0400 < cow_2001> what's it like to be a thomas nagel?
2023-04-13 14:38:01 -0400 < mnieper> Does it do everything rigorously?
2023-04-13 14:40:06 -0400 < Zipheir> No, they summarize a lot of the hard parts.
2023-04-13 14:41:38 -0400 < cow_2001> whenever i see "chez" i am thinking of a guy named chaz living in a van and wasting his brain on weed :|
2023-04-13 14:41:58 -0400 < acdw> lmao
2023-04-13 14:42:12 -0400 < cow_2001> i cannot help it :(
2023-04-13 14:42:33 -0400 < cow_2001> i'm prejudiced against people named chaz
2023-04-13 14:42:39 -0400 < acdw> how about billy scheme
2023-04-13 14:43:30 -0400 < cow_2001> billy is either a small boy or a billy bob, which is better. i like dueling banjos.
2023-04-13 14:43:42 -0400 < cow_2001> too much hollywood is living in my brain ~;~
2023-04-13 14:44:06 -0400 < acdw> lmao
2023-04-13 14:45:19 -0400 < Zipheir> In the CS world, though, I think Brian Kernighan is a master of clear, interesting writing.
2023-04-13 14:45:36 -0400 < Zipheir> Everybody who wants to write about programming should read his books.
2023-04-13 14:45:58 -0400 < wasamasa> cow_2001: is chaz a legit name?
2023-04-13 14:46:19 -0400 < cow_2001> at least a nickname / shorthand
2023-04-13 14:46:29 -0400 < Zipheir> wasamasa: Wikipedia says "Chaz (less frequently Chas or Chazz) is an English masculine given name or nickname, originally derived from a short form of Charles (abbreviated Chas.), although it is also used occasionally as a short form of other given names such as Chastity or Charlton."
2023-04-13 14:46:51 -0400 < wasamasa> names be weird
2023-04-13 14:46:52 -0400 < mnieper> Zipheir: Two very good reads about a programming language are the R6RS and the R7RS!  Seriously!
2023-04-13 14:47:13 -0400 < cow_2001> everyone are raving about the rnrs ~;~
2023-04-13 14:47:17 -0400 < Zipheir> mnieper: They're some of the best-written standards.
2023-04-13 14:48:00 -0400 < cow_2001> hey, what do you think of the 0mq spec?
2023-04-13 14:48:12 -0400 < Zipheir> But they aren't expositions of Scheme for people who don't have a programming languages background.
2023-04-13 14:48:26 -0400 < cow_2001> there's also rfc 8174 which i think is rather funny
2023-04-13 14:48:30 -0400 < acdw> the problem with wanting to write a scheme impl is that i don't really know any other programming languages to write a scheme impl in
2023-04-13 14:48:39 -0400 < acdw> i guess i could do scheme in scheme
2023-04-13 14:48:52 -0400 < wasamasa> of course you can
2023-04-13 14:49:06 -0400 < cow_2001> okay, now really going for a walk
2023-04-13 14:49:06 -0400 < wasamasa> bootstrapping is an issue, but doable
2023-04-13 14:49:35 -0400 < acdw> ooo
2023-04-13 14:49:47 -0400 < mnieper> acdw: https://www.scheme.com/tspl4/examples.html#./examples:h7
2023-04-13 14:49:50 -0400 < acdw> i guess i should like, learn more frist
2023-04-13 14:49:54 -0400 < wasamasa> of course
2023-04-13 14:50:25 -0400 < wasamasa> the other question is whether you want to implement an entire scheme as there's quite a bit of work involved
2023-04-13 14:50:29 -0400 < mnieper> SICP also has a lot to say about meta-circular interpreters.
2023-04-13 14:50:44 -0400 < acdw> how about circa-metular
2023-04-13 14:50:51 -0400 < acdw> thanks for the link mnieper :)O
2023-04-13 14:51:03 -0400 < Zipheir> wasamasa is right. Implementing a real Scheme is hard work.
2023-04-13 14:51:10 -0400 < Zipheir> Better to explore for a while.
2023-04-13 14:51:17 -0400 < wasamasa> but if you stick to some very well defined subset, it is doable
2023-04-13 14:51:32 -0400 < wasamasa> nevertheless I've run into a number of people who ended up implementing something more tractable
2023-04-13 14:51:40 -0400 < Zipheir> You'll learn more by implementing many different kinds of small languages.
2023-04-13 14:51:55 -0400 < Zipheir> EOPL may be a good resource for ideas.
2023-04-13 14:52:06 -0400 < wasamasa> my favorite bootstrapping tale is http://web.archive.org/web/20061108010907/http://www.rano.org/bcompiler.html
2023-04-13 14:52:19 -0400 < mnieper> SICP let's you write a compiler in the last section.
2023-04-13 14:52:38 -0400 < Zipheir> An infamous exercise.
2023-04-13 14:52:40 -0400 < wasamasa> because it includes the mistakes that happened
2023-04-13 14:52:42 -0400 < mnieper> s/let's/lets
2023-04-13 14:55:12 -0400 < Zipheir> acdw: With a simple interpreter framework, you can do a lot. E.g., you can take a minimal Scheme-like language and try adding first-class continuations.
2023-04-13 14:55:50 -0400 < Zipheir> This is much less scary when you aren't trying to hit all of the targets required by some standard.
2023-04-13 14:56:19 -0400 < acdw> haha yeah, makes sense
2023-04-13 14:56:40 -0400 < wasamasa> still, I'd skip continuations
2023-04-13 14:56:57 -0400 < wasamasa> the trade-offs are too much
2023-04-13 14:57:09 -0400 < Zipheir> It depends on what you're trying to do.
2023-04-13 14:57:39 -0400 < Zipheir> Implementing first-class continuations in a variety of interpreters/compilers is a great way to learn about them.
2023-04-13 14:58:00 -0400 < Zipheir> I didn't fully understand shift/reset until I did that.
2023-04-13 14:58:18 -0400 < wasamasa> yeah, but even if I understood it, I very rarely use them and they complicate program semantics too much
2023-04-13 14:58:24 -0400 < Zipheir> (Well, I'm not sure I yet fully understand it.)
2023-04-13 14:58:28 -0400 < wasamasa> depending on the implementation, they complicate debugging, too
2023-04-13 14:58:31 -0400 < acdw> i've used continuations like, twice!
2023-04-13 14:58:39 -0400 < Zipheir> wasamasa: Where's your sense of fun? :)
2023-04-13 14:59:04 -0400 < wasamasa> my idea of fun is to ruin someone's day with a security bug report
2023-04-13 14:59:13 -0400 < Zipheir> :(
2023-04-13 14:59:16 -0400 < wasamasa> sorry
2023-04-13 14:59:46 -0400 < wasamasa> but computers, not really
2023-04-13 14:59:51 -0400 < Zipheir> Well, this stuff is supposed to be enjoyable.
2023-04-13 15:00:08 -0400 < wasamasa> I enjoy making them things they're not supposed to do, basically
2023-04-13 15:00:24 -0400 < dTal> that's kinda dark
2023-04-13 15:00:32 -0400 < wasamasa> no, that's known as hacking
2023-04-13 15:00:37 -0400 < wasamasa> even RMS has figured that out
2023-04-13 15:00:48 -0400 < acdw> h4x0r
2023-04-13 15:01:30 -0400 < wasamasa> although he seems to appreciate other people's jokes (like using punny project names) less the older he gets
2023-04-13 15:04:24 -0400 < Zipheir> acdw: You might check out Will Byrd's hilarious and sometimes deep talk about interpreters, "The Most Beautiful Program Ever Written" https://www.youtube.com/watch?v=OyfBQmvr2Hc
2023-04-13 15:05:06 -0400 < acdw> i've seen it! it's great
2023-04-13 15:05:10 -0400 < Zipheir> Good :)
2023-04-13 15:05:41 -0400 < acdw> wasamasa: indeed, lately it's all "this should be called extremely-boring-and-barely-descriptive-name.el
2023-04-13 15:37:05 -0400 < mnieper> Writing a compiler for C (or some sane subset of it, let us call it Pascal) is probably easier than writing a compiler for Scheme.  In Scheme, you have to deal with tail calls, closures, garbage collection, first-class continuations, eval, ...
2023-04-13 15:44:55 -0400 < wasamasa> sigh
2023-04-13 15:44:57 -0400 < Oxyd> That probably depends on how sophisticated you want each compiler to be. Old versions of the original C compiler were a few thousand lines of code, because C was pretty much just fancy assembly at that point.
2023-04-13 15:44:58 -0400 < mnieper> amirouche: Found the time to have a 10 second-glance at letloop/cli.  Why do you create a custom boot file for a Chez project?
2023-04-13 15:45:27 -0400 < wasamasa> first I've defined a mutilate procedure, now I'm stumbling over use of iota with a step argument
2023-04-13 15:45:34 -0400 < wasamasa> I guess it's time to turn off the computer
2023-04-13 15:47:03 -0400 < acdw> if it's not from the c region of France it's just sparkling assembler
2023-04-13 15:47:39 -0400 < mnieper> This one is nice: https://www.pcengines.ch/tp3.htm
2023-04-13 15:48:01 -0400 < mnieper> At least for those of us who can still remember the great days of TP3.
2023-04-13 15:48:23 -0400 < wasamasa> I only remember going through a "turbopascal for kids" book
2023-04-13 15:49:45 -0400 < mnieper> It probably only takes a day to rewrite the TP3 compiler in Scheme (given the information on that webpage).
2023-04-13 15:51:01 -0400 < wasamasa> the above link reminds me of this tutorial: https://compilers.iecc.com/crenshaw/
2023-04-13 15:52:03 -0400 < mnieper> Thanks for the link, wasamasa!
2023-04-13 15:52:31 -0400 < wasamasa> you're welcome
2023-04-13 16:00:38 -0400 < Zipheir> Reminds me of Let's Build a Compiler! https://compilers.iecc.com/crenshaw/
2023-04-13 16:05:43 -0400 < wasamasa> did we both post the same link
2023-04-13 16:07:40 -0400 < Zipheir> Er, oops. And with nearly the same comment.
2023-04-13 16:08:01 -0400 < Zipheir> Every compiler discussion reminds people of Crenshaw's tutorial.
2023-04-13 16:08:41 -0400 < wasamasa> it's a very approachable tutorial
2023-04-13 16:08:43 -0400 < acdw> lol
2023-04-13 19:06:34 -0400  * tomhg reads bottom-to-top and appreciates joining just now.
2023-04-13 19:08:03 -0400 < tomhg> I am stuck at refactoring and hereby inquire help in a few. If anyhone got some hands-on reference (as in git history of refactoring a mid-sizes procedural program (but Haskell) please forwards any suggestions.
2023-04-13 19:08:11 -0400 < tomhg> over and out.
2023-04-13 19:16:33 -0400 < flatwhatson> i have been thinking it would be nice to have a scheme oracle. curate a big database of manuals, source code, and papers, then embed them all in some useful LLM and use them as context for a chat bot
2023-04-13 19:21:40 -0400 < amirouche> indeed
2023-04-13 19:21:54 -0400 < amirouche> I looked at opensource LLM but none support that feature
2023-04-13 19:22:05 -0400 < amirouche> it requires to finetune an existing LLM
2023-04-13 19:22:13 -0400 < amirouche> and for that it requires a GPU, and I don't
2023-04-13 19:22:20 -0400 < amirouche> bring up the idea on schemeorg@
2023-04-13 19:22:45 -0400 < amirouche> maybe someone can sponsors a server with GPUs
2023-04-13 19:23:01 -0400 < amirouche> To get started you could work with openai?
2023-04-13 19:23:06 -0400 < wasamasa> have you considered doing something similar to the scheme index instead?
2023-04-13 19:23:15 -0400 < amirouche> flatwhatson: I can sponsort the bindings for openai, if you want :)
2023-04-13 19:23:21 -0400 < flatwhatson> i'm not sure fine-tuning is needed, at least openai have an "embedding" API where you generate vectors for each document and create a local vector database
2023-04-13 19:23:21 -0400 < Oxyd> A database like that would be useful even without a AI to interface with it.
2023-04-13 19:23:29 -0400 < wasamasa> that is, spending all that effort on creating a specialized search engine
2023-04-13 19:23:45 -0400 < flatwhatson> queries are done by embedding the query, searching the local db for close references, then putting all that as context into a prompt for the chat bot
2023-04-13 19:23:53 -0400 < flatwhatson> like how bing can search before answering
2023-04-13 19:24:13 -0400 < amirouche> Isn't what you describe just vector search ?
2023-04-13 19:24:31 -0400 < amirouche> s/just//
2023-04-13 19:24:39 -0400 < wasamasa> no, what I describe traditionally involves massaging a bunch of java products
2023-04-13 19:24:49 -0400 < flatwhatson> yes but vectors are generated by the LLM, so hopefully do a decent job of modelling subtler relationships
2023-04-13 19:24:55 -0400 < amirouche> You need a LLM to convert the documents to vector embedding
2023-04-13 19:25:00 -0400 < amirouche> agreed
2023-04-13 19:25:02 -0400 < amirouche> :)
2023-04-13 19:26:25 -0400 < flatwhatson> i have been working on openai bindings: https://notabug.org/flatwhatson/guile-openai/
2023-04-13 19:26:56 -0400 < flatwhatson> not done embeddings yet, but i just got multipart/form-data uploads working so that can come quite soon
2023-04-13 19:29:33 -0400 < amirouche> I can work on putting together a database of content
2023-04-13 19:29:54 -0400 < amirouche> I will rely on a closed source program, but I will export everything later
2023-04-13 19:30:05 -0400 < amirouche> is that ok with you ?
2023-04-13 19:30:28 -0400 < amirouche> erm...
2023-04-13 19:30:29 -0400 < flatwhatson> absolutely!
2023-04-13 19:30:31 -0400 < amirouche> Maybe the first question, is do you want my help?
2023-04-13 19:31:18 -0400 < flatwhatson> yes please! just the data collection is a huge job on its own :)
2023-04-13 19:31:52 -0400 < flatwhatson> then there's a challenge of generating useful embeddings, because this requires chunking the source material into reasonable pieces
2023-04-13 19:37:07 -0400 < flatwhatson> also we should be able to expand the database over time, maybe have some human-powered submission process.  i guess that's done well enough with a pull request these days.
2023-04-13 19:37:40 -0400 < amirouche> implement mutlipart/form-data
2023-04-13 19:37:42 -0400 < amirouche> ;)
2023-04-13 19:37:54 -0400 < amirouche> I deal with data acquisition in the meantime
2023-04-13 19:38:11 -0400 < amirouche> btw, you want something like: https://www.phind.com/
2023-04-13 19:39:18 -0400 < flatwhatson> yes i guess so.  i haven't played with it, but one thing i think is important is maintaining proper references
2023-04-13 19:40:10 -0400 < amirouche> agreed
2023-04-13 19:40:22 -0400 < flatwhatson> it should be able to operate as an actually useful research assistant, with accurate provenance
2023-04-13 19:40:55 -0400 < flatwhatson> hence having some curation of the data set to ensure copyrights & licenses & academic integrity are preserved
2023-04-13 19:40:56 -0400 < amirouche> reference, lineage, authorship, foaf
2023-04-13 19:41:18 -0400 < amirouche> I believe we are aligned
2023-04-13 19:41:21 -0400 < amirouche> here
2023-04-13 19:41:30 -0400 < flatwhatson> cool :)
2023-04-13 19:56:48 -0400 < amirouche> tho, we agree that work will be floss or something?
2023-04-13 19:58:03 -0400 < flatwhatson> yes, i see this kind of effort as wasted otherwise
2023-04-13 19:59:58 -0400 < amirouche> :)
2023-04-13 20:00:36 -0400 < amirouche> what makes me crazy with the kind of apps like phinds, but producthunt leveraged that /scheme/ to an industrial web scale level, is how easy it is for them to gather user feedback, needs, dreams, wishes
2023-04-13 20:01:20 -0400 < flatwhatson> there is a "gold rush" coming on building these kind of systems for private datasets, but systems built on public data sets should be public access
2023-04-13 20:01:30 -0400 < amirouche> when I ask someone what app can fix help them, they reply either 1) do you make games 2) can I be part of your startup?
2023-04-13 20:01:58 -0400 < amirouche> 2) is basically, you will make money with my idea, I want to be part of it.
2023-04-13 20:02:18 -0400 < amirouche> but they have no problem giving away their ideas to established projects -_-'
2023-04-13 20:02:34 -0400 < amirouche> that is a *check directory* pity
2023-04-13 20:03:01 -0400 < flatwhatson> ideas are cheaper than ever with current gen LLMs :)
2023-04-13 20:03:28 -0400 < dTal> Do LLMs come up with ideas, really?
2023-04-13 20:04:00 -0400 < flatwhatson> yes i think so, most "app" ideas are a mashup of existing concepts
2023-04-13 20:40:55 -0400 < amirouche> what do you link for the text on the button to submit a ressource?
2023-04-13 20:41:23 -0400 < amirouche> Usually it is "submit" what else can it be?
2023-04-13 20:42:38 -0400 < wklew> Is there an SRFI that lets me get the current directory path?
2023-04-13 20:42:56 -0400 < wklew> I'm trying to make include work in a predictable way
2023-04-13 20:44:11 -0400 < flatwhatson> wklew: SRFI-170 (current-directory)
2023-04-13 20:46:44 -0400 < wklew> flatwhatson: great ty!
2023-04-13 20:46:45 -0400 < flatwhatson> tbh that bug looks genuine, and should be fixed in guile (maybe email & bump the bug?)
2023-04-13 20:47:34 -0400 < flatwhatson> for a workaround, the least painful option would be to make a guile-specific non-portable loader
2023-04-13 20:57:46 -0400 < mdhughes> I have a general example of a program with modules, compiling where possible, in multiple Scheme impls. https://mdhughes.tech/scheme/ or it's on the wiki, but less maintained
2023-04-13 21:00:10 -0400 < mdhughes> I don't bother with the crazy filename extensions, unless I'm making a cross-impl program.
2023-04-13 21:01:08 -0400 < wklew> mdhughes: do you have examples with include rather than import? I'm struggling with the different ways impls treat filenames for include.
2023-04-13 21:02:56 -0400 < mdhughes> I haven't tested all those, and yes, they have different and often stupid path rules.
2023-04-13 21:03:17 -0400 < mdhughes> The imports are difficult enough, *usually* relative to the main script but not always.
2023-04-13 21:04:06 -0400 < wklew> So far I've tried chibi and guile; chibi looks relative to the REPL dir, whereas guile looks relative to the including file...
2023-04-13 21:04:58 -0400 < wklew> At least I can (cond-expand (guile (define prefix "../")) (chibi (define-prefix ""))) or some such
2023-04-13 21:05:55 -0400 < mdhughes> I am going thru some of them to put in worker.sld which includes worker.ss/scm, and it's revealed some weird bugs.
2023-04-13 21:06:02 -0400 < wklew> Oh that doesn't work because include requires a literal string
2023-04-13 21:16:57 -0400 < wklew> Oh ok, library-level include actually behaves consistently b/w guile and chibi. I think someone mentioned that.
2023-04-13 22:50:04 -0400 < amirouche> I am deploying the form
2023-04-13 22:50:13 -0400 < amirouche> just a couple of minutes ;)
2023-04-13 22:50:29 -0400 < amirouche> flatwhatson: you there?
2023-04-13 22:54:41 -0400 < acdw> mdhughes: oh my God this is amazing
2023-04-13 22:56:15 -0400 < mdhughes> Thank you. It's infuriating that so many have no consistency, or make the weirdo choices.
2023-04-13 23:10:02 -0400 < amirouche> weirdo
2023-04-13 23:10:21 -0400 < amirouche> :)
2023-04-13 23:10:31 -0400 < amirouche> gambit has the best library resolution algorithm, except gambit is the only one to use that algo
2023-04-13 23:10:50 -0400 < amirouche> (foo bar) is looked up first inside foo/bar/bar.sld then in foo/bar.sld
2023-04-13 23:10:58 -0400 < amirouche> that allows to move foo/bar/ more easily
2023-04-13 23:11:03 -0400 < acdw> mdhughes: you said it! I've just started on this journey and boy howdy
2023-04-13 23:11:19 -0400 < acdw> I somehow overlooked gambit....
2023-04-13 23:12:22 -0400 < amirouche> yeah scheme industry... is quiet a beast on its own.
2023-04-13 23:12:48 -0400 < mdhughes> Oh, gambit's fine, except the part where it'll go up to github and load code remotely without telling you, ignoring local files!
2023-04-13 23:12:57 -0400 < amirouche> oh no
2023-04-13 23:13:30 -0400 < mdhughes> And it doesn't search from the source file, but PWD or install path, unless you set a flag.
2023-04-13 23:14:21 -0400 < mdhughes> I love what Marc does with it, generally, but SIGH. I'd like to have everyone ship software in production just once to see how broken their systems are.
2023-04-13 23:14:59 -0400 < mdhughes> You know who's perfect? Chez & CHICKEN. Racket's not bad at it.
2023-04-13 23:15:54 -0400 < flatwhatson> amirouche: hi :)
2023-04-13 23:18:00 -0400 < amirouche> I can't deploy https, but I have a form ready to in a couple of minutes xx
2023-04-13 23:18:13 -0400 < amirouche> It is very likely I will succeed at deploying it
2023-04-13 23:18:16 -0400 < amirouche> x')
2023-04-13 23:18:19 -0400 < amirouche> this time
2023-04-13 23:31:27 -0400 < amirouche> (: that is very funny :)
2023-04-13 23:33:49 -0400 < amirouche> http://135.181.104.114/
2023-04-13 23:34:34 -0400 < amirouche> I spent 10 minutes configuring, and reconfiguring nginx, because I made a copy paste mistake in the browser hiting http://135.181.104.11/ instead of the correct http://135.181.104.114/
2023-04-13 23:35:17 -0400 < acdw> maybe chez is the vibe. chicken is nice, I like the c ness
2023-04-13 23:36:20 -0400 < mdhughes> Chez's very slightly faster compiled, and the REPL is fast. CHICKEN's compiler takes a while to grind, and the interpreter is slow as hell.
2023-04-13 23:36:36 -0400 < mdhughes> But it's much easier to do C stuff from CHICKEN.
2023-04-13 23:37:09 -0400 < mdhughes> And CHICKEN has vastly more "eggs" than anyone else's libraries, it's huge.
2023-04-13 23:38:00 -0400 < mdhughes> Racket & Gauche (& Guile, probably) are close on libraries, but usually only have one solution to any problem.
2023-04-13 23:39:26 -0400 < amirouche> size does not matter @_@
2023-04-13 23:39:43 -0400 < amirouche> anyway, the database is backed up on disk, feel free to add you favorite webiste
2023-04-13 23:39:56 -0400 < amirouche> what url makes sense
2023-04-13 23:40:22 -0400 < flatwhatson> amirouche: beautiful!
2023-04-13 23:40:59 -0400 < amirouche> ty
2023-04-13 23:41:10 -0400 < flatwhatson> what is letloop?
2023-04-13 23:41:22 -0400 < amirouche> ah uh oh
2023-04-13 23:41:40 -0400 < amirouche> that is an umbrella term to host stuff I am working on with Chez
2023-04-13 23:42:07 -0400 < amirouche> so far, there is a cli to compile stuff (but I figured new bugs tonight)
2023-04-13 23:42:27 -0400 < flatwhatson> no concerns, just curiosity :)
2023-04-13 23:42:34 -0400 < amirouche> I have also a "serverless cloud thingy" that I started to explain how a simpler version works at https://hyper.dev
2023-04-13 23:43:14 -0400 < amirouche> nothing is in production, go see md for productionazindustry of scheme ;)
2023-04-13 23:44:16 -0400 < amirouche> gn
2023-04-13 23:44:55 -0400 < acdw> mdhughes: akku works w chez tho right?
2023-04-13 23:45:51 -0400 < mdhughes> Yeah, tho I use Thunderchez. But they're still much much smaller than http://eggs.call-cc.org/5/
2023-04-13 23:48:25 -0400 < acdw> I got annoyed trying to do module compilation w chicken but I should revisit
2023-04-13 23:55:03 -0400 < acdw> mdhughes: how do you reckon gambits example phones GitHub?
2023-04-13 23:55:38 -0400 < acdw> oh it says in the comments there. oof
--- Day changed Fri Apr 14 2023
2023-04-14 01:46:41 -0400 < lockywolf> Has anyone done The Little Prover? Which "production"-level prover system is J-Bob the most similar to? Agda, Lean, Idris, Coq?
2023-04-14 02:03:11 -0400 < lockywolf> Or is it ACL2?
2023-04-14 02:04:07 -0400 < Zipheir> ACL2.
2023-04-14 02:05:11 -0400 < Zipheir> J-Bob is named after Robert S. Boyer and J Strother Moore, the guys who did the research behind ACL2.
2023-04-14 02:10:04 -0400 < lockywolf> hm...
2023-04-14 02:15:25 -0400 < Zipheir> If you want something more like Agda, The Little Typer is a better choice.
2023-04-14 02:15:57 -0400 < Zipheir> I enjoyed that one more than TLP.
2023-04-14 02:36:28 -0400 < Zipheir> The only annoyance with The Little Typer is Pie's Racket dependency.
2023-04-14 02:42:22 -0400 < lockywolf> There, seemingly, is a Racket-free version.
2023-04-14 02:43:14 -0400 < lockywolf> Zipheir: to be honest, I know nothing about proof assistants, and only slightly more about fancily typed languages.
2023-04-14 02:49:10 -0400 < Zipheir> It's a good introduction.
2023-04-14 02:50:09 -0400 < Zipheir> There's a weird but fascinating shift from programs to proofs halfway through.
2023-04-14 03:00:32 -0400 < lockywolf> I was actually trying to do something with LaTeX, rather than programs :).
2023-04-14 03:01:05 -0400 < lockywolf> Like, I wante to write a paper in a language more precise than purely syntactic LaTeX.
2023-04-14 03:02:40 -0400 < lockywolf> I am aware about sTeX and semantex, but never tried them actually.
2023-04-14 04:10:40 -0400 -!- devmsv_ is now known as devmsv
2023-04-14 06:01:16 -0400 < amirouche> flatwhatson: what are the next regarding our project?
2023-04-14 06:03:02 -0400 < flatwhatson> amirouche: i'm just getting the embedding API going, so we should be able to start generating vectors soon
2023-04-14 06:05:27 -0400 < flatwhatson> each reference will need to be split into bite-sized pieces ready for embedding, and those stored in some kind of database alongside the associated reference metadata
2023-04-14 06:06:16 -0400 < flatwhatson> i think it would be best to have those in some easy intermediate format like CSV or sexps, that dataset can be useful for other projects on its own
2023-04-14 06:06:28 -0400 < amirouche> yeah
2023-04-14 06:06:30 -0400 < amirouche> sure
2023-04-14 06:07:08 -0400 < amirouche> can you pitch the project again?
2023-04-14 06:07:34 -0400 < amirouche> please :)
2023-04-14 06:07:42 -0400 < flatwhatson> sure :)
2023-04-14 06:12:45 -0400 < flatwhatson> I want to create a Scheme oracle, using a large database of reference materials (manuals, papers, source code, etc.) to provide context to an LLM chat-bot so that it can provide assistance based on accurate & properly-referenced source materials.
2023-04-14 06:16:22 -0400 < amirouche> who will pay for openapi?
2023-04-14 06:17:58 -0400 < flatwhatson> i'm happy to fund & host it for now, api calls are pretty cheap and i don't imagine it will get hammered too badly with our niche community
2023-04-14 06:19:04 -0400 < flatwhatson> hopefully in the coming months a suitable open-source model will come along that would be feasible to drop the dependence on openai (then there might be a question about gpu time or whatever)
2023-04-14 06:21:16 -0400 < amirouche> One last bit :)
2023-04-14 06:21:23 -0400 < amirouche> What do I get out of this?
2023-04-14 06:21:51 -0400 < flatwhatson> fame and fortune! :D
2023-04-14 06:23:19 -0400 < flatwhatson> i don't mind if you want to help or not, it's something that i would personally find very useful, digging through papers & sources manually is tedious & error-prone
2023-04-14 06:24:41 -0400 < flatwhatson> we have a wealth of historical scheme knowledge across multiple generations, i think much richer than many other programming languages.  it could be like having your personal greybeard schemer :)
2023-04-14 06:28:21 -0400 < amirouche> Indeed, I agree with that, that part of the reason, I do Scheme.
2023-04-14 06:29:48 -0400 < amirouche> I was thinking about a commission :)
2023-04-14 06:30:55 -0400 < flatwhatson> i would like one too :D
2023-04-14 06:31:49 -0400 < amirouche> mnieper: re compile Chez Scheme program, here the suite of cli commands with your approach:
2023-04-14 06:31:55 -0400 < amirouche> ;#sh> scheme-script build.scm
2023-04-14 06:31:58 -0400 < amirouche> ;#sh> petite main
2023-04-14 06:32:14 -0400 < amirouche> oops
2023-04-14 06:32:22 -0400 < amirouche> ;#sh> scheme-script build.scm
2023-04-14 06:32:26 -0400 < amirouche> ;#sh> scheme-script main
2023-04-14 06:32:28 -0400 < amirouche> hello schemer!
2023-04-14 06:32:44 -0400 < amirouche> ;#sh> letloop compile ./usr/lib/csv9.5.9/ta6le/ main.scm main
2023-04-14 06:32:47 -0400 < amirouche> ;#sh> ./main
2023-04-14 06:32:49 -0400 < amirouche> hello schemer!
2023-04-14 06:33:33 -0400 < amirouche> that is what people expect when they ask for standalone binaries, installing chez scheme, is not what the user story describe
2023-04-14 06:34:02 -0400 < mnieper> amirouche: They don't have to install Chez Scheme, just the runtime.
2023-04-14 06:34:03 -0400 < ecraven> does this produce static binaries? or do you still need various dynamic libraries?
2023-04-14 06:34:11 -0400 < amirouche> Sorry, for copy pasting, I thought it was small (and it is without the mistakes)
2023-04-14 06:35:08 -0400 < mnieper> I assume that for 99% of the use cases, everything in one file is not what you need.
2023-04-14 06:35:42 -0400 < amirouche> Here what I pasted above, build vs. letloop: http://ix.io/4tpx
2023-04-14 06:36:10 -0400 < amirouche> ecraven: that is exactly my goal.
2023-04-14 06:36:16 -0400 < mnieper> By the way, with my approach, you don't have to prefix the executable with scheme-script
2023-04-14 06:37:21 -0400 < mnieper> As much as I don't want glibc statically linked into every of my programs, I don't want the Chez (or Chicken or whatever) runtime statically linked into my programs.
2023-04-14 06:38:05 -0400 < ecraven> mnieper: well, as long as I can distribute a single *file*, I don't care if it contains dynamic libraries and whatever else, but I don't want to have to distribute more than one *file*
2023-04-14 06:38:36 -0400 < amirouche> mnieper: you need scheme-script, or petite, or chez, see http://ix.io/4tpy/bash
2023-04-14 06:38:38 -0400 < ecraven> and have you tried building a dynamic executable that runs on both alpine and glibc-based systems at the same time?
2023-04-14 06:38:52 -0400 < mnieper> ecraven: make dist produces a single file :)
2023-04-14 06:38:59 -0400 < amirouche> ecraven: no, not yet, it is too much work
2023-04-14 06:39:18 -0400 < amirouche> I mean the solution I have is too much work
2023-04-14 06:39:28 -0400 < ecraven> I'm a bit late to the discussion, what is this make dist, and where can I look at it?
2023-04-14 06:39:56 -0400 < amirouche> says the hobby schemer :>
2023-04-14 06:40:05 -0400 < mnieper> ecraven: A standard target for Makefiles (according to the GNU coding standards).
2023-04-14 06:41:07 -0400 < ecraven> so how do you package all the relevant libraries and the scheme code into one file?
2023-04-14 06:41:07 -0400 < mnieper> Nothing Scheme-specific. make dist should produce a single tar(gz) from your sources so that you just have to ship one file to do tar -xzf ... && ./configure && make install on the other side.
2023-04-14 06:41:21 -0400 < ecraven> I want a *runnable* file, that people can just execute
2023-04-14 06:41:35 -0400 < amirouche> autofuu is the way
2023-04-14 06:41:41 -0400 < amirouche> ;)
2023-04-14 06:42:02 -0400 < amirouche> mnieper: for context, ecraven is shipping binaries, without source...
2023-04-14 06:42:39 -0400 < ecraven> say I want to write the next Scheme game, like Kandria in CL.. how do I fully package that including all relevant libraries (lots of C there), so that it runs on as many machines as possible?
2023-04-14 06:42:43 -0400 < mnieper> ecraven: I believe in distributing source code.  As long as your Makefile does `make install' well, people (at least on GNU/Linux) get what they expect.
2023-04-14 06:43:11 -0400 < ecraven> mnieper: fair enough, but this doesn't work for 99% of the world population...
2023-04-14 06:43:37 -0400 < ecraven> I don't have a problem with distributing the source, but it should be part of a single "file"
2023-04-14 06:43:43 -0400 < mnieper> These 99% know how to click on a button presented by some GUI installer :)
2023-04-14 06:43:58 -0400 < mnieper> ecraven: A tarball is a single file, so I don't understand.
2023-04-14 06:44:10 -0400 < ecraven> so what will that installer do? call configure and make, and then install all the relevant libraries?
2023-04-14 06:44:34 -0400 < ecraven> quite a lot of software does *not* work like this any longer, because .. it just doesn't work ;) library version mismatches, and so on
2023-04-14 06:44:53 -0400 < mnieper> With a properly written Makefile (e.g. one generated by Automake), you should be able to install in any directory, even a virtual one).
2023-04-14 06:45:11 -0400 < amirouche> we are back at autofu
2023-04-14 06:45:24 -0400 < ecraven> well, how do you get all your dependencies in the right version? Make doesn't know how to install sdl_mixer in the right version...
2023-04-14 06:45:45 -0400 < mnieper> ./configure should tell you when something is missing.
2023-04-14 06:46:16 -0400 < ecraven> indeed, but the *user* shouldn't be expected to fix this, imho... (not in this use case, which is "shipping an entire program with all dependencies
2023-04-14 06:46:18 -0400 < ecraven> ")
2023-04-14 06:46:29 -0400 < amirouche> ahem
2023-04-14 06:46:33 -0400 < amirouche> you won't agree.
2023-04-14 06:46:48 -0400 < ecraven> which is fine ;)
2023-04-14 06:46:48 -0400 < amirouche> ecraven if you were transparent about what you do, it will be easier for people to help you
2023-04-14 06:46:48 -0400 < mnieper> ecraven: If you want to ship all dependencies then ship a docker container.
2023-04-14 06:47:01 -0400 < amirouche> even, possibly for free!
2023-04-14 06:47:59 -0400 < ecraven> amirouche: I don't have any concrete goal, but I *did* try to send a friend a small scheme program I had written, I compiled it on arch linux, and of course it didn't work on his machine (different distro).. now, I *could* send him all my libraries, and tell him how to set up chez to compile it, but that's quite a lot of work, why can't I *build* a binary that will just work for any modern linux distribution :D
2023-04-14 06:48:07 -0400 < mnieper> Another option is to turn your tarball into a deb package (or whatever, depending on the target audience).
2023-04-14 06:48:23 -0400 < ecraven> mnieper: indeed, I should look into how well containers work with ui libraries these days
2023-04-14 06:49:24 -0400 < sham1> There's also flatpak and such for Linux stuff
2023-04-14 06:49:30 -0400 < amirouche> there guix!
2023-04-14 06:49:38 -0400 < amirouche> nixos too
2023-04-14 06:49:41 -0400 < amirouche> ;)
2023-04-14 06:50:03 -0400 < mnieper> Yes!
2023-04-14 06:50:28 -0400 < mnieper> I wouldn't try to reinvent the wheel but would use an existing packager/container solution.
2023-04-14 06:51:10 -0400 < mnieper> For example, your program you want to distribute may want to use `eval' at some point, which probably needs the libraries lying around somewhere in source form.
2023-04-14 06:51:26 -0400 < mnieper> So having them somewhere stored in the exe won't help.
2023-04-14 06:52:20 -0400 < mnieper> Similar for C libraries you need/want to dynamically link (because of FFI, because they represent plugins, etc.).
2023-04-14 06:52:24 -0400 < amirouche> ecraven: I will fix your usecase, I hope you will return me the favor
2023-04-14 06:52:43 -0400 < ecraven> no need to hurry, I haven't had time to work on any Scheme code recently :-/
2023-04-14 06:52:53 -0400 < ecraven> maybe flatpak is the best option :-/
2023-04-14 06:53:21 -0400 < amirouche> oh no... what scheme company!...
2023-04-14 06:56:17 -0400 < mnieper> amirouche: Re need scheme-script:  The original top-level program must start with #!<path to chez/petit-scheme>
2023-04-14 06:56:42 -0400 < mnieper> amirouche: This is then copied by Chez into the final executable so that the kernel knows the program loader.
2023-04-14 06:57:05 -0400 < amirouche> please update the build file in the repository at gitlab for future reference
2023-04-14 07:00:12 -0400 < mnieper> https://gitlab.com/nieper/chez-example-program/-/blob/main/main.sps
2023-04-14 07:00:33 -0400 < mnieper> ^^ The main.sps did start with #!/...
2023-04-14 07:04:03 -0400 < amirouche> mnieper: you rebased the branch?!
2023-04-14 07:04:47 -0400 < cow_2001> okay, i didn't realise map was unordered O_O
2023-04-14 07:04:51 -0400 < cow_2001> "read the spec"
2023-04-14 07:05:23 -0400 < cow_2001> evaluation is unordered, that is
2023-04-14 07:05:47 -0400 < cow_2001> can be ordered, but that's not guaranteed by the spec
2023-04-14 07:06:15 -0400 < mnieper> amirouche: No, I didn't touch the repo since I created and shared it yesterday.
2023-04-14 07:06:36 -0400 < mnieper> cow_2001: There is map-in-order in SRFI 1 if you need it.
2023-04-14 07:06:53 -0400 < amirouche> anyway, I will not use that method, i need to build a boot file, and use the "hacks" that gwatt documented.
2023-04-14 07:07:18 -0400 < mnieper> Why do you need to build a boot file?
2023-04-14 07:07:28 -0400 < amirouche> because I eval stuff at runtime
2023-04-14 07:07:48 -0400 < mnieper> Why doesn't this work with the simple method?
2023-04-14 07:08:33 -0400 < amirouche> What is wrong about building a bootfile?
2023-04-14 07:09:59 -0400 < cow_2001> mnieper: yeah, i was just looking at yesterday's links
2023-04-14 07:10:15 -0400 < cow_2001> wasamasa linked it
2023-04-14 07:10:18 -0400 < mnieper> amirouche: When something is unnecessary, why should one do it?  Before Chez had WPO, it might have made sense.
2023-04-14 07:10:44 -0400 < wasamasa> usually you do not need map-in-order
2023-04-14 07:10:56 -0400 < wasamasa> but in the face of side effects, think about what you need to order
2023-04-14 07:11:03 -0400 < ecraven> if you need in-order, use `for-each'
2023-04-14 07:11:16 -0400 < mnieper> ecraven: for-each throws away the values
2023-04-14 07:11:24 -0400 < wasamasa> I for example remember cyclone implementing map and so on in fun ways that it ends up evaluating from right to left
2023-04-14 07:11:24 -0400 < mnieper> ecraven: it is not the same as map-in-order
2023-04-14 07:11:37 -0400 < ecraven> yes, but if you care about the values, most of the time you *don't* care about the order of the calculation
2023-04-14 07:12:04 -0400 < ecraven> I think MIT does right-to-left, and chez does right-to-left in pairs, for some reason ;)
2023-04-14 07:12:18 -0400 < mnieper> ecraven: Not necessarily; if you print warnings or info messages, say, you may want the warnings appear in the right order.
2023-04-14 07:12:22 -0400 < wasamasa> I'm sure jcowan has a full table
2023-04-14 07:12:52 -0400 < flatwhatson> right-to-left makes sense if you use intermediate lists to hold args
2023-04-14 07:15:05 -0400 < mnieper> amirouche: Pushed to my repo.  Eval works with the simple method of wpo.
2023-04-14 07:16:33 -0400 < cow_2001> how about this one! :D http://0x0.st/H8Z8.scm
2023-04-14 07:16:41 -0400 < cow_2001> i didn't really test it :|
2023-04-14 07:16:42 -0400  * amirouche looking at eval
2023-04-14 07:17:48 -0400 < mnieper> cow_2001: Don't use set!
2023-04-14 07:18:05 -0400 < cow_2001> D:<
2023-04-14 07:18:10 -0400 < mnieper> Your definition becomes incorrect as soon as f catches and reinstates continuations.
2023-04-14 07:18:24 -0400 < cow_2001> i haven't touched continuations yet
2023-04-14 07:18:26 -0400 < cow_2001> oh dear
2023-04-14 07:18:52 -0400 < mnieper> Always be careful with mutation when control escapes (like when you call a parameter like f).
2023-04-14 07:19:05 -0400 < mnieper> Use fold-right.
2023-04-14 07:20:07 -0400 < mnieper> (define map-in-order (lambda (f x*) (fold-right (lambda (x x*) (cons (f x) x*)) '() x*)))
2023-04-14 07:20:21 -0400 < cow_2001> are there any tools that warn you of that kind of stuff? rustlang has clippy
2023-04-14 07:20:38 -0400 < mnieper> cow_2001: Not that I know of.
2023-04-14 07:20:48 -0400 < mnieper> Just think twice when you use set!.
2023-04-14 07:20:53 -0400 < mnieper> And thrice when you use eval.
2023-04-14 07:22:51 -0400 < cow_2001> okay, i should really just continue onward with the program. continuations are first mentioned in chapter 4.3.3 and i'm at 3.2.
2023-04-14 07:23:25 -0400 < amirouche> mnieper: what does not work is (eval (hello) (environment '(example hello))) out of tree
2023-04-14 07:23:31 -0400 < mnieper> Another, often more practical reason is that many compilation models of Scheme disfavor set! in terms of efficiency.
2023-04-14 07:24:15 -0400 < mnieper> amirouche: You mean '(hello), right?
2023-04-14 07:24:15 -0400 < amirouche> e.g. (display (eval '(hello) (environment '(rnrs) '(example hello))))
2023-04-14 07:24:28 -0400 < mnieper> let me check
2023-04-14 07:26:07 -0400 < mnieper> It does here.
2023-04-14 07:26:21 -0400 < mnieper> Have you referenced (example hello) somewhere in your static imports?
2023-04-14 07:26:21 -0400 < amirouche> out of tree
2023-04-14 07:26:26 -0400 < amirouche> no
2023-04-14 07:26:28 -0400 < mnieper> I copied it out of tree
2023-04-14 07:26:34 -0400 < mnieper> amirouche: Then do this :)
2023-04-14 07:26:49 -0400 < amirouche> yeah, but that is use a bug imo
2023-04-14 07:27:08 -0400 < mnieper> No, it isn't.  This is how the library system of R6RS works.
2023-04-14 07:27:16 -0400 < amirouche> because if an import is present but not used, it should be eliminated from the compiled form
2023-04-14 07:27:48 -0400 < amirouche> Thanks a lot for the workaround
2023-04-14 07:27:54 -0400 < mnieper> amirouche: No, because when the import is present, it is expanded at compilation time of the program and this expansion may contain compile-time information that couldn't be reproduced.
2023-04-14 07:28:10 -0400 < mnieper> It would be a bug if it weren't present in the compiled form.
2023-04-14 07:28:41 -0400 < amirouche> so, you claim that it is better to import an unused library necessary to execute a an eval, than create a boot file?
2023-04-14 07:28:42 -0400 < mnieper> By the way, this is one reason why R6RS does not visit/invoke libraries when no identifier is referenced.
2023-04-14 07:29:07 -0400 < mnieper> amirouche: Of course.  Because express things in Scheme when you can.
2023-04-14 07:29:14 -0400 < amirouche> hmm
2023-04-14 07:29:35 -0400 < mnieper> R6RS is very well thought of.  Use the expressiveness, it gives you.
2023-04-14 07:30:42 -0400 < mnieper> In pre-R6RS times (csv < 8), boot files must have been more important.
2023-04-14 07:35:06 -0400 < mnieper> And probably if you want to use Chez Scheme embedded in a C application (i.e. your main program is in C but you like to call Scheme procedures).
2023-04-14 07:40:06 -0400 < amirouche> I will try to find a solution for the remaining issue
2023-04-14 07:40:11 -0400 < amirouche> mnieper: you are a great person
2023-04-14 07:41:14 -0400 < mnieper> don't say this.
2023-04-14 07:41:34 -0400 < amirouche> you are chez genius!
2023-04-14 07:42:00 -0400 < mnieper> I do make at least as twice as many mistakes as I seemingly have brilliant moments.
2023-04-14 07:42:29 -0400 < amirouche> yeah, I know, also you are kind
2023-04-14 07:44:02 -0400 < mnieper> amirouche: I wouldn't have the staying power for projects like letloop so it is good that we are a diverse bunch of people.
2023-04-14 07:44:18 -0400 < mnieper> You mentioned Chez & FFI yesterday.
2023-04-14 07:45:08 -0400 < mnieper> Do you think it would be possible to write a macro that takes a high-level description of a C API (like Chibi's stubs) and spits out definitions of Scheme procedures calling these entry points?
2023-04-14 07:45:31 -0400 < ecraven> I've thought about doing that too, writing FFI code is very repetitive
2023-04-14 07:46:20 -0400 < amirouche> I can't tell for sure
2023-04-14 07:46:28 -0400 < amirouche> it just painful whatever you do.
2023-04-14 07:46:35 -0400 < mnieper> Chez has `foreign-procedure', which would just have to be inserted by such a macro in the output.
2023-04-14 07:46:42 -0400 < mnieper> amirouche: In what sense painful?
2023-04-14 07:46:56 -0400 < amirouche> compared to writing scheme code
2023-04-14 07:47:25 -0400 < mnieper> Even better would, of course, be a parser for C header files!
2023-04-14 07:47:29 -0400 < ecraven> I think it would be simple to write a macro for the trivial cases, but often you need to `foreign-alloc' some data structure to pass into the foreign call, or destructure a result, and those conversions are harder to generalise :-/
2023-04-14 07:47:55 -0400 < sham1> IMO FFI should be painful. If for no other reason than to encourage people to write usable wrappers
2023-04-14 07:48:09 -0400 < mnieper> :)
2023-04-14 07:50:34 -0400 < mnieper> ecraven: You mean one would need general mappers records<->C structs?
2023-04-14 07:50:56 -0400 < mnieper> I have to get back at work!
2023-04-14 07:53:26 -0400 < ecraven> mnieper: well, many things depend on what you want.. do you want to decode your structs to Scheme records, or do you just want accessor methods that access the C struct directly? how do you want to deal with enums (I mostly use symbols or lists of symbols that are then encoded to / decoded from integers), and so on.. also, you need to know your *architecture*, as – to my knowledge – the size of enums is dependant on that, and chez
2023-04-14 07:53:26 -0400 < ecraven> doesn't provide a generic "enum" type in the ffi :-/
2023-04-14 07:53:32 -0400 < ecraven> it's all.. complicated ;)
2023-04-14 08:30:20 -0400 < amirouche> mnieper: what you describe still requires scheme to be installed.
2023-04-14 08:30:22 -0400 < amirouche> fwiw
2023-04-14 08:31:53 -0400 < mnieper> You need the runtime, yes.  But this is good for N > 1 programs.  Unless you really need static linking.
2023-04-14 08:33:42 -0400 < mnieper> amirouche: As I wrote yesterday, I think, this is not different to how Linux loads the typical ELF file.  It hands over the dynamic linking to /lib/ld-linux.so.2
2023-04-14 08:34:02 -0400 < mnieper> which is the actual ELF interpreter.
2023-04-14 09:46:17 -0400 < gwatt> I'm betting that someone could call out to libclang or something and generate the foreign-procedures and ftypes
2023-04-14 09:46:30 -0400 < gwatt> RE: FFI code being repetetive
2023-04-14 10:16:36 -0400 < mnieper> You mean libclang parsing a header file?
2023-04-14 10:57:27 -0400 < gwatt> yes
2023-04-14 10:59:10 -0400 < mnieper> Problematic would be header files where some of the "functions" are actually implemented as preprocessor macros.
2023-04-14 10:59:30 -0400 < mnieper> Or defined as static inline.
2023-04-14 11:02:17 -0400 < gwatt> Oh sure. I"m no saying it would necessarily be the a walk in the park to implement, but it would remove the tedium
2023-04-14 11:02:49 -0400 < mnieper> What is the output of libclang?
2023-04-14 11:02:58 -0400 < mnieper> ... like?
2023-04-14 11:03:14 -0400 < gwatt> I do not know
2023-04-14 11:03:39 -0400 < gwatt> This is a thought I had and did absolutely no actual work on.
2023-04-14 11:07:44 -0400 < cow_2001> D:< https://github.com/sarabander/sicp/pull/45/commits/6235bec8a34b7d11ed3ab0f033ba45ee12ddb2f7
2023-04-14 11:09:48 -0400 < cow_2001> i've made a patch to (the unofficial) sicp!
2023-04-14 11:10:33 -0400 < acdw> nice
2023-04-14 11:12:35 -0400 < mnieper> gwatt: Is the format of GCC's precompiled header files documented somewhere?  It must be some written GENERIC.
2023-04-14 11:15:47 -0400 < cow_2001> the owner of that repository seems to have vanished
2023-04-14 11:26:10 -0400 < gwatt> mnieper: I don't know. My understanding is that Stallman fights tooth and nail to keep GCC from being usable as an intermediate tool like that
2023-04-14 11:27:31 -0400 < mnieper> With the official libgccjit, this seems no longer be true anymore, I think.
2023-04-14 11:28:02 -0400 < gwatt> Ah, neat!
2023-04-14 11:28:41 -0400 < mnieper> But this is the other direction we would need.  Using libgccjit one can replace the frontend.  We, however, would need to replace the backend.
2023-04-14 11:28:50 -0400 < acdw> i gotta say finding out that the one part of gcc was written in obfuscated C seemed pretty anti-libre tbqh
2023-04-14 11:29:05 -0400 < mnieper> acdw: Which part?
2023-04-14 11:29:27 -0400 < mnieper> I once contributed to GCC (fixing some memory leak when used as library) and the code was very readable.
2023-04-14 11:29:28 -0400 < acdw> i honeslty don't remember
2023-04-14 11:30:08 -0400 < acdw> https://lwn.net/Articles/582697/, from this hn comment https://news.ycombinator.com/item?id=25213252
2023-04-14 11:30:19 -0400 < acdw> i think that's where i heard about it
2023-04-14 11:38:48 -0400 < mnieper> I understand that GCC doesn't want non-free plugins.  Without the GPL and its prevalence (especially historically), the software ecosystem and a user's freedom would look a lot worse today.  Licenses chosen by projects like LLVM do not do any immediate harm, but they will lead to a deterioration of the software world and our freedom as users of software.
2023-04-14 11:39:10 -0400 < acdw> i keep going back and forth on the issue
2023-04-14 11:39:43 -0400 < mnieper> As I see it, the only reason for not to choose a GPL-like license as an open source programmer is when you write software that cannot compete with existing software or when you want to open a market for the free software movement.
2023-04-14 11:40:16 -0400 < acdw> mmm
2023-04-14 11:40:26 -0400 < acdw> maybe it's time to re-examine my beliefs
2023-04-14 11:42:50 -0400 < mnieper> The way it now works on GitHub, etc. is that it is a one-way share.  Zillions of programmers contribute to great open source projects by Microsoft, Apple, Google, Facebook, ..., the companies take the free work gratefully (or not so gratefully), but never have to pay something back.  For example, Apple can add some extra non-open source bells and whistles to clang to make xcode (or what is called) to be the best IDE or, similarly,
2023-04-14 11:42:50 -0400 < mnieper> Safari and no one has a chance to catch up.
2023-04-14 11:43:58 -0400 < sham1> This does ignore the idea that things do get contributed back. Mostly because for many things it's annoying to keep the patches up-to-date with the upstream
2023-04-14 11:45:31 -0400 < mnieper> Filtered things get contributed back.
2023-04-14 11:45:37 -0400 < mnieper> To get more free work done.
2023-04-14 11:45:46 -0400 < acdw> mnieper: yeah, that's a good point. tho realistically you could argue that an individual programmer has no recourse if their code is stolen by a large player, even with GPL -- b/c of the way the legal system works
2023-04-14 11:48:07 -0400 < mnieper> There have been court decisions (positive ones): https://lwn.net/Articles/556317/
2023-04-14 11:48:51 -0400 < mnieper> I am not saying that the GPL is the optimum, but IMO it is better in spirit than the licenses that favor the big tech companies.
2023-04-14 11:49:27 -0400 < Zipheir> acdw: Copying is not theft, even when it's corporate copying.
2023-04-14 11:51:06 -0400 < sham1> Breach of license, yeah
2023-04-14 11:53:38 -0400 < acdw> Zipheir: i mean if the corpo doesnt follow the terms of the license. .. sorry poor choice of words
2023-04-14 11:53:46 -0400 < acdw> mnieper: i'll give it a read, thanks :D
2023-04-14 11:57:36 -0400 < mnieper> acdw: I think we all knew what you meant when you wrote "stolen".
2023-04-14 11:59:06 -0400 < Zipheir> Yes, that meaning is familiar. But corporate types (esp. those in Hollywood) like to abuse it to describe, you know, watching a stream without paying.
2023-04-14 12:03:05 -0400  * mnieper has to go.
2023-04-14 12:03:27 -0400 < Zipheir> Bye Marc.
2023-04-14 12:09:02 -0400 < acdw> o/
2023-04-14 12:09:20 -0400 < acdw> always good to be absolutely clear
2023-04-14 12:27:46 -0400 < mdhughes> A company has two options with open source: They can steal it, or they can use it by license. Putting your code under GPL means they'll choose to steal it, which is what copilot does. Putting it under BSD/MIT means they can use it under license, and may contribute bugs back; probably not, because corporations.
2023-04-14 12:28:25 -0400 < mdhughes> Nothing you do is going to affect that. So instead you should concentrate on the license that benefits you and other users, which is a true open source license, BSD/MIT.
2023-04-14 12:29:36 -0400 < mdhughes> And then there's the side that *does* benefit from GPL, which is the FSF, keeping control and power in the hands of RMS, noted toe-jam eater, pedophile defender, and project tyrant.
2023-04-14 12:30:16 -0400 < mdhughes> If I could make a license that was "BSD, but you can't use this if you're affiliated with the FSF in any way", I would.
2023-04-14 12:31:24 -0400 < sham1> You mean GPL sans FSF?
2023-04-14 12:31:28 -0400 < sham1> That kinda license?
2023-04-14 12:31:50 -0400 < mdhughes> I mean BSD, I want anyone to be able to use my freely released code for any purpose, as long as it's not affiliated with the FSF.
2023-04-14 12:32:02 -0400 < sham1> There's always Mozilla's license which is copyleft
2023-04-14 12:32:32 -0400 < ecraven> mdhughes: so, do you not use any GPL'd software, if you dislike them so much?
2023-04-14 12:32:35 -0400 < mdhughes> Yeah, Apache & Mozilla have licenses which aren't bad, esp. if you're working in a corporation and want to cover all your legal ass.
2023-04-14 12:33:09 -0400 < mdhughes> I try not to. There's some poison I can't escape, but where possible I'm a FreeBSD & Mac user, so it's pretty small.
2023-04-14 12:34:01 -0400 < Zipheir> There have been those who like the GPL but not the FSF. Linus, e.g., said that using the GPL for Linux turned out to be a good decision.
2023-04-14 12:34:38 -0400 < Zipheir> (However, Linus rejected GPLv3.)
2023-04-14 12:34:57 -0400 < mdhughes> Right, but it's been an endless headache as well from Stallmanites who insist they own GNU/Linux or GNU minus HURD or whatever.
2023-04-14 12:35:29 -0400 < acdw> i'm sorry, i have to interject for a moment
2023-04-14 12:35:35 -0400 < mdhughes> And I *hate* the Linux GNU userland. WTF does /bin/true have option flags?
2023-04-14 12:36:10 -0400 < mdhughes> Half the man pages were ripped out and put in GNU Texinfo, so they're useless.
2023-04-14 12:36:33 -0400 < mdhughes> There's a de-GNU'd Linux distro I tried a while, it was a little saner.
2023-04-14 12:36:45 -0400 < mdhughes> But then why not just use BSD all the time.
2023-04-14 12:37:05 -0400 < sham1> Hardware support
2023-04-14 12:37:19 -0400 < Zipheir> Non-GNU Linux is great until you find a binary that's been built against glibc.
2023-04-14 12:38:24 -0400 < mdhughes> Alpine. https://www.alpinelinux.org There's also iglunix: https://iglunix.xyz but I haven't tried it.
2023-04-14 12:38:40 -0400 < Zipheir> Alpine is fine, although the installer is junk.
2023-04-14 12:38:54 -0400 < mdhughes> FreeBSD and NetBSD have often better hardware support than Linux, because they're not insane about binary drivers.
2023-04-14 12:39:08 -0400 < mdhughes> OpenBSD is the usual pain in the ass that Theo wants it to be.
2023-04-14 12:39:29 -0400 < Zipheir> OpenBSD is on a major NIH binge these days.
2023-04-14 12:40:07 -0400 < mdhughes> Theo is 100% correct and focused on his goals, and he does good work. He's just insufferable about it, and doesn't compromise for usability.
2023-04-14 12:40:09 -0400 < Zipheir> Licenses are an ethical as well as practical choice, so people will differ.
2023-04-14 12:41:58 -0400 < Zipheir> I personally don't care very much about the various GPL flavors, since I don't write proprietary software. Admittedly, the license version issues can be annoying.
2023-04-14 12:47:09 -0400 < wasamasa> I'm more annoyed when people pretend they just want a FLOSS license
2023-04-14 12:50:24 -0400 < Zipheir> In that matter, the thing I'm most annoyed about is from outside the software world: CC-NonCommercial.
2023-04-14 12:51:19 -0400 < Zipheir> (All of those pseudo-free-culture-advocates forget that "non commercial" means "private personal use only" in e.g. Germany.)
2023-04-14 12:51:35 -0400  * acdw uses gnu emacs ... O.O
2023-04-14 12:52:04 -0400 < acdw> i usually just use a joke license bc yolo
2023-04-14 12:52:26 -0400 < Zipheir> It's probably best to use one of the established ones.
2023-04-14 12:52:47 -0400 < acdw> https://acdw.casa/licenses i collect goofy ones
2023-04-14 12:52:53 -0400 < Zipheir> You don't want to be haled before a judge who questions you about the WTFPL.
2023-04-14 12:53:14 -0400 < mdhughes> vim -c ":help license"
2023-04-14 12:53:37 -0400 < acdw> Zipheir: i count on the fact i'm not a very good programmer ;)
2023-04-14 12:53:39 -0400 < wasamasa> > If you're dumb enough to want to copy this software, you're a big enough schmuck to abide by BIG BILL HELL'S LICENSE (BBHL)
2023-04-14 12:53:56 -0400 < mdhughes> I've been mostly using BBEdit, but finally switching back to Vim with a bunch of plugins so I can work the same across platforms.
2023-04-14 12:54:05 -0400 < Zipheir> acdw: People use PHP... :)
2023-04-14 12:54:07 -0400 < wasamasa> acdw: these are some good finds
2023-04-14 12:54:08 -0400 < acdw> wasamasa: yeah that's a good one lol
2023-04-14 12:54:26 -0400 < Oxyd> I don't think the author of the software is at any risk because of a joke licence. The users might be, though.
2023-04-14 12:54:26 -0400 < acdw> feel free to send more!
2023-04-14 12:54:52 -0400 < acdw> sometimes i think that using a joke license is a sure way to keep corpos from using it since their legal team will be like "i don't want to deal with this"
2023-04-14 12:55:04 -0400 < wasamasa> you assume they check
2023-04-14 12:55:13 -0400 < acdw> lol fair enough
2023-04-14 12:55:18 -0400 < wasamasa> usually the corporates I deal with are completely swamped with other things
2023-04-14 12:55:46 -0400 < acdw> well then, only write software in a language no one uses ;)
2023-04-14 12:55:58 -0400 < wasamasa> sure, I do that
2023-04-14 12:56:06 -0400 < wasamasa> but people kept opening issues
2023-04-14 12:56:18 -0400 < wasamasa> so I migrated to my own git and told them to write me emails instead
2023-04-14 12:56:22 -0400 < amirouche> license? who reads that anymore, not openai at least :P
2023-04-14 12:56:36 -0400 < acdw> wasamasa: rude :P
2023-04-14 12:56:38 -0400 < mdhughes> Like I said above, a joke license or anything a corporation can't immediately comply with, they'll just steal your code and not care.
2023-04-14 12:56:40 -0400 < acdw> the people, not u lol
2023-04-14 12:56:45 -0400 < acdw> mdhughes: yeah fair enough
2023-04-14 12:56:56 -0400 < Zipheir> Just use CC0 if you really want to disclaim any kind of copyright.
2023-04-14 12:56:57 -0400 < acdw> most of the time i just can't care enough about it
2023-04-14 12:57:09 -0400 < acdw> wasamasa: i really like depp btw, it's great
2023-04-14 12:57:10 -0400 < wasamasa> I do check licenses sometimes
2023-04-14 12:57:22 -0400 < acdw> at least looks great. idk if it works great on your end :P
2023-04-14 12:57:23 -0400 < wasamasa> but I cannot recall anything unique
2023-04-14 12:57:32 -0400 < wasamasa> it does work surprisingly well
2023-04-14 12:57:45 -0400 < acdw> ince
2023-04-14 12:57:47 -0400 < acdw> nice*
2023-04-14 12:58:03 -0400 < wasamasa> but I have to document it properly, at least for myself
2023-04-14 12:58:13 -0400 < wasamasa> otherwise I won't get it running on a new server
2023-04-14 12:58:29 -0400 < wasamasa> several people asked how to run it on their own machines and I consider that a deeply unwise decision
2023-04-14 12:58:50 -0400 < wasamasa> but if the documentation happens, then I would have some solid proof for that feeling
2023-04-14 12:58:53 -0400 < acdw> oh yeah. friends of mine wrote a similar thing called repo2html: https://git.m455.casa/repo2html/
2023-04-14 12:58:56 -0400 < Zipheir> The "ethical licenses" count as joke licenses of sorts. https://perens.com/2019/10/12/invasion-of-the-ethical-licenses/
2023-04-14 12:59:10 -0400 < acdw> oh yeah the ones where it's like "don't use this for bad things mkay
2023-04-14 12:59:11 -0400 < acdw> "
2023-04-14 12:59:29 -0400 < Zipheir> The Vaccine License (you must get your shots!) seems to have died.
2023-04-14 12:59:32 -0400 < wasamasa> lol
2023-04-14 12:59:59 -0400 < acdw> lol
2023-04-14 13:00:59 -0400 < wasamasa> I'm grateful Perens bothers explaining why exactly these joke licenses are... jokes
2023-04-14 13:01:08 -0400 < wasamasa> copyright law is deeply weird
2023-04-14 13:01:29 -0400 < acdw> honestly i kind of disagree with the very premise of IP
2023-04-14 13:01:42 -0400 < mdhughes> You might be able to distribute them as click-thru installers, so the user *has* to agree, not just run software.
2023-04-14 13:01:53 -0400 < Zipheir> wasamasa: It's a good post.
2023-04-14 13:01:59 -0400 < wasamasa> I suspect what the makers of these licenses really want is a EULA
2023-04-14 13:02:35 -0400 < Zipheir> The EULA is not important; it's that the companies that issue EULAs have scary legal teams and lots of money.
2023-04-14 13:02:44 -0400 < mdhughes> Pop up dialogs in the software, "did you get your shots, it's been 6 months?" and if they can't hold up a vaccine card to the camera, delete the program.
2023-04-14 13:03:01 -0400 < wasamasa> yes
2023-04-14 13:03:05 -0400 < Zipheir> No one has ever lied to a pop-up.
2023-04-14 13:03:14 -0400 < mdhughes> IT IS ILLEGAL
2023-04-14 13:03:17 -0400 < Zipheir> Hah.
2023-04-14 13:03:20 -0400  * wasamasa clicks sublime text nag popup away
2023-04-14 13:03:40 -0400 < acdw> it's really all about who has money
2023-04-14 13:04:12 -0400 < mdhughes> I really wanted to like Sublime, but editing JSON files is stupid, and the scripting library sucks hairy goat balls.
2023-04-14 13:04:22 -0400 < Zipheir> "IP" law is very complicated and sometimes arbitrary. Users can be counted on to run away at any hint of legal action.
2023-04-14 13:06:49 -0400 < Zipheir> (If Wizards of the Coast told me they owned the word "beholder" and I better not use it (which is nonsense), I'd probably stop using it rather than face an uncertain and incredibly expensive legal battle.)
2023-04-14 13:07:45 -0400 < Oxyd> Seems to me that such a battle would be fairly certain.
2023-04-14 13:08:43 -0400 < Zipheir> Not at all.
2023-04-14 13:09:01 -0400 < mdhughes> Yeah, that fiasco's turned out well for everyone, and we still stay away from Beholder®, Displacer Beast®, etc.
2023-04-14 13:09:31 -0400 < mdhughes> But that's a trademark, not a copyright issue.
2023-04-14 13:09:38 -0400 < Zipheir> It's copyright law, not trademark, but consider the insanity of this decision https://en.wikipedia.org/wiki/Pharrell_Williams_v._Bridgeport_Music  Nothing with this stuff is clear or certain.
2023-04-14 13:11:27 -0400 < Zipheir> (The gist of that decision, IIUC, was that "Blurred Lines" was infringement because it had the same "feel" as a Marvin Gaye song. But, anyway.)
2023-04-14 13:17:37 -0400 < Oxyd> That's a question of “are two pieces of music similar enough”. Very different from “you can't use a common word”.
2023-04-14 13:19:21 -0400 < Zipheir> You might be on firmer ground with trademark law.
2023-04-14 13:22:29 -0400 < acdw> Zipheir: yeah that was an effed decision. esp. b/c of the ruling on Under Pressure/Ice Ice Baby
2023-04-14 13:22:32 -0400  * acdw armchair lawyers
2023-04-14 13:36:50 -0400 < mnieper> I observe for another time that they only thing where mdhughes' and my opinion agree is that Chez and its language are a good target for Scheme programming. :)
2023-04-14 13:37:32 -0400 < acdw> chez does seem quite nice
2023-04-14 13:38:15 -0400 < mdhughes> Which makes me suspicious! But Chez is really solid.
2023-04-14 13:38:30 -0400 < mnieper> :D   The only complaint I have is that it was open-sourced very late.
2023-04-14 13:40:58 -0400 < acdw> cant' trust it
2023-04-14 13:42:00 -0400 < mnieper> About Chez's solidity: There is a reason why Racket and Idris both chose Chez as their backend.
2023-04-14 18:17:03 -0400  * amirouche cooking a new release of letloop's cli
2023-04-14 18:17:12 -0400 < amirouche> ETA 1 hours :-)
2023-04-14 18:22:29 -0400 < amirouche> lol another problem
--- Day changed Sat Apr 15 2023
2023-04-15 00:53:34 -0400 < mnieper> Good morning, everyone!
2023-04-15 04:29:51 -0400 -!- mdhughes_ is now known as mdhughes
2023-04-15 04:30:09 -0400 < mdhughes> Well, some quality of some time period, anyway.
2023-04-15 04:56:18 -0400 < mnieper> What's your TZ?
2023-04-15 05:41:35 -0400 < mdhughes> Pacific
2023-04-15 05:41:58 -0400 < mdhughes> But I'm nocturnal, so this is "day" for me. Except I'm running about 6+ hours late today.
2023-04-15 05:43:49 -0400 < mnieper> Now with three variables, that's too hard to calculate for me.
2023-04-15 05:44:31 -0400 < mdhughes> I have had breakfast, second breakfast, and coffee.
2023-04-15 05:49:42 -0400 < mnieper> I am on the train and waiting for someone to come along with a coffee for me!
2023-04-15 06:06:07 -0400 < amirouche> heyo
2023-04-15 06:09:44 -0400 < amirouche> mdhughes: you should come to south of france, better wheather, and same chill
2023-04-15 06:09:58 -0400 < amirouche> you will be able to see the sun
2023-04-15 06:10:13 -0400 < amirouche> while keeping your cycle the same
2023-04-15 06:10:27 -0400 < mdhughes> Oh I'll get entirely too much sun in spring & summer here.
2023-04-15 06:12:32 -0400 < mnieper> amirouche: Are you located in the south of France?  I have been several times to Nice.
2023-04-15 06:12:43 -0400 < amirouche> (import (only (usa) mdhughes))
2023-04-15 06:13:00 -0400 < amirouche> mnieper: I live near paris, i never went to nice, but I know people in marseille
2023-04-15 06:21:36 -0400 < amirouche> If I have enough freetime I will write a linter, then improve it to support somekind of modern typing discipline
2023-04-15 06:22:14 -0400 < amirouche> last couple of years, those "strong typing functional language" are making the news, and targeting Chez
2023-04-15 06:22:35 -0400 < amirouche> purescript will have a Chez backend: https://www.purescript.org/
2023-04-15 06:29:30 -0400 < mdhughes> I'd like to visit Europe, but time & money are hard to come by. Present unpleasant bullshit aside (and it *mostly* doesn't affect where I live), I do like living in the US.
2023-04-15 06:30:02 -0400 < mnieper> The only general problem with a static type system is that a static type system is never epxressive enough.
2023-04-15 06:41:09 -0400 < amirouche> yes
2023-04-15 06:41:32 -0400 < amirouche> tho, it can help, in some situation, it is better than nothing
2023-04-15 06:50:38 -0400 < mdhughes> I prefer nothing! I can always instrument functions with asserts & tests if I'm paranoid, but mostly Scheme blows up in good places when you pass "wrong" (or unsupported yet) types.
2023-04-15 06:52:00 -0400 < mdhughes> Often if I do pass an unsupported type, I go "Huh, maybe I should handle that here, too", and now my program's more general.
2023-04-15 06:52:51 -0400 < mdhughes> If you do that in a typed system, you're boned. Have fun writing duplicate code for each function just because the arguments are different types.
2023-04-15 06:55:16 -0400 < wklew> It's a good point about type systems not being expressive enough. Seems like there's a schism in the Haskell community between depend types people and Hindley-Milner people. No one has a perfect solution.
2023-04-15 06:56:31 -0400 < mnieper> wklew: Full dependent types à la Martin Löf are great as is HM on the other side of the spectrum.
2023-04-15 06:57:01 -0400 < mnieper> Modern Haskell programming, unfortunately, is based on a mess in the middle.
2023-04-15 06:57:20 -0400 < wklew> But putting them into a programming language in an intuitive and expressive way is not simple
2023-04-15 06:57:41 -0400 < dpk> my understanding is that Haskell 2010 is a restricted version of System F where inference is decidable?
2023-04-15 06:58:06 -0400 < mnieper> Is there any "modern" Haskell program written in H2010?
2023-04-15 06:58:22 -0400 < dpk> i don't know, i'm not that into the Haskell ecosystem
2023-04-15 06:59:01 -0400 < mnieper> wklew: Agda sans Unicode looks like a good approximation.
2023-04-15 06:59:42 -0400 < wklew> I always wanted to learn Agda
2023-04-15 06:59:49 -0400 < wklew> I like the unicode too, hehe
2023-04-15 07:00:10 -0400 < mnieper> wklew: Until have to deal with three different types of colons.
2023-04-15 07:00:36 -0400 < mnieper> The mapping Unicode character <-> perceived visual representation is highly non-bijective.
2023-04-15 07:00:57 -0400 < wklew> Haha
2023-04-15 07:01:31 -0400 < dpk> mdhughes: have you ever used a statically typed language like Haskell? (Java, C, C++ etc don't count)
2023-04-15 07:02:50 -0400 < mnieper> I would see non-ASCII characters in source code less problematic (at least a bit) if the use of Unicode characters were based on their semantic meaning.
2023-04-15 07:03:41 -0400 < mnieper> Better to use LaTeX-like identifiers and let your editor display them visually as you like.
2023-04-15 07:04:23 -0400 < flatwhatson> you don't need haskell to implement polymorphic functions
2023-04-15 07:04:53 -0400 < wklew> I think if I'd discovered ML before scheme I would have been perfectly content with that. It's a lovely language.
2023-04-15 07:07:38 -0400 < flatwhatson> SWITCH of lexp * conrep list * (con * lexp) list * lexp option
2023-04-15 07:09:14 -0400 < mnieper> HM has problems to express something like:
2023-04-15 07:09:23 -0400 < mnieper>  f :: (forall a . a -> c) -> x -> y -> (c -> c -> c) -> c
2023-04-15 07:09:29 -0400 < mnieper>  f phi u v w = w (phi (u), phi(v))
2023-04-15 07:10:44 -0400 < mnieper> So not every polymorphism that can easily be implemented in Scheme can be expressed elegantly (or efficiently or both) in a HM type system.
2023-04-15 07:17:25 -0400 < flatwhatson> is there some HM extension which can infer that correctly?
2023-04-15 07:18:05 -0400 < mnieper> Yes, in GHC, but you lose automatic type inference, if I am not mistaken.
2023-04-15 07:53:29 -0400 < sham1> One of the issues I have with non-static typing is that things like IDE tooling tend to be weaker than with statically typed languages. Of course something like Java or C# have very good tooling in general, but I do think that a non-negligible part of that is that the tooling knows what methods and such are available for any given identifier
2023-04-15 07:53:53 -0400 < sham1> Although Haskell for example also has a tad weak tooling
2023-04-15 07:53:54 -0400 < amirouche> What i have in mind is a linter, not a static type system that yells all around, more like a peer reviewer
2023-04-15 07:53:57 -0400 < mdhughes> IDEs are for people who don't know how to program, just hit "next" in a wizard.
2023-04-15 07:54:39 -0400 < mdhughes> linters do work OK in some things. I use jslint and with some rules tweaks it's been a big help.
2023-04-15 07:54:51 -0400 < sham1> I hardly use wizards. The most I usually do is use the refactoring tooling of IDEA
2023-04-15 07:56:13 -0400 < mdhughes> I just do Uncle Bob's refactoring steps in the editor. At this point they're pretty automatic. I *could* make a little script to do some of them.
2023-04-15 07:56:17 -0400 < flatwhatson> guile's compiler warnings with flycheck do a decent job, catching typos and arity mismatches and missing imports and whatnot cover the most common foibles
2023-04-15 07:57:06 -0400 < sham1> Well stuff like with are knowable at compile time, so it makes sense
2023-04-15 07:57:20 -0400 < flatwhatson> geiser's ability to provide completion of identifiers in scope is also useful.  prefix-naming gives a lot of the same convenience as OO dot notation completion.
2023-04-15 07:59:11 -0400 < flatwhatson> also macros let you do compile-time assertions, to get the best of both worlds
2023-04-15 08:01:49 -0400 < sham1> I'd think Guile and thus Geiser should also be able to use the data gathered from the type inference guile does, and provide diagnostics that way
2023-04-15 08:02:03 -0400 < flatwhatson> outside of scheme, it seems the way to get decently useful linting is to add types annotations to your dynamic language to get the worst of both worlds
2023-04-15 08:02:41 -0400 < flatwhatson> there's absolutely room for improvement there
2023-04-15 08:08:33 -0400 < mnieper> IDE support for Scheme is more complicated thanks to the turing-completeness of macros.
2023-04-15 08:09:55 -0400 < sham1> True, although at least ones made in syntax-rules should be fairly nice to autocomplete since you know how it's supposed to look thanks to the patterns
2023-04-15 08:10:51 -0400 < sham1> And I don't see why syntax-case would be any worse, at least syntactically. Like yeah, the analysis of what it expands to is a crapshoot, but it can at least be completed
2023-04-15 08:12:20 -0400 < mnieper> what would autocomplete give you when you now the s-r patterns?
2023-04-15 08:14:27 -0400 < flatwhatson> generating a template of the call could be tricky for recursive macros :)
2023-04-15 08:17:33 -0400 < flatwhatson> what's the complexity of turing-completeness of macros in practice? non-termination?
2023-04-15 08:18:01 -0400 < mnieper> you can't determine anything in general without running them
2023-04-15 08:18:37 -0400 < flatwhatson> it's certainly possible to hang clangd with template nonsense, for example
2023-04-15 08:19:01 -0400 < sham1> Well, if I type "(let |" and autocomplete, it could complete to something like "(let (|) [])" where the pipe is the cursor position, and the square brackets where you can tab forwards
2023-04-15 08:19:07 -0400 < flatwhatson> assuming a sandboxed compiler, doesn't that just leave non-termination?
2023-04-15 08:19:50 -0400 < mnieper> syntax-rules are sandboxed, syntax-case is not
2023-04-15 08:19:57 -0400 < sham1> Mutis mutandis for other macros
2023-04-15 08:20:06 -0400 < mnieper> e.g include can be implemented in it
2023-04-15 08:20:18 -0400 < sham1> mutatis mutandis*
2023-04-15 08:21:28 -0400 < sham1> And yeah, that's not a lot of change, but it's something
2023-04-15 08:21:33 -0400 < mnieper> and even s-r alone: invoking a macro may trigger a visit of a library
2023-04-15 08:21:47 -0400 < mnieper> which in turn can execute arbitrary code
2023-04-15 08:23:15 -0400 < sham1> Well you'd need to load the library anyway to gather symbols. Although you could probably just use the exports
2023-04-15 08:23:16 -0400 < flatwhatson> you can still sandbox the compiler to deny capabilities like writing files or opening sockets
2023-04-15 08:23:48 -0400 < sham1> Or alternatively you do what SLIME/SLY do for CL and just use completion information from the actual running instance
2023-04-15 08:24:02 -0400 < flatwhatson> that's what geiser does
2023-04-15 08:24:15 -0400 < sham1> So you complete using the same system as where you execute the code. And yeah, Geiser also does that
2023-04-15 08:24:58 -0400 < mnieper> Alternative, one could provide static annotations describing the syntax in the source files
2023-04-15 08:25:12 -0400 < mnieper> These could also determine the syntax highlighting and formatting
2023-04-15 08:25:28 -0400 < mnieper> and indentation, etc.
2023-04-15 08:25:57 -0400 < sham1> That would work, although the problem I see with that is that you'd then have to duplicate the information you're writing to syntax-rules/syntax-case anyway. So one would have to figure out the ergonomics
2023-04-15 08:26:28 -0400 < mnieper> sham1: Indentation or syntax highlighting would be information that would not be doubled
2023-04-15 08:26:29 -0400 < flatwhatson> that's what we do crudely with eg. (put 'stream-let 'scheme-indent-function 2)
2023-04-15 08:26:52 -0400 < flatwhatson> a schemey convention for that would be nice
2023-04-15 08:26:58 -0400 < sham1> But that's Emacs-specific. It'd be nice if we could have that but editor-independent
2023-04-15 08:27:07 -0400 < mnieper> flatwhatson: Indeed, and the current approach is global, which is incorrect.
2023-04-15 08:28:25 -0400 < mnieper> Something like (declare-syntax (let ([<var> <expr>] ...) <body>), with correct indentation.
2023-04-15 08:29:14 -0400 < sham1> Well that would have to accept multiple syntaxes, because let for example of course has the named variant
2023-04-15 08:30:18 -0400 < flatwhatson> allow multiple declare-syntax for each valid form
2023-04-15 08:30:35 -0400 < mnieper> Or a list of forms as arguments to one declare-syntax
2023-04-15 08:30:44 -0400 < sham1> Either that or make it so that you can have another (declare-syntax (let <var> ([<var> <expr>] ...) <body>)
2023-04-15 08:30:50 -0400 < sham1> )
2023-04-15 08:31:16 -0400 < mnieper> That approach would not let me shadow a previous declaration locally.
2023-04-15 08:32:03 -0400 < mdhughes> You can just use snippets if you have some pattern you use a lot, let-name<TAB> would expand to the usual with placeholders. But it's not that hard to type (let foo [(... as you work, is it?
2023-04-15 08:32:12 -0400 < sham1> So something like (declare-syntax let list-of-syntaxes)
2023-04-15 08:32:40 -0400 < mnieper> sham1: Just (declare-syntax list-of-syntaxes)
2023-04-15 08:32:48 -0400 < mdhughes> I don't see what benefit that gives you. You type the letters on the keyboard and they show up in your editor. It's more magical than completion!
2023-04-15 08:33:12 -0400 < mnieper> sham1: Or not, don't know
2023-04-15 08:33:40 -0400 < sham1> mdhughes: well, code formatters would benefit
2023-04-15 08:34:26 -0400 < mdhughes> I just recently saw this, and it was so awful: https://www.youtube.com/watch?v=FXx1JGibSz4
2023-04-15 08:34:57 -0400 < flatwhatson> also like eldoc can tell you which parameter you're entering for functions, it could indicate you're in <var> or <expr> or <body>
2023-04-15 08:35:00 -0400 < mdhughes> For the most part, you can indent one tab per ( and unindent one tab per )
2023-04-15 08:35:29 -0400 < sham1> We're programmers, the whole enterprise is based around automating things that people could do manually with computers, but don't want to
2023-04-15 08:35:42 -0400 < mdhughes> I know, I'm a heretic about indentation, in that I think it's utterly irrelevant beyond "does this communicate scope correctly".
2023-04-15 08:36:57 -0400 < flatwhatson> but the editor doesn't understand that for forms like receive, which a naive indenter will mess up
2023-04-15 08:37:37 -0400 < flatwhatson> but every scheme-mode needs to hard-code receive indentation, this would make it portable & extensible for non-standard forms
2023-04-15 08:38:30 -0400 < sham1> mnieper: anyway, the specific form that the syntax declaration would take place can be bikeshed later. I'm more concerned about having to write both the expander and then this extra stuff. As I said, there needs to be a think about the ergonomics
2023-04-15 08:38:52 -0400 < mnieper> Emacs' scheme.el has some stuff hard-coded.  That would be fine if they hadn't added implementation-specific stuff.
2023-04-15 08:40:00 -0400 < mnieper> Which becomes injected in all your Scheme projects (whether written in Guile, MIT, ..., R6RS, R7RS, ...)
2023-04-15 08:41:13 -0400 < mnieper> sham1: Apart from the simplest s-r macros, the user-facing syntax is usually not obvious from the syntax-rules.
2023-04-15 08:41:20 -0400 < mdhughes> I don't use receive (SRFI-8), but it looks pretty normal to me. The formals go on the first line like a function decl, expression next line so no extra indent, body no extra indent, close )
2023-04-15 08:42:15 -0400 < mnieper> receive should be 'scheme-indent-function 2
2023-04-15 08:43:14 -0400 < flatwhatson> lol, i asked chatgpt to write an srfi proposal for declare-syntax
2023-04-15 08:43:29 -0400 < mnieper> But the editor is dumb.  Even when I have it, I don't want that formatting <HERE>: (let ([receive 'dummy]) <HERE>)
2023-04-15 08:43:53 -0400 < mnieper> flatwhatson: lol... what's the output?
2023-04-15 08:44:20 -0400 < flatwhatson> https://paste.debian.net/1277444/
2023-04-15 08:44:48 -0400 < sham1> Hum
2023-04-15 08:45:43 -0400 < flatwhatson> i didn't tell it your declare-syntax example, so it's come up with a rubbish syntax, and failed to properly indent its examples which are meant to demonstrate the indentation
2023-04-15 08:45:53 -0400 < flatwhatson> whitespace is hard when all you have is tokens
2023-04-15 08:47:27 -0400 < flatwhatson> SRFI authors are safe... for now.
2023-04-15 15:49:19 -0400 < acdw> anybody have tips for writing chez with geiser in emacs? apparently it doesn't see code in libraries or something. .... should I just write things out of libraries then package them up as I go? or is there better chez emacs integration to be had?
2023-04-15 16:14:53 -0400 < amirouche> fyi I do not use the geiser integration
2023-04-15 16:15:17 -0400 < amirouche> I could use ed instead of emacs :P
2023-04-15 16:23:01 -0400 < amirouche> I love emacs in the terminal, but with gtk frontend the code is more readable
2023-04-15 16:23:19 -0400 < amirouche> Hmm... maybe that is a problem with my terminal
2023-04-15 16:27:24 -0400 < acdw> hm indeed. what do you use amirouche ?
2023-04-15 16:28:11 -0400 < amirouche> I use emacs
2023-04-15 16:28:24 -0400 < amirouche> you mean what terminal?
2023-04-15 16:28:30 -0400 < amirouche> I use foot, and gnome-terminal
2023-04-15 16:28:54 -0400 < amirouche> I am trying GNOME again, not sure why
2023-04-15 16:34:20 -0400 < wasamasa> foot?
2023-04-15 16:35:32 -0400 < msavoritias> https://codeberg.org/dnkl/foot
2023-04-15 16:35:53 -0400 < amirouche> that is it :)
2023-04-15 16:36:31 -0400 < amirouche> a while back I was on alpine edge, that has latest version of sway, and foot, and it looks very good, very useable et al.
2023-04-15 16:37:11 -0400 < amirouche> Another edgy option is hypr, very nice effects, and good ux
2023-04-15 16:37:13 -0400 < amirouche> https://github.com/hyprwm/Hypr
2023-04-15 16:38:12 -0400 < amirouche> All that said, I need to tell the truth the best things since the invention of the Internet is https://scheme.fail/assets/img/screenshot/loko-0-11-doom-wip.png
2023-04-15 16:42:08 -0400 < msavoritias> And here is me waiting for a scheme wayland wm
2023-04-15 16:42:17 -0400 < msavoritias> Or even better arcan :P
2023-04-15 17:27:06 -0400 < acdw> amirouche: I mean what do you use for scheme authoring
2023-04-15 18:08:43 -0400 < amirouche> acdw: I am a noob emacs user
2023-04-15 18:09:47 -0400 < acdw> aha got you
2023-04-15 18:20:17 -0400 < amirouche> I put much effort into letloop
2023-04-15 18:20:27 -0400 < amirouche> I put much effort into letloop/cli and i have zero stars
2023-04-15 18:20:47 -0400 < amirouche> I put some effort into a broken cloud app, and I did not release the code and I have a dozen stars
2023-04-15 18:20:49 -0400  * amirouche shrugs
2023-04-15 18:43:13 -0400 < wasamasa> highly scientific analysis, that
2023-04-15 18:45:38 -0400 < wasamasa> please don't take github stars or their lack personally
2023-04-15 18:52:09 -0400 < dpk> actually do, because your worth and value as a human being is defined by number go up
2023-04-15 18:52:22 -0400 < dpk> whether number is money, or internet points
2023-04-15 18:52:42 -0400 < dpk> (this is sarcasm, in case i have to point this out)
2023-04-15 18:55:28 -0400 < acdw> do things for fun!
2023-04-15 18:57:06 -0400 < wklew> I did a bunch of work to get the finger tree library in better shape: https://git.sr.ht/~wklew/finger-tree/
2023-04-15 18:57:26 -0400 < wklew> I also documented most things. Check it out!
--- Day changed Sun Apr 16 2023
2023-04-16 03:50:55 -0400 -!- JITn is now known as DKordic
2023-04-16 04:43:02 -0400 < cow_2001> i think i may be doing too much ascii "art"
2023-04-16 04:52:20 -0400 < cow_2001> https://git.sr.ht/~kakafarm/sicp/tree/master/item/sicp/tests/3_14.scm
2023-04-16 05:12:03 -0400 < edgar-rft> modern kids use UTF-8 art
2023-04-16 05:21:12 -0400 < amirouche> Stars help to know whether the current direction is useful / good direction or not
2023-04-16 05:23:09 -0400 < cow_2001> stars *_*
2023-04-16 05:24:10 -0400 < cow_2001> i can point at the north star, maybe, if i'm on the northern hemisphere here on earth
2023-04-16 05:25:16 -0400 < amirouche> ah ah
2023-04-16 05:25:55 -0400 < amirouche> stars is a form of feedback, and I know first hand that it does not necessarly means that is good quality
2023-04-16 05:26:21 -0400 < amirouche> tho, it is more motivating that scavengers cloning the repo, and never giving feedback
2023-04-16 05:29:28 -0400 < cow_2001> hmmmmmmm
2023-04-16 07:19:07 -0400 < dpk> cow_2001: what Scheme implementation is that which is letting you interleave definitions and expressions?
2023-04-16 07:20:28 -0400 < cow_2001> guile
2023-04-16 07:20:37 -0400 < cow_2001> r7rs does not allow?
2023-04-16 07:21:12 -0400 < cow_2001> i get a warning
2023-04-16 07:21:35 -0400 < cow_2001> maybe i should have used a set!
2023-04-16 07:22:18 -0400 < dpk> well, R7RS Large will probably allow it exactly because of situations like this
2023-04-16 07:22:30 -0400 < dpk> in test suites, it makes sense to be able to do this
2023-04-16 07:23:19 -0400 < cow_2001> oh!
2023-04-16 07:23:35 -0400 < cow_2001> then i guess i shouldn't change it
2023-04-16 07:28:31 -0400 < wasamasa> amirouche: hey now, why you calling me a scavenger
2023-04-16 07:28:50 -0400 < wasamasa> amirouche: I can see the case for people forking your repo without ever committing to it
2023-04-16 07:51:44 -0400 < cow_2001> amirouche: who are these people and why do they have Akira Toriyama art on their page? https://wiki.xxiivv.com/site/discourse.html
2023-04-16 07:58:33 -0400 < wklew> cow_2001: that's devine's wiki
2023-04-16 07:58:48 -0400 < wklew> I think they created uxn, among other things
2023-04-16 08:18:53 -0400 < wasamasa> maybe ask that person instead
2023-04-16 08:19:09 -0400 < wasamasa> Bulma is a cool character
2023-04-16 08:24:16 -0400 < cow_2001> i don't like how the two if branches look exactly the same except for two tiny things https://git.sr.ht/~kakafarm/sicp/tree/master/item/sicp/solutions/3_17.scm
2023-04-16 08:28:01 -0400 < wasamasa> honestly, it's less confusing than avoiding the big if and instead putting it into the differing parts
2023-04-16 08:43:02 -0400 < pyzozord> hey, is there some function in scheme to visualize cons cells in ascii?
2023-04-16 08:43:14 -0400 < pyzozord> I think someone here suggested something like this to me last year, but I lost the logs
2023-04-16 08:43:24 -0400 < sham1> Well, you can write it
2023-04-16 08:43:43 -0400 < pyzozord> I thought the suggestion was some built in function
2023-04-16 08:43:48 -0400 < cow_2001> wasamasa: that's what i thought. i started by having two ifs inside the code
2023-04-16 08:43:50 -0400 < pyzozord> it might have been for specific scheme maybe racket
2023-04-16 08:43:56 -0400 < sham1> pyzozord: I meant to use write
2023-04-16 08:43:57 -0400 < pyzozord> or chez
2023-04-16 08:44:05 -0400 < pyzozord> ooh
2023-04-16 08:44:06 -0400 < sham1> But do keep in mind that if the cdr of a pair is another pair, it'll print it like a list
2023-04-16 08:44:24 -0400 < sham1> I don't think there's a procedure that will always print things in form (a . b), even when b is another pair
2023-04-16 08:44:31 -0400 < pyzozord> sham1: no, it had nice ascii boxes and arrows
2023-04-16 08:44:41 -0400 < sham1> That sounds extremely non-standard
2023-04-16 08:44:51 -0400 < pyzozord> might have been a racket thing
2023-04-16 08:46:50 -0400 < pyzozord> ah it was excellent, I can't find it anymore :(
2023-04-16 08:48:38 -0400 < cow_2001> https://git.sr.ht/~kakafarm/sicp/tree/master/item/sicp/solutions/3_19.scm
2023-04-16 08:48:45 -0400 < cow_2001> tortoise and hare! :D
2023-04-16 08:50:05 -0400 < cow_2001> wait, i don't need that deepest null check
2023-04-16 08:50:53 -0400 < cow_2001> och, it doesn't really works
2023-04-16 09:02:28 -0400 < cow_2001> fixed!
2023-04-16 09:48:47 -0400 < amirouche> cow_2001: artists
2023-04-16 11:51:18 -0400 < amirouche> I keep dreaming about this IDE, I will write an attribute it to john
2023-04-16 11:52:20 -0400 < amirouche> wat! epoll is 5 to 10 times faster than io uring via liburing
2023-04-16 11:52:25 -0400 < amirouche> :/
2023-04-16 11:52:52 -0400 < amirouche> rudybot: what would be the best ed ide?
2023-04-16 11:52:52 -0400 < rudybot> amirouche: I just realized that an ide is just an Apple version of ed :)
2023-04-16 11:53:28 -0400 < amirouche> rudybot: you lost your sould when you wrote lle ape, it is: le ape
2023-04-16 11:53:29 -0400 < rudybot> amirouche: If you want to try the command line, then just run this: racket -lle racket racket/future "(processor-count)"
2023-04-16 11:53:46 -0400 < amirouche> rudybot: sorry, I misread, you wrote apple. my mistake.
2023-04-16 11:53:46 -0400 < rudybot> amirouche: i misread. my mistake.
2023-04-16 11:54:43 -0400 < amirouche> rudybot: what do you think about chatbot gpt, that is strong competition to you, isn't it?
2023-04-16 11:54:44 -0400 < rudybot> amirouche: under no circumstances do i recommend using GPT-n as a chatbot for your doctor's office, or w/e
2023-04-16 11:54:48 -0400 < sham1> ChatGPT this ain't
2023-04-16 12:04:46 -0400 < amirouche> that is very interesting: https://gitlab.com/weinholt/schjig
2023-04-16 12:05:02 -0400 < amirouche> it is a fuzzy testing framework for scheme implementations
2023-04-16 12:05:23 -0400 < sham1> quicktest.scm would be nice
2023-04-16 12:05:38 -0400 < amirouche> so there is reference implementation, and a wip implementations, the tests are executed in both, and if not equal, raise an error (AFAIU)
2023-04-16 12:05:49 -0400 < amirouche> sham1: what is quicktest.scm?
2023-04-16 12:06:06 -0400 < sham1> A hypothetical scheme port of QuickTest
2023-04-16 12:06:33 -0400 < amirouche> you mean QuickCheck?
2023-04-16 12:06:42 -0400 < sham1> Yes
2023-04-16 12:09:14 -0400 < amirouche> I looked at QuickCheck, and also the so called american fuzzy loop, I was not very inspired
2023-04-16 12:09:29 -0400 < amirouche> What I did I scrape existing project test suites, like SRFI-180
2023-04-16 12:09:44 -0400 < amirouche> e.g. for HTTP, a good source of tests are apache, nginx, and squid
2023-04-16 12:10:32 -0400 < amirouche> the problem is unlike json test suite, both the input, and output of the tests in scrambled inside non-parentheses slang
2023-04-16 12:11:23 -0400 < amirouche> Google is running AFL, et al. you can find interesting test cases, I do not remember the website, search for something like: google fuzzy testing service
2023-04-16 12:11:45 -0400 < amirouche> anyway, I found what I wanted to read: https://akkuscm.org/packages/text-mode/
2023-04-16 16:06:19 -0400 < cow_2001> what is that thing which creates a port to an in-memory structure which can be written into and then be converted to a string?
2023-04-16 16:06:29 -0400 < cow_2001> string port or something
2023-04-16 16:06:59 -0400 < wasamasa> a string port, yes
2023-04-16 16:08:00 -0400 < cow_2001> okay, srfi-6 has it!
2023-04-16 16:08:18 -0400 < cow_2001> i can now test my display-queue procedure! :D
2023-04-16 16:09:31 -0400 < sham1> r7rs also has itr
2023-04-16 16:11:05 -0400  * cow_2001 checks
2023-04-16 16:30:30 -0400 < mnieper> `open-string-output-port' in R6RS.  (In the R6RS interface, the two logically separate operations, namely writing and extracting, also kept separate.  One can pass a string port to some procedure without giving it the right to extract the string.)
2023-04-16 16:44:54 -0400 < Zipheir> It's too bad that the R6 and R7 names differ for that.
2023-04-16 16:45:48 -0400 < Zipheir> SRFI 6 was well-known when the R6 designers chose to go with different names.
2023-04-16 16:45:54 -0400 < sham1> Too bad there's no way of renaming things :(
2023-04-16 16:46:41 -0400 < Zipheir> Hah. It is indeed easily fixed. It just seems like another unnecessary R6 incompatibility.
2023-04-16 16:46:55 -0400 < Zipheir> R6-to-SRFI incompatibility, I mean.
2023-04-16 16:54:31 -0400 < Zipheir> The R6 authors obviously knew the SRFIs, since the wrote a number themselves (since withdrawn). But they ignored all the ones they didn't write, including popular libraries like SRFI 1. Were those, perhaps, Not Invented Here?
2023-04-16 16:54:32 -0400 < mnieper> Zipheir: The R6RS procedure does not the same as the SRFI 6 procedure.
2023-04-16 16:54:46 -0400 < Zipheir> s/the wrote/they wrote/
2023-04-16 16:55:06 -0400 < mnieper> Choosing the same name would not have been a good idea.
2023-04-16 16:57:06 -0400 < Zipheir> mnieper: Ah, you're right. open-string-output-port returns the extractor.
2023-04-16 16:57:12 -0400 < mnieper> Not taking history into account, the R6RS interface of string ports is better than the SRFI 6 one because of the logical separation of putting and retrieving characters.
2023-04-16 16:57:27 -0400 < mnieper> So they had good reasons not just to blindly copy SRFI 6.
2023-04-16 16:58:16 -0400 < Zipheir> I don't see why returning an extractor thunk is better.
2023-04-16 16:59:00 -0400 < mnieper> The authors also took all procedures of SRFI 1 into account (you can find this is in the rationale).  But, first of all, the SRFI 1 names were not universal (e.g. Chez had andmap instead of for-all/every, etc.), and secondly, the full SRFI 1 library was deemed too large.
2023-04-16 16:59:18 -0400 < Zipheir> Hmm.
2023-04-16 16:59:38 -0400 < mnieper> Claiming that they ignored SRFI 1 is just repeating untruths.
2023-04-16 16:59:54 -0400 < sham1> How ironic, a library considered too large for R6RS
2023-04-16 17:00:06 -0400 < mnieper> Procedures like filter, partition, fold-right, etc. in R6RS follow SRFI !.
2023-04-16 17:00:10 -0400 < mnieper> SRFI 1.
2023-04-16 17:00:19 -0400 < Zipheir> I'm sorry if that's false.
2023-04-16 17:01:18 -0400 < mnieper> sham1: That's also nonsense.  The hash table API in R6RS is also minimal.
2023-04-16 17:01:40 -0400 < mnieper> It was always meant to extend the language with user-written libraries.
2023-04-16 17:01:44 -0400 < Zipheir> Yes. R6 standard libraries are usually very small.
2023-04-16 17:01:59 -0400 < sham1> T'was a joke
2023-04-16 17:02:04 -0400 < Zipheir> It was not the library design that was "maximal".
2023-04-16 17:02:40 -0400 < Zipheir> (Certainly it is a big standard compared to R5.)
2023-04-16 17:03:47 -0400 < mnieper> Zipheir: It is not much bigger compared to R5RS when you measure the time you need to learn the language.
2023-04-16 17:06:06 -0400 < Zipheir> The condition system and phasing will take you some time. (I still don't know the details of phasing.) But those may be part of the R5RS "stone soup".
2023-04-16 17:07:39 -0400 < mnieper> Zipheir: Re returning an extra thunk: It is better because it maintains an important abstraction barrier: When you create a string port in R6RS and pass it to a producer, you can be sure that the produce cannot act as a consumer.
2023-04-16 17:08:22 -0400 < dpk> i wonder what the smallest possible subset of Scheme not including lambda is
2023-04-16 17:08:36 -0400 < dpk> possibly just eval and quote, maybe
2023-04-16 17:08:59 -0400 < Zipheir> If you fully specify the semantics of 'eval', you are done. :)
2023-04-16 17:09:25 -0400 < dpk> smallest possible Turing complete subset, i mean
2023-04-16 17:09:31 -0400 < Zipheir> mnieper: In other words, no one but you can get the resulting string?
2023-04-16 17:10:11 -0400 < mnieper> Zipheir: re condition system and phasing: If you want to understand this thoroughly, you need to spend some time you wouldn't need to spend on R5RS, of course.  But the good thing is that as long as you write the programs that were also possible with R5RS, you wouldn't notice.
2023-04-16 17:10:26 -0400 < dpk> no, wait
2023-04-16 17:10:48 -0400 < mnieper> Zipheir: If you just import (rnrs) and don't write procedural macros, you don't have to worry even in systems with explicit phasing.
2023-04-16 17:11:29 -0400 < mnieper> Zipheir: Yes, as long as only you have access to the thunk, no one else can read the port.
2023-04-16 17:11:42 -0400 < Zipheir> mnieper: True, but if we are really talking about "learning the language", that means learning the whole thing.
2023-04-16 17:11:51 -0400 < Zipheir> mnieper: I agree. That is a better design.
2023-04-16 17:12:53 -0400 < mnieper> dpk: Wait for what?
2023-04-16 17:15:06 -0400 < dpk> i think you’ll have to wait for me to sleep before i try to think about things like how Scheme works
2023-04-16 17:16:15 -0400 < mnieper> And whether eval and quote suffices?
2023-04-16 17:19:18 -0400 < dpk> it doesn’t
2023-04-16 17:21:02 -0400 < mnieper> Zipheir: Yes, learning the whole thing will take some more time, but not a magnitude more.  Of course, R6RS does extend R5RS, as does R7RS (and as R5RS did R4RS).
2023-04-16 17:30:33 -0400 < mnieper> https://en.wikipedia.org/wiki/One-instruction_set_computer
2023-04-16 17:31:42 -0400 < mnieper> So Scheme should only have one special form :)
2023-04-16 23:38:59 -0400 < mdhughes> I prefer a more complex instruction set: https://en.wikipedia.org/wiki/Brainfuck
2023-04-16 23:43:03 -0400 < mdhughes> tho of course in Scheme they'd need better names. (increment-address) (decrement-address) (increment-value) (decrement-value) (output-value) (input-value) (begin ...)
2023-04-16 23:52:02 -0400 < flatwhatson> call it Brainhug
--- Day changed Mon Apr 17 2023
2023-04-17 02:47:39 -0400 < lockywolf> Isn't bf basically a Turing machine
2023-04-17 02:47:41 -0400 < lockywolf> ?
2023-04-17 02:49:42 -0400 < lockywolf> https://paste.debian.net/1277595/
2023-04-17 04:53:35 -0400 < sham1> Not just basically, BF explicitly is Turing complete
2023-04-17 05:09:09 -0400 < dave0> this is a good esoteric language https://esolangs.org/wiki/ByteByteJump
2023-04-17 05:26:04 -0400 < edgar-rft> my BoyFriend is Turing complete, too
2023-04-17 10:24:11 -0400 < Oxyd> Does he have infinite “tape”?
2023-04-17 10:33:14 -0400 < DKordic> lockywolf: Yes, it's almost PDP(11)!
--- Day changed Tue Apr 18 2023
2023-04-18 01:50:33 -0400 < cow_2001> is it a complete mistake to break up a very link library into many small library files each with a single function?
2023-04-18 01:50:49 -0400 < cow_2001> sorry, i mean, long library, not link. too much linked lists.
2023-04-18 01:51:24 -0400 < cow_2001> "very long" might not be very long in normal person's terms
2023-04-18 01:51:55 -0400 < cow_2001> i just want to change only one thing at a time without fearing i've changed something else by accident
2023-04-18 02:20:52 -0400 < mdhughes> I wouldn't do single functions. Most of my libraries are dozen or two related functions. But my main library is a gigantic mess, I haven't got around to splitting it up nicely.
2023-04-18 02:21:13 -0400 < mdhughes> SRFIs are a good example to work from.
2023-04-18 02:29:20 -0400 < cow_2001> i am trying it just for the hell of it for this one exercise
2023-04-18 02:33:17 -0400 < flatwhatson> cow_2001: use version control and review your own changes
2023-04-18 02:33:29 -0400 < flatwhatson> then you'll never be unsure about what you've changed :)
2023-04-18 02:34:21 -0400 < cow_2001> hmmmm so just stage things that are pretty much done and then restage when i think they should be changed
2023-04-18 02:34:34 -0400 < cow_2001> oh kay
2023-04-18 02:35:00 -0400 < flatwhatson> yes, that can work, though committing is better than staging
2023-04-18 02:35:25 -0400 < cow_2001> but i don't want to commit D:<
2023-04-18 02:35:33 -0400 < flatwhatson> no harm in a bunch of "wip" commits, you can squash them later
2023-04-18 02:35:34 -0400 < cow_2001> they're not done
2023-04-18 02:35:39 -0400 < cow_2001> hmm
2023-04-18 02:36:12 -0400 < cow_2001> HMM!
2023-04-18 02:36:55 -0400 < cow_2001> thank you
2023-04-18 02:37:17 -0400 < flatwhatson> np :)
2023-04-18 07:37:32 -0400 < cow_2001> okay, here it is. a [can we cuss in here? i imagine not.] deque! https://git.sr.ht/~kakafarm/sicp/commit/2d1e58224d4dd0d8ee91fc711691e470f8cbcd96
2023-04-18 07:38:02 -0400 < cow_2001> flatwhatson: look at this horror
2023-04-18 07:38:14 -0400 < cow_2001> i can finally continue
2023-04-18 09:19:34 -0400 -!- prestidigitator is now known as f8l
2023-04-18 10:10:44 -0400 < lockywolf> cow_2001: doing sicp?
2023-04-18 10:25:27 -0400 < cow_2001> lockywolf: doing sicp B€
2023-04-18 10:25:44 -0400 < lockywolf> B-Euro?
2023-04-18 10:26:39 -0400 < cow_2001> it kind of looks like https://us.v-cdn.net/5021068/uploads/editor/vb/pj6pzor7wjjb.png
2023-04-18 14:27:44 -0400 < mdhughes> Maximum perversity: https://ianthehenry.com/posts/generalized-macros/
2023-04-18 14:28:42 -0400 < mdhughes> The joke, I guess, is that you can just do this now with a wrapping macro. Instead of defer inside a group, you'd (defer-group ... (defer ...
2023-04-18 14:28:51 -0400 < acdw> oh god
2023-04-18 14:29:22 -0400 < mdhughes> But by introducing multiple insane features, you can get rid of that group!
2023-04-18 14:34:03 -0400 < mdhughes> Tho happily Scheme already has #;(comment) so we don't need that.
2023-04-18 15:08:13 -0400 < acdw> lol
2023-04-18 15:31:30 -0400 < gwatt> mdhughes: That blog post's an interesting mind-bender. I guess I'm glad someone has explored and blogged about it, but I would run away if I ever encountered it in the wild
2023-04-18 15:34:14 -0400 < mdhughes> rudybot, tell mnieper to read the history.
2023-04-18 15:34:15 -0400 < rudybot> mdhughes: maybe this is the kind of thing? https://github.com/mnieper/rapid-scheme
2023-04-18 15:35:42 -0400 < mdhughes> rudybot, later tell mnieper to read the history.
2023-04-18 15:35:42 -0400 < rudybot> mdhughes: I asked `MemoServ' to forward the message to mnieper.
2023-04-18 17:57:11 -0400 < flatwhatson> lol, "introduce multiple insane features" "you mean like this implementation of R7RS?" :D
2023-04-18 18:03:41 -0400 < acdw> insane features!
--- Day changed Wed Apr 19 2023
2023-04-19 00:55:19 -0400 -!- ormaaj1 is now known as ormaaj
2023-04-19 05:36:58 -0400 < lockywolf> Janet is intentionally called like this in order to be confusable with Julia.
2023-04-19 05:37:21 -0400 < lockywolf> Those context-sensitive macros are nice though.
2023-04-19 05:38:04 -0400 < lockywolf> But I don't see why they should be limited to ((lefts) macroname (rights))
2023-04-19 05:38:57 -0400 < lockywolf> They should really be given just a pointer to their position in the code, and the whole syntactic tree.
2023-04-19 09:45:00 -0400 < cow_2001> hmm no srfi-170 in guile
2023-04-19 09:45:03 -0400 < cow_2001> oh well
2023-04-19 10:16:18 -0400 < flatwhatson> all the functionality is there, just needs a compatibility wrapper
2023-04-19 12:17:44 -0400 < mnieper> mdhughes: What is in the history that I should read?
2023-04-19 12:19:16 -0400 < gwatt> mnieper: I think this: https://ianthehenry.com/posts/generalized-macros/
2023-04-19 19:11:01 -0400 -!- JudgeChicken is now known as ZombieChicken
--- Day changed Thu Apr 20 2023
2023-04-20 01:49:23 -0400 < ecraven> gwatt: thanks, that's an interesting read!
2023-04-20 03:59:34 -0400 < amirouche> ecraven: I have just stolen your code, catch me if you can :p
2023-04-20 04:00:07 -0400 < ecraven> which code? feel free, I don't have secret code, just bad code I'd like to hide :P :D
2023-04-20 04:01:27 -0400 < amirouche> indeed, I had to fix a memory leak :D
2023-04-20 04:01:44 -0400 < amirouche> in the socket libraries from github chez-scheme-libraries
2023-04-20 04:02:00 -0400 < amirouche> also there is a line repeated twice
2023-04-20 04:04:16 -0400 < amirouche> oh I misread, it is not the same line, I need filled an issue
2023-04-20 04:08:12 -0400 < amirouche> done
2023-04-20 04:08:31 -0400 < ecraven> thanks. it's very possible there are memory leaks
2023-04-20 04:08:41 -0400 < amirouche> yeah, I did not test for it yet
2023-04-20 04:08:53 -0400 < amirouche> but that one, I think is obvious
2023-04-20 04:13:55 -0400 < ecraven> hm.. I need to look into the C socket documentation, on *when* I am allowed to release that
2023-04-20 04:22:10 -0400 < amirouche> improving quality is worth it
2023-04-20 10:35:33 -0400 < cow_2001> hmmmmmm...... so sicp's solution to the problem of not being able to properly change the procedure input is to create a pair, writing nonsense in its car and putting the pointer to the actual data in the cdr
2023-04-20 10:35:45 -0400 < cow_2001> instead of having a proper box
2023-04-20 11:16:11 -0400 < acdw> hm
2023-04-20 11:19:14 -0400 < gwatt> I'm surprised sicp's solution isn't a variadic lambda, like parameter objects
2023-04-20 11:35:24 -0400 < cow_2001> gwatt: what's a variadic lambda? wait, i have the internet!
2023-04-20 11:36:06 -0400 < sham1> One that has variable arity
2023-04-20 11:36:42 -0400 < cow_2001> (lambda x …)
2023-04-20 11:37:06 -0400 < acdw> i always forget about the plain x form
2023-04-20 11:37:24 -0400 < cow_2001> it's not obvious!
2023-04-20 11:37:32 -0400 < acdw> for an endless loop, (let loop () ...) is the way to go right?
2023-04-20 11:37:35 -0400 < acdw> lol yeah
2023-04-20 11:38:16 -0400 < cow_2001> but when you really think about it, it's the obvious way to go
2023-04-20 11:38:40 -0400 < acdw> nice
2023-04-20 11:38:44 -0400 < acdw> oh lol yeah
2023-04-20 11:38:44 -0400 < cow_2001> <_<
2023-04-20 11:38:46 -0400 < cow_2001> >_>
2023-04-20 11:39:14 -0400 < acdw> ^_^
2023-04-20 11:39:46 -0400 < sham1> v_v
2023-04-20 11:41:01 -0400 < cow_2001> i had a dumb question. why not have (define x …)'s value also be the value assigned to x?
2023-04-20 11:41:13 -0400 < cow_2001> i still have this dumb question
2023-04-20 11:42:28 -0400 < acdw> is it not so?
2023-04-20 11:42:43 -0400 < acdw> oh you mean (define x ...) should return x
2023-04-20 11:42:56 -0400 < acdw> it does that in elisp for sure, it would be nice if it did so in scheme
2023-04-20 11:43:10 -0400 < gwatt> So (display (define x 6)) should print out "6" ?
2023-04-20 11:44:08 -0400 < acdw> that'd be dope
2023-04-20 11:44:14 -0400 < acdw> like i get why it doesn't
2023-04-20 11:44:17 -0400 < acdw> but still!
2023-04-20 11:51:38 -0400 < gwatt> I think a value-returning define is kind of useless
2023-04-20 11:52:05 -0400 < gwatt> Though scheme does distinguish between define and set!, whereas other lisps might not as much?
2023-04-20 11:52:43 -0400 < johnjaye> gwatt: the usage is something like (while (setq x (foo x)) ... <body forms>)
2023-04-20 11:53:11 -0400 < johnjaye> so you can check for the result and assign it in one step
2023-04-20 11:55:33 -0400 < cow_2001> i am the walrus! i am the walrus! choo choo ka choo!
2023-04-20 11:57:09 -0400 < gwatt> johnjaye: yeah, I thought of that, however the discussion did start with the (define ..) form, and I suspect the scoping rules of scheme would prevent the defined identifier being visible later in the code
2023-04-20 12:13:36 -0400 < mdhughes> I'd very much prefer a set! that returns, but you can make a macro to do that. I do, in the sense that my list-push! type macros return as well, but I haven't made just a set-that-returns!
2023-04-20 12:15:55 -0400 < Zipheir> cow_2001: define is not an expression.
2023-04-20 12:17:17 -0400 < Zipheir> cow_2001: Also, define can't appear in an "expression context" in standard Scheme.
2023-04-20 12:18:43 -0400 < Zipheir> Although I'm not entirely sure whether (define x (let () (define y 4))) is legal.
2023-04-20 12:19:38 -0400 < DeeEff> Zipheir: I'm not sure it's correct to say define is not an expression
2023-04-20 12:19:47 -0400 < DeeEff> AFAICT R7RS says nothing about it
2023-04-20 12:20:03 -0400 < Zipheir> CHICKEN allows that expression with x being assigned #<unspecified>. R6 implementations spit it out.
2023-04-20 12:20:39 -0400 < Zipheir> DeeEff: I don't know what it is, but I'm pretty sure it's not an expression. :-/
2023-04-20 12:20:44 -0400 < acdw> let's have a notation for procedures that return : proc⮐
2023-04-20 12:20:53 -0400 < acdw> (set!⮐ x 'foo), e.g.
2023-04-20 12:20:57 -0400 < DeeEff> In fact, by reading it to the letter you'd say it's definitely an expression but just one that always returns an unspecified value
2023-04-20 12:21:02 -0400 < Zipheir> It has side effects, of course.
2023-04-20 12:21:06 -0400 < DeeEff> because it side-effects the environment, yea
2023-04-20 12:21:33 -0400 < DeeEff> Scheme has syntax but nothing approximating the idea of "statements"
2023-04-20 12:21:59 -0400 < DeeEff> most Schemes actually allow for (let ((x (define y 1))) ...)
2023-04-20 12:22:00 -0400 < Zipheir> What would you call 'set!', then?
2023-04-20 12:22:03 -0400 < DeeEff> although that wouldn't be useful
2023-04-20 12:22:10 -0400 < DeeEff> set! is an expression, not a statement
2023-04-20 12:22:14 -0400 < DeeEff> this is actually in R7RS
2023-04-20 12:22:23 -0400 < mdhughes> Exception: no expressions in body (let () (define y 4))
2023-04-20 12:22:24 -0400 < DeeEff> See section 4.1.6
2023-04-20 12:22:29 -0400 < Zipheir> OK.
2023-04-20 12:22:57 -0400 < Zipheir> BTW, R6RS 1.5 says "definitions are not expressions".
2023-04-20 12:23:19 -0400 < Zipheir> I like that they stated that.
2023-04-20 12:24:30 -0400 < DeeEff> R7RS says "Definitions are either variable definitions, syntax definitions, or record-type definitions, all of which are explained in this chapter. They are valid in some, but not all, contexts where expressions are allowed, specifically at the outermost level of a <program> and at the beginning of a <body>."
2023-04-20 12:24:39 -0400 < Zipheir> So I guess Scheme doesn't have statements, only side-effecting expressions with meaningless values.
2023-04-20 12:25:06 -0400 < DeeEff> I'd rank definitions under "special-case expressions that are not valid in all contexts"
2023-04-20 12:25:14 -0400 < DeeEff> but that's just how R7 writes it
2023-04-20 12:25:20 -0400 < DeeEff> R6 does a better job disambiguating here
2023-04-20 12:25:20 -0400 < Zipheir> R7 is looser than R6 in this case.
2023-04-20 12:26:00 -0400 < Zipheir> "One man's constant is another man's variable." --Perlis
2023-04-20 12:26:14 -0400 < acdw> i think it should all be an expression, #hottake
2023-04-20 12:26:21 -0400 < DeeEff> I think this is because R7 is allowing for define to be called inside let/letrec/etc
2023-04-20 12:26:42 -0400 < Zipheir> Ah, good point.
2023-04-20 12:26:53 -0400 < DeeEff> R7 also has a whole section (5.3.2) on internal definitions
2023-04-20 12:26:56 -0400 < Zipheir> That makes (define y 1) a valid lambda body, then...
2023-04-20 12:27:00 -0400 < DeeEff> yes
2023-04-20 12:28:42 -0400 < Zipheir> acdw: You can already use set! almost anywhere. Many Schemes allow set! to create definitions, too. (I don't recommend exploiting that.)
2023-04-20 12:30:34 -0400 < Zipheir> acdw: There's also a serious question of scope if define can be used an expression. What is the scope of x in (let ((y (begin (define x 2) 1))) ...) ?
2023-04-20 12:30:41 -0400 < Zipheir> s/an/as an/
2023-04-20 12:31:15 -0400 < DeeEff> I guess to the original point that spawned the above disagreement: "define should return the value it bound" -> I'd disagree, this is like allowing for `if x = 1` in C, which is all sorts of stupid and breaks things in subtle ways
2023-04-20 12:31:48 -0400 < Zipheir> DeeEff: Yes.
2023-04-20 12:32:29 -0400 < DeeEff> I suppose we're in violent agreement then :)
2023-04-20 12:33:04 -0400 < Zipheir> I hope I didn't give the impression that I was upset or argumentative. I think it's a fascinating topic.
2023-04-20 12:33:21 -0400 < DeeEff> not at all, I worry I was giving the same impression and I also find it fascinating
2023-04-20 12:34:30 -0400 < DeeEff> Not really on topic but: one big shift in C/C++ -> Rust that I really appreciated is that almost everything is an expression, despite the syntax. It made it feel a lot more like a Lisp / Scheme even with all the syntax :P
2023-04-20 12:35:54 -0400 < Zipheir> Or perhaps people are slowly rediscovering Pascal. :)
2023-04-20 12:37:42 -0400 < DeeEff> ssshhhhh you'll scare us all away
2023-04-20 12:38:34 -0400 < Zipheir> Ada is also ripe for rediscovery, although the abstraction level is a bit low for modern tastes.
2023-04-20 12:38:44 -0400 < johnjaye> i mean pascal was basically the practical incarnation of algol right
2023-04-20 12:38:53 -0400 < DeeEff> BTW not sure I ever announced this but: https://gitlab.com/ThatGeoGuy/chicken-transducers
2023-04-20 12:39:10 -0400 < DeeEff> it says "chicken" on the tin but as of 0.3.0 it is now an R7RS module
2023-04-20 12:39:17 -0400 < DeeEff> module / library / whatever we call it now
2023-04-20 12:39:21 -0400 < Zipheir> johnjaye: No, that was Algol 68, of which Pascal was a descendent.
2023-04-20 12:39:35 -0400 < johnjaye> ah ok. well in any event earlier means better right.
2023-04-20 12:39:36 -0400 < Zipheir> *descendant
2023-04-20 12:39:42 -0400 < johnjaye> so pascal should be the best language
2023-04-20 12:40:09 -0400 < Zipheir> I've always liked Pascal. Then again, I was born after the Pascal / C wars.
2023-04-20 12:40:47 -0400 < johnjaye> i think rust and c are at different levels. to that point about it being impossible to be both fast and modular.
2023-04-20 12:41:15 -0400 < johnjaye> there should be a "lower level" like c/go/fortran where you only care about speed. and a "higher level" like rust/c++/java where you care about modularity
2023-04-20 12:41:19 -0400 < DeeEff> Indeed they are at different levels. C is an abstraction for a PDP-11 and Rust is a general purpose programming language with a fully qualified type system
2023-04-20 12:41:26 -0400 < DeeEff> I'll show myself the door :X
2023-04-20 12:43:54 -0400 < acdw> Zipheir: that's a good point!
2023-04-20 12:44:09 -0400 < acdw> also DeeEff, absolute
2023-04-20 12:44:48 -0400 < acdw> i'm still thinking we need a forth/lisp hybrid called fith
2023-04-20 12:44:52 -0400 < gwatt> johnjaye: I think assuming low-level vs high-level being about performance is a bad assumption. For starters, once you remove having to worry about malloc/free, more complicated yet performant data structures become easier to reason about. Also, the more complex type systems enable implementations to "know" more about the source code and generate more efficient results
2023-04-20 12:44:53 -0400 < acdw> maybe fithp
2023-04-20 12:45:04 -0400 < Zipheir> Rust, however, is a huge language, while "a little C is all there is" (Larry Wall).
2023-04-20 12:45:23 -0400 < Zipheir> (But Larry adds "I'm still learning those libraries, though".)
2023-04-20 12:46:00 -0400 < Zipheir> acdw: Sounds like Joy.
2023-04-20 12:46:02 -0400 < johnjaye> gwatt: maybe. for speed a language made for a pdp-11 is still king
2023-04-20 12:46:11 -0400 < acdw> joy!? ooooo
2023-04-20 12:46:30 -0400 < Zipheir> Look up the Joy Programming Language. It was billed as "FORTH's functional cousin".
2023-04-20 12:46:33 -0400 < acdw> ooo
2023-04-20 12:47:18 -0400 < Zipheir> IIRC jcowan implemented a large chunk of Joy in Scheme.
2023-04-20 12:47:38 -0400 < acdw> ooo
2023-04-20 12:47:52 -0400 < Zipheir> Yeah http://vrici.lojban.org/~cowan/joy.ss
2023-04-20 12:47:58 -0400 < acdw> very cool
2023-04-20 13:28:59 -0400 < wklew> DeeEff Thanks, I'm going to play with transduce for the finger tree library
2023-04-20 13:29:04 -0400 < wklew> I was the one who responded in the chicken mailing list asking for R7 support, hehe
2023-04-20 13:31:22 -0400 < DeeEff> wklew: oh that's awesome. Send me an email or ping me here if you have questions about how to make the two work together more nicely
2023-04-20 13:31:38 -0400 < DeeEff> I saw your finger-tree library but haven't gotten around to spending time looking at the API
2023-04-20 13:32:28 -0400 < wklew> will do. really the only thing to look at right now is (finger-tree seq) which is like Haskell's Data.Sequence
2023-04-20 15:24:06 -0400 < jcowan> Pascal was the result of a rebellion in the Algol committee after Algol 60.  One group went on and wrote Algol 68; the rebels thought it was too complicated and published the interim Algol W which then became Pascal and from there Euler, Modula(-[23]), Mesa, Oberon.
2023-04-20 15:25:49 -0400 < jcowan> One of the changes between R5 and R7 was that R5's `eval` would only handle expressions, whereas in R7 it handles definitions too (but not imports, but that's pretty much okay because you can now construct run-time environments from libraries)
2023-04-20 15:26:15 -0400 < jcowan> Oh, and Ada is a Pascal descendant too
2023-04-20 15:28:19 -0400 < jcowan> In a sense, so is the 8086 architecture with its four segment registers. They were intended to give you 64K of code, global data, stack, and heap, because in a Pascal implementation you always statically know what space a pointer points to.
2023-04-20 15:28:43 -0400  * jcowan scrools back
2023-04-20 15:30:49 -0400 < jcowan> A way to think about the meaning of (lambda x ...) is the idea that a non-list is a kind of improper list of length 0.  So whereas (lambda (x . y) ...) binds x to the 0th and only required parameter and y is bound to a list of all remaining parameters, so (lambda y ...) has no required parameters to bind and y is bound to a list of all parameters.
2023-04-20 15:33:47 -0400 < DeeEff> ^ that is generally how I've interpreted it, as a kind of light-pattern-matching
2023-04-20 16:01:21 -0400 < jcowan> The original design for SRFI 1 made list?, improper-list?, and circular-list? a full partition of all objects, but there was too much objection from the assembled multitudes.  So improper-list? was made to be true only of things made of pairs, as it is today.
2023-04-20 16:05:03 -0400 < amirouche> John, you, here!
2023-04-20 16:08:28 -0400 < jcowan> I've been a little bit sick and I still am, I took today off work to try to recover fully
2023-04-20 16:35:14 -0400 < amirouche> stay safe
2023-04-20 17:33:40 -0400  * tomhg been here, done that. I'm struggling guys. See you in a few.
2023-04-20 17:35:01 -0400 < Zipheir> tomhg: I hope things improve for you.
2023-04-20 17:36:14 -0400 < tomhg> Thanks, Zipheir. I havn't applied my nested tmux. So a short relog before leaving.
--- Log closed Thu Apr 20 17:39:56 2023
--- Log opened Thu Apr 20 17:41:16 2023
2023-04-20 17:41:16 -0400 -!- Irssi: #scheme: Total of 196 nicks [0 ops, 0 halfops, 0 voices, 196 normal]
2023-04-20 17:41:17 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-04-20 19:14:37 -0400 -!- epony is now known as Guest3663
2023-04-20 19:17:31 -0400 -!- Guest3663 is now known as epony
2023-04-20 20:33:06 -0400 < mdhughes> Supposedly GCC-12 has Modula-2 support now, so the "good parts edition" of Pascal. https://gcc.gnu.org/onlinedocs/gm2/index.html#SEC_Contents
2023-04-20 20:45:54 -0400 < mdhughes> I can't seem to get gm2 to install from gcc12, so I dunno if it's actually real. I'd rather use someone else's compiler anyway, but it'd be nice if it existed.
2023-04-20 20:52:25 -0400 < Oxyd> It's strange how the Pascal family didn't gain more traction. Delphi (i.e. Object Pascal) was semi-popular some time ago, but even that has died out.
2023-04-20 20:55:05 -0400 < mdhughes> It came really close thru the mid-80s, Macs were all Pascal to late-80s. And then shitty C on shitty Intel/Windows won, the world fell into barbarism, all was lost.
2023-04-20 20:55:35 -0400 < mdhughes> (I wrote mostly C late-80s on, so I'm not guiltless)
2023-04-20 20:56:31 -0400 < Oxyd> And now JavaScript has won. Almost like being shit is some sort of evolutionary advantage for languages.
2023-04-20 20:58:03 -0400 < mdhughes> Cue Gabriel's rant.
2023-04-20 20:58:38 -0400 < mdhughes> https://www.dreamsongs.com/WorseIsBetter.html
2023-04-20 21:00:11 -0400 < flatwhatson> javascript didn't win, it just held a monopoly on browser scripting for a bit
2023-04-20 21:04:15 -0400 < Oxyd> Still does, as far as I can see.
2023-04-20 21:04:52 -0400 < Oxyd> Also people have been using it outside the browser as well.
2023-04-20 21:24:32 -0400 < mdhughes> In the near future, everyone will code Scheme in the browser.
2023-04-20 21:24:36 -0400 < flatwhatson> i think things are slowly heading in a better direction with wasm
2023-04-20 21:25:12 -0400 < flatwhatson> not sure whether scheme can capture the zeitgeist, but at least it will be an *option*
2023-04-20 22:30:54 -0400 < aeth> in the near future, the web will be replaced with Scheme
2023-04-20 22:32:02 -0400 < mdhughes> You kinda can now, with Kawa or Clojure (if we count all paren-based nonsense), and amirouche's server? Which I haven't tried yet.
2023-04-20 22:58:25 -0400 < aeth> mdhughes: I was thinking about something more like https://en.wikipedia.org/wiki/Gemini_(protocol)
2023-04-20 23:46:23 -0400 < lockywolf> Can someone remind me... I remember there was an essay, or an online rant, from someone prominent, about how "code" and "programs" is a _bad_ way of expressing thoughts and reasoning.
2023-04-20 23:46:33 -0400 < lockywolf> What may that be?
--- Day changed Fri Apr 21 2023
2023-04-21 00:03:00 -0400 < epony> https://en.wikipedia.org/wiki/Software_crisis?useskin=vector#Causes
2023-04-21 00:04:11 -0400 < epony> programmer errors, not expression weaknesses
2023-04-21 00:04:19 -0400 < epony> mostly in the time domain
2023-04-21 00:04:28 -0400 < epony> logic fails
2023-04-21 00:05:40 -0400 < epony> still waiting for an OS in a Lisp dialect
2023-04-21 00:55:47 -0400 < sham1> Well there is Mezzano
2023-04-21 01:22:20 -0400 < mdhughes> https://github.com/jart/sectorlisp
2023-04-21 03:11:22 -0400 < weinholt> epony, https://scheme.fail :)
2023-04-21 09:44:16 -0400 < dpk> jcowan: assimilation
2023-04-21 09:44:19 -0400 < dpk> or assimilated
2023-04-21 09:44:27 -0400 < dpk> for the self-describing linguistic terms list
2023-04-21 09:44:45 -0400 < dpk> (thanks to my Old Norse lecturer for pointing this out)
2023-04-21 09:45:21 -0400 < dpk> oh, it's already there
2023-04-21 09:45:23 -0400 < dpk> several times over, in fact
2023-04-21 10:00:46 -0400 < dpk> oh, no it isn’t
2023-04-21 10:00:52 -0400 < dpk> i misread
2023-04-21 10:15:37 -0400 < epony> weinholt, more like fortress fail, same dude different lang  https://en.wikipedia.org/wiki/Fortress_(programming_language)?useskin=vector#History  (killed by your VM)
2023-04-21 10:17:12 -0400 < weinholt> epony, no no, it's a real url to a scheme that runs on bare metal
2023-04-21 10:20:09 -0400 < acdw> owo
2023-04-21 10:26:10 -0400 < epony> Fortress looks like a delayed by 35-40 years Pascal  https://en.wikipedia.org/wiki/Pascal_(programming_language)?useskin=vector  "Pascal became very successful in the 1970s, notably on the burgeoning minicomputer market. Compilers were also available for many microcomputers as the field emerged in the late 1970s. It was widely used as a teaching language in university-level programming courses in the 1980s, and also used in production settings for writing
2023-04-21 10:26:10 -0400 < epony> commercial software during the same period. It was displaced by the C programming language during the late 1980s and early 1990s as UNIX-based systems became popular, and especially with the release of C++."
2023-04-21 11:49:56 -0400 < Zipheir> Fortress is very different from Pascal, as I understand it.
2023-04-21 11:54:27 -0400 < wasamasa> yeah, it looked more like Ada to me
2023-04-21 11:56:58 -0400 < Zipheir> At least from his presentations, it seems like Steele meant to avoid accumulators and other imperative idioms on the grounds that they don't parallelize well.
2023-04-21 11:58:12 -0400 < Zipheir> Xah Lee sums up his views as "don't iterate, recurse, and get rid of cons!".
2023-04-21 11:59:08 -0400 < Zipheir> I suspect this was never going to become a mainstream language *this* decade.
2023-04-21 12:00:20 -0400 < Zipheir> Accumulators are beloved in both imperative and functional programming!
2023-04-21 12:02:13 -0400 < acdw> aw i like cons
2023-04-21 12:04:25 -0400 < Zipheir> It might be that cons is fine if it's lazy.
2023-04-21 12:05:00 -0400 < amirouche> wasm uprising was my motivation for building letloop
2023-04-21 12:05:26 -0400 < amirouche> letloop's cloud
2023-04-21 12:06:10 -0400 < amirouche> I am working on a standalone self hosted before maybe getting into more serverless like thing
2023-04-21 12:06:16 -0400 < amirouche> called petit cloud
2023-04-21 12:06:33 -0400 < amirouche> Also I had a look at visual programming done in the browser
2023-04-21 12:06:45 -0400 < amirouche> point and click style
2023-04-21 12:09:13 -0400 < amirouche> the code is not hard to put together, but finding a way to make it sustainable
2023-04-21 12:12:30 -0400 < amirouche> Here is a demo of petit-cloud: https://functional.cafe/@aziz/110231128674042632
2023-04-21 12:13:13 -0400 < amirouche> here is the browser editor: https://functional.cafe/@aziz/110219470351022503
2023-04-21 12:13:29 -0400 < amirouche> I need to create a video of the editor it will be more appealing
2023-04-21 12:15:01 -0400 < amirouche> re petit-cloud, my point is that chez scheme is possibly beter, at least a good enough target for the use cases targeting wasm in the backend
2023-04-21 12:15:18 -0400 < amirouche> and the primary target of wasm in the backend is serverless cloud
2023-04-21 12:47:11 -0400 < amirouche> re natural language history: I met someone that argued that latin, and greek grammarians were gate keepers. Wat a nite!
2023-04-21 12:48:39 -0400 < amirouche> according to her, grammar is based on natural language, but latin is everything, but natural
2023-04-21 12:48:59 -0400 < amirouche> anthroposcene call that written, and spoken english
2023-04-21 12:52:26 -0400 < amirouche> I am paraphrasing: "grammar is the antic way of having a passport, and a blue check mark"
2023-04-21 13:04:48 -0400 < msavoritias> I hope it doesnt stop there
2023-04-21 13:04:48 -0400 < msavoritias> I have high hopes for wasm to replace more stuff
2023-04-21 13:04:48 -0400 < msavoritias> Serverless cloud is the least interesting thing for wasm imo
2023-04-21 13:12:34 -0400 < Zipheir> It's a language with approximately one major implementation.
2023-04-21 13:12:51 -0400 < Zipheir> The Web already revolves around Chromium.
2023-04-21 13:17:18 -0400 < DeeEff> s/Chromium/Internet Explorer 7/
2023-04-21 13:17:25 -0400 < DeeEff> :)
2023-04-21 13:31:13 -0400 < jcowan> There are languages with (a) one implementation, (b) one dominantn implementation which all others must follow slavishlyl (c) many implementations, mostly following a standards document.
2023-04-21 13:34:40 -0400 < mdhughes> Then there's BASIC, where everyone took the minimal 10 statements or so and copied whatever they wanted. Standards-compliant BASICs were immediately forgotten.
2023-04-21 13:35:06 -0400 < mdhughes> Pascal to some extent, too. There's a standard, but the useful impls ignore it.
2023-04-21 13:35:37 -0400 < Zipheir> Those are rather old examples.
2023-04-21 13:37:00 -0400 < mdhughes> Wait 'til you hear how old Latin & Greek are!
2023-04-21 13:37:07 -0400 < Zipheir> We are squarely in the era of one-implementation/one-dominant-implementation languages, because modern languages are too big and complicated to implement.
2023-04-21 13:38:05 -0400 < wasamasa> I for one, am glad that R7RS-large introduces brings this to scheme
2023-04-21 13:38:36 -0400 < Zipheir> mdhughes: I mean that that was a good situation. If people are coming up with many dialects, a language is thriving. It's simple enough to be grokked by many.
2023-04-21 13:38:47 -0400 < mdhughes> APL, J, K, L, R, S, MATLAB are all incoherent variants of APL.
2023-04-21 13:39:44 -0400 < mdhughes> Also just newer languages haven't had time to become dialects yet.
2023-04-21 13:39:57 -0400 < wasamasa> clojure did though
2023-04-21 13:40:10 -0400 < wasamasa> so many knock-offs that are incoherent variants of it
2023-04-21 13:40:10 -0400 < Zipheir> Are there Clojure dialects?
2023-04-21 13:40:13 -0400 < wasamasa> yes
2023-04-21 13:40:27 -0400 < wasamasa> hy, janet and so on
2023-04-21 13:40:29 -0400 < mdhughes> Clojurescript's as close to original as JS substrate allows, I thought.
2023-04-21 13:40:30 -0400 < DeeEff> Clojure, ClojureScript, Clojure on CLR, etc
2023-04-21 13:40:33 -0400 < Zipheir> Wow.
2023-04-21 13:40:54 -0400 < wasamasa> fennel is the best one of the bunch
2023-04-21 13:40:58 -0400 < mdhughes> But it might be in the process of going that way.
2023-04-21 13:41:00 -0400 < wasamasa> because it's not totally incoherent
2023-04-21 13:41:16 -0400 < wasamasa> but I don't see myself learning lua
2023-04-21 13:41:36 -0400 < mdhughes> I have learned Lua, and it *sucks*. But it sucks in the way useful languages often do.
2023-04-21 13:42:26 -0400 < Zipheir> Lua strikes me as an odd cross between Scheme, AWK, and BASIC.
2023-04-21 13:42:29 -0400 < mdhughes> There's your nice languages which are logically perfect. Then there's garbage thrown together like PHP. And Lua's about 0.75 PHPs.
2023-04-21 13:42:37 -0400 < wasamasa> what about JS
2023-04-21 13:42:51 -0400 < mdhughes> JS has Typescript and some others.
2023-04-21 13:42:58 -0400 < Zipheir> JS is already a cross between Scheme and Basic. :)
2023-04-21 13:43:00 -0400 < wasamasa> I mean, regarding the 0.75 PHPs statement
2023-04-21 13:43:08 -0400 < mdhughes> 0.5 PHPs?
2023-04-21 13:43:19 -0400 < wasamasa> you think JS is less stupid than lua?
2023-04-21 13:43:23 -0400 < mdhughes> It's a really shitty syntax, and some decisions were dumb. But there's a real Self interpreter under that!
2023-04-21 13:43:59 -0400 < mdhughes> You can do serious work in JS. It's just uglier than anything else. But at the big picture level, it's kind of amazing.
2023-04-21 13:44:20 -0400 < wasamasa> :/
2023-04-21 13:46:24 -0400 < msavoritias> The thing is js mattered little to what http web has become. It could have been any other language and we would have had the same result
2023-04-21 13:46:39 -0400 < msavoritias> As long as its dynamic and gc that is
2023-04-21 13:47:09 -0400 < Zipheir> That's probably true.
2023-04-21 13:47:18 -0400 < wasamasa> I'm just surprised about the levels of derision something like python or ruby gets on #scheme
2023-04-21 13:47:27 -0400 < mdhughes> I don't think so. There's not a lot of other languages that were that error-tolerant, that easy to build big structures in. JSON is a huge win that no other language really could've pulled off.
2023-04-21 13:47:37 -0400 < wasamasa> in terms of footguns, python > ruby >>> anything else > JS > PHP
2023-04-21 13:47:56 -0400 < mdhughes> Python's contemptible for performance reasons. Ruby's even slower *and* easier to hurt yourself with.
2023-04-21 13:48:46 -0400 < mdhughes> JS went from only a little faster than Python, to nearly C speed now. Python *can't* make those changes without another major language revision.
2023-04-21 13:49:01 -0400 < wasamasa> of course, we all know that in terms of lack of footguns, scheme reigns supreme
2023-04-21 13:49:18 -0400 < gwatt> mdhughes: I think that's not really true. S-expressions could have easily replaced JSON, and the error tolerance is easy too. It's an exception handler at the event loop
2023-04-21 13:49:19 -0400 < Zipheir> I don't think any kind of language contempt is worth it. I used to make lots of snarky comments about Java, and I regret not learning more instead.
2023-04-21 13:49:29 -0400 < mdhughes> I assure you I can blow up lots of things in Scheme.
2023-04-21 13:50:08 -0400 < Zipheir> If you don't like the language, implement one you do like on top.
2023-04-21 13:50:17 -0400 < mdhughes> Contempt doesn't mean you shouldn't learn & use it. I've shipped prod code in PHP, Python, Java, JS.
2023-04-21 13:50:32 -0400 < gwatt> I think the error tolerance you're talking about is more related to just running any arbitrary code in the browser.
2023-04-21 13:50:41 -0400 < mdhughes> Not always by choice, just what I was paid for or was available (PHP, ugh).
2023-04-21 13:51:19 -0400 < mdhughes> JS's error tolerance is in both syntax, leaving off ; is mostly fine but not always, the silent error catching, undefined as a value, a whole bunch of tricks.
2023-04-21 13:51:36 -0400 < mdhughes> Which adds up to: A half-loaded page will still do something.
2023-04-21 13:51:50 -0400 < mdhughes> You load half a Scheme script, and you're screwed.
2023-04-21 13:52:34 -0400 < wasamasa> I really hate how the syntax for defining a global is not using any keywords at all
2023-04-21 13:52:44 -0400 < wasamasa> which may as well be assignment
2023-04-21 13:52:48 -0400 < mdhughes> sexprs are kind of limited and poorly specified compared to JSON. Which escapes are allowed? Is null a symbol or nil?
2023-04-21 13:53:11 -0400 < mdhughes> Well, nowadays you assign globals with const or let.
2023-04-21 13:53:17 -0400 < wasamasa> Zipheir: here's a list of clojure-likes: https://p.hagelb.org/new-lisps.html
2023-04-21 13:53:46 -0400 < wasamasa> Zipheir: well, almost entirely clojure-likes, some are significantly different
2023-04-21 13:53:56 -0400 < mdhughes> And with modules, you usually make a class and assign your globals as class statics, then export the class.
2023-04-21 13:54:59 -0400 < Zipheir> wasamasa: Thanks.
2023-04-21 13:55:17 -0400 < Zipheir> "Lisp-1s have won; almost nobody writes Lisp-2s anymore"  Interesting.
2023-04-21 13:55:22 -0400 < wasamasa> indeed
2023-04-21 13:55:30 -0400 < wasamasa> TXR is the only one I could come up with
2023-04-21 13:55:42 -0400 < wasamasa> but then, author happens to be biased because he designed Fennel
2023-04-21 13:56:17 -0400 < acdw> lisp+1
2023-04-21 13:57:16 -0400 < wasamasa> the author of the paste that is, not of TXR
2023-04-21 14:06:50 -0400 < jcowan> Python is not contemptible for performance reasons; the CPython implementation trades off speed for clarity.
2023-04-21 14:08:01 -0400 < jcowan> And loading half a Scheme script may very well still do something (as opposed to loading half a Scheme library)
2023-04-21 14:09:37 -0400 < jcowan> It's at least a question whether Lisp-1s are the victory of teh stupid.
2023-04-21 14:09:49 -0400 < mdhughes> The other Python impls like Jython are just as slow or worse, because they have to do the same dumb work for some internal features (mainly str, repr, sub, dict operators on every object).
2023-04-21 14:10:58 -0400 < mdhughes> Cython & Pypy do a little better at working around the incidental speed problems. Cython was usably fast on some problems, as long as you avoided all the dynamic features.
2023-04-21 14:11:46 -0400 < jcowan> That amounts to RPython, which is plenty fast.
2023-04-21 14:12:14 -0400 < jcowan> You're right that some features are inherently dynamic, like def being a statement, but rarely does anyone exploit that.
2023-04-21 14:13:18 -0400 < jcowan> The rule of elevator speed tells us that the slowest acceptable speed is that fastest speed ever achieved, but that  doesn't help much.  (Neither did Raoul Mitgong.)
2023-04-21 14:28:33 -0400 < mdhughes> I've never been on time either.
2023-04-21 14:31:55 -0400 < jcowan> "Early is on time; on time is late; late is fired."
2023-04-21 14:39:36 -0400 < gwatt> But if early is on time and on time is late, then early is late?!?
2023-04-21 14:47:19 -0400 < jcowan> no, it's a let* not a let
2023-04-21 14:48:59 -0400 < jcowan> or rather vice versa
2023-04-21 15:22:27 -0400 < Oxyd> Regarding new-lisps.html: “Everyone kinda realized that implicit quoting is the devil.” – what's implicit quoting referring to?
2023-04-21 15:22:54 -0400 < wasamasa> '(foo (bar baz)) rather than [:foo [:bar :baz]]
2023-04-21 15:23:05 -0400 < acdw> '(foo...) is explicit yes?
2023-04-21 15:23:13 -0400 < wasamasa> the inner list is implicit
2023-04-21 15:23:19 -0400 < acdw> ohhh
2023-04-21 15:23:22 -0400 < gwatt> I would have assume it meant turning () into '() or #(a b c) into '#(a b c)
2023-04-21 15:23:29 -0400 < acdw> well i mean it's /inside/ the quoted form
2023-04-21 15:23:40 -0400 < acdw> where is this new-lisps.html
2023-04-21 15:23:48 -0400 < wasamasa> yes, but a lot of people do not understand why they can't just quote symbols all the time
2023-04-21 15:23:50 -0400 < acdw> is it the thing technomancy posted earlyer?
2023-04-21 15:23:54 -0400 < wasamasa> yes
2023-04-21 15:23:56 -0400 < acdw> who are these people
2023-04-21 15:24:13 -0400 < wasamasa> elisp hackers mostly
2023-04-21 15:24:15 -0400 < Oxyd> But, but… That's just an explicitly quoted list.
2023-04-21 15:24:17 -0400 < acdw> like i wouldn't even call that implicit quoting
2023-04-21 15:24:20 -0400 < acdw> exactly
2023-04-21 15:24:44 -0400 < wasamasa> the problem comes up once in a while on #emacs, r/emacs or emacs.stackexchange
2023-04-21 15:24:46 -0400 < acdw> it works like any other form in lisp works... like you wouldn't say that in (+ 1 2 3) , 2 is "implictly added"
2023-04-21 15:25:05 -0400 < wasamasa> that didn't stop people from trying to quote numbers, lol
2023-04-21 15:25:25 -0400 < wasamasa> when your mental model is that a quote prevents you from evaluation errors, then it's easy to overuse it
2023-04-21 15:25:39 -0400 < acdw> well then they should just fix their mental model
2023-04-21 15:25:43 -0400 < acdw> smh my head
2023-04-21 15:25:48 -0400 < wasamasa> so they'll do '(foo '(bar baz)) and wonder why there's a (quote ...) inside
2023-04-21 15:26:06 -0400 < gwatt> in that quote prevents evaluation, it sure does prevent evaluation errors
2023-04-21 15:26:21 -0400 < Zipheir> If the inner list of (quote (a (b c))) isn't quoted, then 'quote' is not recursive. That's rather un-sexpy.
2023-04-21 15:26:33 -0400 < wasamasa> more precisely, they think ' creates a list or a symbol
2023-04-21 15:26:35 -0400 < wasamasa> which is wrong
2023-04-21 15:26:37 -0400 < acdw> what are you talking about, the whole thing is quoted
2023-04-21 15:26:56 -0400 < wasamasa> yes, but the jump from ' is for lists/symbols to the whole thing is quoted
2023-04-21 15:26:58 -0400 < acdw> why even have lisp syntax in the first place like that is the whole reason to have the syntax
2023-04-21 15:27:03 -0400 < wasamasa> no
2023-04-21 15:27:05 -0400 < wasamasa> it's a clever hack
2023-04-21 15:27:12 -0400 < gwatt> I think maybe the problem stems from the fact that the apostrophe is shorthand for (quote ...)
2023-04-21 15:27:22 -0400 < acdw> i mean the (explicit (delineation) between sub (expressions))
2023-04-21 15:27:25 -0400 < wasamasa> lisp is a bunch of clever hacks
2023-04-21 15:27:40 -0400 < Zipheir> I'm saying that I find it hard to believe that someone thinks non-recursive quote is sensible.
2023-04-21 15:27:58 -0400 < gwatt> If everyone had to spell out (quote (...)) for all forms that would be wildly more explicit and probably prevent misunderstandings?
2023-04-21 15:28:20 -0400 < Zipheir> Perhaps.
2023-04-21 15:28:22 -0400 < wasamasa> in clojure, quote is mostly used for macros
2023-04-21 15:28:25 -0400 < wasamasa> or rather, backquote is
2023-04-21 15:28:34 -0400 < gwatt> but yeah, it's also not something I've probably been tripped up by, beyond early learning experiences
2023-04-21 15:29:26 -0400 < gwatt> but on the other hand, maybe early learning experiences are worth considering when designing languages / libraries?
2023-04-21 15:29:34 -0400 < acdw> gwatt: also, sometimes nested quoting is actually something you want to do
2023-04-21 15:29:40 -0400 < Zipheir> It's funny that Phil Wadler complained about SICP's use of quotation, which he considered "an advanced topic". I think it's one of the most beautiful and fundamental ideas in CS.
2023-04-21 15:29:48 -0400 < acdw> i would say not if it makes the language less powerful
2023-04-21 15:29:57 -0400 < acdw> i agree Zipheir, it's the thing that makes lisp "work" for me
2023-04-21 15:29:59 -0400 < Oxyd> It's the whole “code is data” thing.
2023-04-21 15:30:25 -0400 < Oxyd> Nowhere outside Lisps is code data, so it's understandable that it'll be confusing at first.
2023-04-21 15:30:30 -0400 < wasamasa> what was the stance on #(...) syntax again, are the contents quoted or not?
2023-04-21 15:31:20 -0400 < Zipheir> Oxyd: I'd say code is data always and everywhere.
2023-04-21 15:31:34 -0400 < Zipheir> It's just a little easier to see in S-exp languages.
2023-04-21 15:31:40 -0400 < wasamasa> it seems they are
2023-04-21 15:32:41 -0400 < Zipheir> cf. http://calculist.org/blog/2012/04/17/homoiconicity-isnt-the-point/, an interesting read.
2023-04-21 15:34:57 -0400 < wasamasa> I do recounter some extremely pointless discussions on homoiconicity
2023-04-21 15:36:00 -0400 < Zipheir> I think quotation is fundamental because, as SICP says, "The evaluator, which determines the meaning of expressions in a programming language, is just another program."
2023-04-21 15:37:19 -0400 < Zipheir> Other languages dance around that strange loop, but you have to face it directly in Lisp.
2023-04-21 15:41:45 -0400 < acdw> #( ... ) is a literal vector, '#( ... ) is a quoted vector
2023-04-21 15:42:28 -0400 < acdw> i just want to say that calculist.org renders beautifully in eww
2023-04-21 15:45:01 -0400 < acdw> nice blog post
2023-04-21 16:04:51 -0400 < gwatt> Zipheir: I feel like that's a long-winded way of defining homoiconicity
2023-04-21 16:05:21 -0400 < mnieper> One has to be careful with "code = data" and Scheme.  With lexical scoping and hygienic macros it is not really a feature of the language.  For otherwise, `eval' would work in any scope and with the current lexical environment as an implicit second argument.
2023-04-21 16:05:33 -0400 < wasamasa> yup
2023-04-21 16:06:42 -0400 < mnieper> Scheme is, in some sense, similar to other languages, it just has a nicer syntax.
2023-04-21 16:08:33 -0400 < mnieper> People who are confused because of 3 vs '3 vs ''3 should take a look at 3-LISP.  It is very carefully designed so that there a not surprises and ' behaves very regularly.
2023-04-21 16:10:08 -0400 < jcowan> Or just 2-LISP; you don't need to understand reflection for that, just normalize-reduce as a replacement for eval-apply.
2023-04-21 16:10:20 -0400 < mnieper> Right.
2023-04-21 16:10:35 -0400 < mnieper> Is there a nice write-up just for 2-LISP?
2023-04-21 16:10:49 -0400 < jcowan> The appropriate chapter of Smith's thesis.
2023-04-21 16:11:08 -0400 < jcowan> (Note that 2-LISP is not LISP-2 is not LISP 2)
2023-04-21 16:11:57 -0400 < gwatt> I'm sure that's not going to confuse anyone
2023-04-21 16:13:07 -0400 < mnieper> The difference between LISP-1 and LISP-2 is not really fundamental.  2-LISP deviates more radically.
2023-04-21 16:32:25 -0400 < Zipheir> mnieper: "Scheme is, in some sense, similar to other languages, it just has a nicer syntax."  Exactly.
2023-04-21 16:33:12 -0400 < sham1> The most annoying part I find about Lisp-2s like CL or Elisp is that one needs a special form to call a function in a higher-order function. But yeah, aside from that the difference doesn't matter
2023-04-21 16:33:41 -0400 < sham1> Like that one needs FUNCALL and FUNCTION as special forms
2023-04-21 16:33:58 -0400 < sham1> It's a minor difference
2023-04-21 16:34:31 -0400 < acdw> but hey the details make all the difference
2023-04-21 16:34:32 -0400 < Zipheir> gwatt: I think that's because homoiconicity is more subtle than people sometimes think.
2023-04-21 16:35:15 -0400 < acdw> one thing i like in lisp-2 that you can't do in lisp-1 is, e.g., (dolist (fn '(frob foo bar)) (funcall fn data))
2023-04-21 16:36:15 -0400 < acdw> equivalent in scheme would be like, (dolist (fn (list frob foo bar)) ...)
2023-04-21 16:36:18 -0400 < acdw> assuming dolist of course
2023-04-21 16:36:32 -0400 < Zipheir> What is dolist (and fn?)
2023-04-21 16:37:19 -0400 < acdw> dolist is a macro in CL/elisp of the form (dolist (<var> <list>) <body>) which performs <body> on each item in <list> bound to <var>
2023-04-21 16:37:36 -0400 < acdw> so fn is varioulsy 'frob, 'foo, 'bar
2023-04-21 16:37:50 -0400 < Zipheir> Ah, I see.
2023-04-21 16:37:54 -0400 < acdw> (funcall 'frob data) works, but ('frob data) doesn't, nor does (apply 'frob data)
2023-04-21 16:38:00 -0400 < acdw> it's pretty minor all things considered
2023-04-21 16:38:09 -0400 < Zipheir> I suppose you'd have to pull out 'eval' for that in Scheme.
2023-04-21 16:39:48 -0400 < acdw> yeah i think so ... i asked a little while ago and the consensus was that's not a great idea
2023-04-21 16:40:18 -0400 < acdw> like i think it's /fine/, but really for both applications a list of actual function objects is probably better
2023-04-21 16:40:42 -0400 < Zipheir> The usual way to get procedures from symbols is to use a dictionary of some sort.
2023-04-21 16:40:44 -0400 < mnieper> Not eval, but a your own environment (e.g. a hash table) where you map symbols to your procedures.
2023-04-21 16:40:51 -0400 < Zipheir> Like so.
2023-04-21 16:40:57 -0400 < mnieper> Zipheir: Lol.
2023-04-21 16:41:03 -0400 < acdw> oh yeah that's what was said before
2023-04-21 16:41:10 -0400 < acdw> sorry i forgot
2023-04-21 16:41:32 -0400 < acdw> is it true that for structures of less than like, thousands of items an alist is about as good as a hash table? or am i way off
2023-04-21 16:42:15 -0400 < Zipheir> I like mnieper's way of putting better than mine. It's very much an environment.
2023-04-21 16:42:20 -0400 < mnieper> I think the main advantage of a Lisp-2 is that you need half as many symbols.
2023-04-21 16:42:23 -0400 < mnieper> You can name your lists list and still call list.
2023-04-21 16:42:23 -0400 < mnieper> acdw: Do the benchmark.
2023-04-21 16:42:31 -0400 < Zipheir> acdw: I would be surprised if that were true.
2023-04-21 16:43:16 -0400 < acdw> oh lol
2023-04-21 16:43:25 -0400 < Zipheir> acdw: My completely bogus rule of thumb is to only use alists when I don't expect more than 10 elements (or when I'm writing a program for one-off personal use).
2023-04-21 16:43:28 -0400 < acdw> i honestly don't even know how i'd start doing a benchmark for that lol
2023-04-21 16:43:32 -0400 < acdw> huh
2023-04-21 16:43:35 -0400 < acdw> TIL
2023-04-21 16:44:20 -0400 < Zipheir> Make a really big alist and do a few thousands 'assv' calls on it.
2023-04-21 16:44:24 -0400 < acdw> okay here's a question for r6rs users: i'm plannig on using akku. do you ever install any libraries system-wide so you don't have to, say, akku install thunderchez on every new project, or do you just install the thunderchez
2023-04-21 16:44:29 -0400 < acdw> Zipheir: oh smart
2023-04-21 16:45:42 -0400 < Zipheir> I haven't used Akku, unfortunately. I keep my Chez libraries in my home directory.
2023-04-21 16:45:48 -0400 < acdw> aha
2023-04-21 16:45:56 -0400 < Zipheir> i.e. ~/lib/chez or whatever.
2023-04-21 16:46:09 -0400 < acdw> yeah and point whatever env var to that dir
2023-04-21 16:46:23 -0400 < Zipheir> CHEZSCHEMELIBDIRS
2023-04-21 16:46:40 -0400 < Zipheir> (Not a very Lispy name, if you ask me.)
2023-04-21 16:46:59 -0400 < Zipheir> Hey Kent, why not CHEZ-SCHEME-LIBRARY-DIRECTORIES
2023-04-21 16:50:59 -0400 < acdw> for real
2023-04-21 16:51:10 -0400 < acdw> well the dashes aren't valid in shell. so it'd have to be _
2023-04-21 16:51:24 -0400 < acdw> maybe that's so offensive that they decided on nothing at all
2023-04-21 17:38:16 -0400 -!- daviid` is now known as daviid
2023-04-21 23:16:00 -0400 < lockywolf> I haven't actually known about srfi-97 before
2023-04-21 23:16:27 -0400 < lockywolf> Why don't all library srfis after 97 specify a library name?
2023-04-21 23:24:05 -0400 < mdhughes> I don't think clojure has quasiquote, so they think everything should be unquoted to insert values.
2023-04-21 23:24:17 -0400 < lockywolf> Zipheir: I don't really see Scheme really adhering to the "code is data" principle. Procedures are opaque, records are opaque, and there seems to be no first-class syntax
2023-04-21 23:27:41 -0400 < mdhughes> acdw: I just put thunderchez in my code dir (I have ~/Code, inside that is CodeChez, CodeJava, CodeC, etc.)
2023-04-21 23:28:28 -0400 < acdw> ooo nice
2023-04-21 23:49:25 -0400 < Zipheir> lockywolf: I wasn't specifically talking about Scheme. I meant the general computational idea that any program can also be treated as input to a program.
2023-04-21 23:49:51 -0400 < lockywolf> everything is just machine words
2023-04-21 23:50:18 -0400 < lockywolf> just as we all are just a bunch of quarks
2023-04-21 23:50:25 -0400 < Zipheir> Well...
2023-04-21 23:50:45 -0400 < Zipheir> I should have said that *the representation of any program* can be input.
2023-04-21 23:53:38 -0400 < Zipheir> lockywolf: But I agree that the opaqueness of Scheme objects makes it harder to see.
2023-04-21 23:56:05 -0400 < acdw> could you have a scheme that's more... transparent?
--- Day changed Sat Apr 22 2023
2023-04-22 00:01:52 -0400 < lockywolf> isn's common lisp more transparent?
2023-04-22 00:02:02 -0400 < lockywolf> except it's lisp-2
2023-04-22 00:03:59 -0400 < lockywolf> opaqueness of Scheme has both positive and negative sides
2023-04-22 00:04:38 -0400 < lockywolf> type disjointedness, as far as I understand, cannot be achieved without opaqueness
2023-04-22 00:05:03 -0400 < lockywolf> and many people consider it an important and useful thing
2023-04-22 00:05:22 -0400 < mdhughes> It's not entirely true, since Scheme has syntax that isn't just sexpr.
2023-04-22 00:05:29 -0400 < acdw> I need to learn so much more about programming language design
2023-04-22 00:05:39 -0400 < lockywolf> on the other hand, (chibi generic) doesn't use types for dispatch
2023-04-22 00:06:00 -0400 < lockywolf> it has a dynamic predicate-based dispatch
2023-04-22 00:32:28 -0400 < lockywolf> acdw: what for?
2023-04-22 00:33:55 -0400 < lockywolf> it's a rabbit hole that will not make you rich
2023-04-22 00:38:15 -0400 < acdw> so I understand y'all in here lol
2023-04-22 00:38:25 -0400 < acdw> also I like languages, human and computer
2023-04-22 00:44:08 -0400 < lockywolf> acdw: how old are you?
2023-04-22 00:44:41 -0400 < lockywolf> anyway, a lot of stuff in language design is easy, and mostly only requires you to learn the vocabulary
2023-04-22 00:45:05 -0400 < lockywolf> unfortunately, easy doesn't necessarily mean simple
2023-04-22 00:46:05 -0400 < acdw> 32
2023-04-22 00:46:09 -0400 < acdw> hahah
2023-04-22 00:55:44 -0400 < Zipheir> EoPL is a fun book by some eminent Schemers, if you're interested in programming languages. https://en.wikipedia.org/wiki/Essentials_of_Programming_Languages
2023-04-22 00:56:47 -0400 < Zipheir> I may have already recommended PLFA https://plfa.github.io/
2023-04-22 01:09:53 -0400 < acdw> oo
2023-04-22 01:56:24 -0400 -!- greaser|q is now known as GreaseMonkey
2023-04-22 01:59:59 -0400 -!- justache is now known as reddit-bot
2023-04-22 02:00:08 -0400 -!- reddit-bot is now known as justache
2023-04-22 07:29:51 -0400 < amirouche> hello here
2023-04-22 07:30:06 -0400 < sham1> Ah, general Kenobi.
2023-04-22 08:44:17 -0400 < mnieper`> Question to the regexp/emacs experts: What font-lock entry would you suggest for `define-values'?
2023-04-22 08:45:27 -0400 < mnieper`> The way scheme.el handles `define', only the first identifier after the parenthesis is colored.
2023-04-22 08:45:50 -0400 < mnieper`> But (define-values (foo bar) (values 1 2)) needs both foo and bar to be colored.
2023-04-22 08:49:11 -0400 < wasamasa> or neither
2023-04-22 08:52:01 -0400 < mnieper`> Coloring the defined identifiers is a nice feature of scheme.el's `define'.
2023-04-22 08:56:54 -0400 < wklew> it should probably highlight the whole list (foo bar) as one, so it's consistent with (define-values lst (values 1 2))
2023-04-22 08:57:40 -0400 < wklew> (or not at all)
2023-04-22 08:58:35 -0400 < wklew> although maybe you're right, it's good to know which names are bound
2023-04-22 11:59:50 -0400 < johnjaye> i'm missing some context. is there something wrong with the default font highlighting in scheme mode?
2023-04-22 12:01:01 -0400 < johnjaye> it looks to me browsing casually it makes 'define' magenta and the function name blue. making the params a 3rd color would probably be too visually cluttered i'm guessing
2023-04-22 12:16:03 -0400 < wasamasa> yeah, I thought the same
2023-04-22 12:18:27 -0400 < johnjaye> same thing is done in elisp mode by the way
2023-04-22 12:20:41 -0400 < mnieper``> No, I didn't ask for coloring the arguments, that is the identifiers following the "function" in define.
2023-04-22 12:20:52 -0400 < mnieper``> But define-values is differently.
2023-04-22 12:21:22 -0400 < mnieper``> Whatever is in the first pair of parentheses after (define-syntax should be colored blue (in the default color scheme).
2023-04-22 12:21:51 -0400 < mnieper``> Or, if there are no parentheses just the identifier following define-syntax.
2023-04-22 12:22:57 -0400 < mnieper``> What I need is some regexp expression that handles <identifier><whitespace>*<identifier>...<identifier> and only colors the <identifier> parts in it.
2023-04-22 12:42:44 -0400 < johnjaye> mnieper``: meaning, in define-values expression?
2023-04-22 12:44:13 -0400 < mnieper``> Like in (define-values (<id1> <id2> . <id3>) blabla)
2023-04-22 12:44:25 -0400 < mnieper``> Or (define-values <id> blabla)
2023-04-22 12:44:58 -0400 < mnieper``> Coloring the <ids> would be consistent with how `define' is handled.
2023-04-22 12:49:50 -0400 < johnjaye> ok i think i have something working
2023-04-22 12:49:55 -0400 < johnjaye> execute this and restart scheme mode
2023-04-22 12:49:57 -0400 < johnjaye> https://dpaste.com/AYFYB9ZEE
2023-04-22 12:50:06 -0400 < johnjaye> it should make them a bright red color
2023-04-22 12:59:49 -0400 < mnieper``> Thank you!
2023-04-22 13:00:53 -0400 < mnieper``> It does color the dot in (<id> . <id>), though.  And, technically, the whitespace, which could matter if some color scheme used underlining of identifiers.
2023-04-22 13:01:28 -0400 < johnjaye> ah i'm in the terminal so I didn't consider such matters.
2023-04-22 13:01:40 -0400 < johnjaye> anyway the relevant manual page is here if you have any questions: https://www.gnu.org/software/emacs/manual/html_node/elisp/Customizing-Keywords.html
2023-04-22 13:01:49 -0400 < johnjaye> you can tweak the regexp for that if you prefer
2023-04-22 13:28:06 -0400 < cow_2001> cargo culting ~_~
2023-04-22 14:06:21 -0400 < Zipheir> cow_2001: As long as the planes land...
2023-04-22 14:07:20 -0400 < Zipheir> My experience with scheme-mode involved spending more time telling Emacs what to highlight than time programming.
2023-04-22 14:10:03 -0400 < johnjaye> Zipheir: maybe this deserves its own topic on the chicken wiki? i could maybe slap something together
2023-04-22 14:10:13 -0400 < johnjaye> what is your major dissatisfaction?
2023-04-22 14:13:44 -0400 < johnjaye> also does geiser do anything differently?
2023-04-22 14:15:46 -0400 < Zipheir> johnjaye: It's not worth complaining about. I found it hard to get Emacs to highlight and correctly indent macros, especially. I don't have much use for syntax highlighting, though.
2023-04-22 14:16:40 -0400 < Zipheir> It makes very little sense in Scheme, I think. Some editors highlight anything built-in, for example, the utility of which I don't understand.
2023-04-22 14:18:22 -0400 < Zipheir> Use what you like, of course.
2023-04-22 14:25:26 -0400 < jcowan> Zipheir: I think it started with Algol 60, which for a long time was the main language for publishing algorithms in Communications of the ACM.  All keywords were printed in bold, although at the time it didn't matter to the computer.
2023-04-22 14:26:57 -0400 < jcowan> In principle you could use if, then, etc. as identifiers as well as keywords, and a variety of conventions were developed like putting keywords in ALL CAPS (case insensitive language), preceding them with a dot, or putting them in single quotes.
2023-04-22 14:27:34 -0400 < jcowan> So people got used to the idea that the structural parts of the language should be displayed with EMPHASIS, and the actually menaingful identifiers should not.  Which typographically is completely bogus.
2023-04-22 14:28:49 -0400 < Zipheir> jcowan: Yes, exactly.
2023-04-22 14:29:11 -0400 < Zipheir> jcowan: And the "structural parts" of each Scheme program may be different.
2023-04-22 14:29:19 -0400 < jcowan> Even worse, yes.'
2023-04-22 14:30:05 -0400 < jcowan> There was, fortunately, a fourth alternative, which was to say that if and IF always meant the keyword, and the identifier if was simply unusable, as is the case in C etc.
2023-04-22 14:30:58 -0400 < jcowan> In Cobol there are something like 300 reserved words, and the list grows every time there's a new standard, so some shops are fanatical that all identifiers must be informally namespaced with a prefix.
2023-04-22 14:31:10 -0400 < Zipheir> Wow.
2023-04-22 14:32:32 -0400 < Zipheir> I think someone likened conventional programming-language highlighting to "making all the verbs blue, the nouns red, the adjectives green" etc. in English prose.
2023-04-22 14:32:41 -0400 < jcowan> PL/I was cleverly designed so that the parser can figure out pretty easily what is and what is not a keyword, so they can all be used as identifiers.  Famously, "if if = then then then = else else else = if;" is a perfectly valid and parsable statement.
2023-04-22 14:33:33 -0400 < jcowan> A mild disadvantage is that (as in Fortran), top-level calls to subroutines (aka procedures returning nothing) have to be preceded by CALL.
2023-04-22 14:34:08 -0400 < Zipheir> Ah, yes.
2023-04-22 14:34:38 -0400 < jcowan> Note also the parser knows which =s are equality (the first one)  and which are assignment (the second and third)
2023-04-22 14:35:56 -0400 < Zipheir> Hopefully the human parser knows, too.
2023-04-22 14:36:27 -0400 < jcowan> Basic does the same thing, and people don't seem to get confused
2023-04-22 14:37:17 -0400 < Zipheir> I think the ALGOL family got it right with :=.
2023-04-22 14:37:21 -0400 < jcowan> The whole thing used to require ad hoc parsing, but it is fairly amenable to a PEG parser nowadays.  The only bad part there is that there are a lot of places in the language, notably declarations, where there is optional order: a declaration, for example, is DECLARE X and then you get to specify any of about 20 clauses specifying X's properties in any order desired, but you can't duplicate them.
2023-04-22 14:37:54 -0400 < jcowan> Well, for some values of "right".  I happen to think (with Scheme) that it's a mistake for assignments to be expressions.
2023-04-22 14:38:30 -0400 < jcowan> I mean, (set! x ...) is technically an expression, but you know nothing about its value (or in R6RS about its values)
2023-04-22 14:38:34 -0400 < Zipheir> Absolutely. I just think := was the right choice of token.
2023-04-22 14:39:39 -0400 < jcowan> Oh, fair enough. In my language Harlan, which uses the STEELMAN requirements to go somewhere almost, but not quite, completely unlike Ada, it's a requirement that such things be clear, so I go with = and == because that's what's clear to programmers today.
2023-04-22 14:41:38 -0400 < jcowan> So back to PL/I declarations, you either have to write syntax rules for each of those 20! possible orders (somewhat simplified because some are incompatible), or you give up on trying to filter out duplicates in the parser and do it at a higher level.
2023-04-22 14:42:24 -0400 < jcowan> oh, worse than 20! because of course they don't all have to be present
2023-04-22 14:56:00 -0400 < mnieper``> If set! were no expression, Scheme would be more complicated because another category of forms (e.g. "statements") would be needed.
2023-04-22 14:56:11 -0400 < mnieper``> Or do I misunderstand what you mean?
2023-04-22 15:12:56 -0400 < johnjaye> Zipheir: the main utility of syntax highlighting in my experience is simply verifying that you typed the builtin correctly. and secondarily for skimming code quickly
2023-04-22 15:13:35 -0400 < cow_2001> Zipheir: siiiiiiggghhhhhh... and the plane doesn't land
2023-04-22 15:15:13 -0400 < johnjaye> so in a way yes only highlighting keywords and not identifiers is kind of sillly
2023-04-22 15:15:51 -0400 < johnjaye> i actually have a bit of elisp in my init.el file which specifically handles this by looking for defined elisp variables and symbols and highlighting them in special font
2023-04-22 15:33:37 -0400 < sham1> := is the best thing. I'd personally also accept <-
2023-04-22 15:35:48 -0400 < wasamasa> ChucK uses <-
2023-04-22 15:36:29 -0400 < wasamasa> actually, no, it uses =>
2023-04-22 15:36:40 -0400 < wasamasa> so you assign the other way around :D
2023-04-22 15:37:19 -0400 < wasamasa> 1 => x;
2023-04-22 15:49:47 -0400 < johnjaye> is there some huge controversy over the "walrus" and the -> and => notations?
2023-04-22 15:50:03 -0400 < johnjaye> i mean. if you're literally making new editions of c++ every few years why not change == to :=
2023-04-22 15:50:06 -0400 < johnjaye> or = i guess
2023-04-22 16:07:02 -0400 < Zipheir> Assignment is the way you do everything in C-like languages. It'd be a huge change.
2023-04-22 16:07:44 -0400 < Zipheir> Go made it.
2023-04-22 18:26:58 -0400 < mdhughes> assignment: =!  comparison: =?
2023-04-22 18:30:17 -0400 < mdhughes> I like how in some BASICs you can use LET to assign keywords. In Atari BASIC: LET IF=1:?IF  prints 1. Remove the LET and it's an error.
2023-04-22 18:33:36 -0400 < Zipheir> Hmm, no LET block. What was the first language with LET ... IN ...?
2023-04-22 18:34:20 -0400 < Zipheir> Obviously some Lisps had the equivalent, but I don't know who started it.
2023-04-22 18:58:41 -0400 < mdhughes> ALGOL, probably, tho you had to do it in nested procedures.
2023-04-22 20:51:06 -0400 < whereiseveryone> what's a good way to explain allow-other-keys to a beginner?
2023-04-22 20:54:35 -0400 < Zipheir> What is allow-other-keys?
2023-04-22 21:01:07 -0400 < edgar-rft> excellent explanation :-)
2023-04-22 21:05:01 -0400 < Zipheir> "Not in any RnRS"
2023-04-22 21:05:34 -0400 < Zipheir> Oh, it's in CLHS.
2023-04-22 21:05:51 -0400 < edgar-rft> yes, It's a Common Lisp thing
2023-04-22 21:07:33 -0400 < Zipheir> whereiseveryone: "It allows callers to pass meaningless keywords", I guess.
2023-04-22 21:09:09 -0400 < whereiseveryone> It's also a Guile Scheme thing: https://www.gnu.org/software/guile/manual/html_node/lambda_002a-and-define_002a.html
2023-04-22 21:09:27 -0400 < whereiseveryone> > "It allows callers to pass meaningless keywords"
2023-04-22 21:09:34 -0400 < whereiseveryone> But then why would I want to even use it?
2023-04-22 21:09:38 -0400 < edgar-rft> &allow-other-.keys is normally used to allow the user to call a function with additional keyword arguments that are not specified in the function definition, without causing compiler errors
2023-04-22 21:10:06 -0400 < whereiseveryone> > with additional keyword arguments that are not specified in the function definition
2023-04-22 21:10:10 -0400 < whereiseveryone> I understand that much
2023-04-22 21:10:22 -0400 < whereiseveryone> but, I want to know when I will actually need to do that
2023-04-22 21:10:37 -0400 < whereiseveryone> but thanks for the explanations so far
2023-04-22 21:10:38 -0400 < Zipheir> I don't understand it, either.
2023-04-22 21:10:52 -0400 < Zipheir> It seems like those should be errors.
2023-04-22 21:11:03 -0400 < whereiseveryone> Zipheir: do you ever use something that is equivalent to allow-other-keys in your scheme of choice?
2023-04-22 21:11:31 -0400 < Zipheir> whereiseveryone: I can't remember the last time I wrote procedures with keyword arguments.
2023-04-22 21:11:46 -0400 < edgar-rft> you need it when you have your own keyword argument parser inside the function body, the only other way would be using a &rest argument and then parse the list it produces
2023-04-22 21:11:52 -0400 < whereiseveryone> What do you use instead of keyword arguments? Zipheir
2023-04-22 21:12:20 -0400 < Zipheir> Since keywords aren't standardized and keyword symbols are basically unreliable, I don't think they're very usable in current Scheme
2023-04-22 21:12:54 -0400 < Zipheir> edgar-rft: Interesting.
2023-04-22 21:13:17 -0400 < whereiseveryone> The place where I always see them used is for example, here: https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/python-xyz.scm?id=db4ddd04542c9632648f7aea103e421a3c94fb21#n341
2023-04-22 21:13:18 -0400 < rudybot> https://teensy.info/ERebHBgV8W
2023-04-22 21:14:23 -0400 < whereiseveryone> Why is the url shortener bot a good thing? Some people aren't able to open long urls?
2023-04-22 21:15:04 -0400 < Zipheir> Well, that's clear as mud to me.
2023-04-22 21:15:08 -0400 < whereiseveryone> I haven't read the memo yet on that so any education here is much appreciated
2023-04-22 21:15:26 -0400 < Zipheir> I appreciate rudybot's shortened URLs when the original gets wrapped in my terminal.
2023-04-22 21:15:28 -0400 < whereiseveryone> Zipheir: the link I shared is clear as mud?
2023-04-22 21:15:36 -0400 < Zipheir> The code is.
2023-04-22 21:15:59 -0400 < whereiseveryone> ok, can you explain what #:allow-other-keys is allowing in that context?
2023-04-22 21:16:14 -0400 < Zipheir> I see that it's using #:allow-other-keys, but the file is so complex that I don't know why.
2023-04-22 21:16:19 -0400 < whereiseveryone> what particular keyword or thing it is allowing to pass, that is
2023-04-22 21:16:32 -0400 < whereiseveryone> the latter is what I'm trying to understand :)
2023-04-22 21:16:48 -0400 < whereiseveryone> It has puzzeled me for a while
2023-04-22 21:17:08 -0400 < whereiseveryone> I think it is heavily abstracted in the call chain/call stack
2023-04-22 21:17:19 -0400 < whereiseveryone> so might be a rabbit hole into guix "internals"
2023-04-22 21:18:34 -0400 < Zipheir> What I don't understand is why #:allow-other-keys is used without a rest argument.
2023-04-22 21:18:50 -0400 < Zipheir> The examples here only show it used with such an argument. https://www.gnu.org/software/guile/manual/html_node/lambda_002a-and-define_002a.html
2023-04-22 21:19:24 -0400 < whereiseveryone> It's a GNU mystery
2023-04-22 21:19:25 -0400 < Zipheir> Are other keywords silently ignored?
2023-04-22 21:19:38 -0400 < Zipheir> Easy enough to check.
2023-04-22 21:20:51 -0400 < Zipheir> Yes, that's what happens.
2023-04-22 21:21:00 -0400 < whereiseveryone> Zipheir: I think it is related to this comment: https://github.com/guix-mirror/guix/blob/master/guix/build/gnu-build-system.scm#L909
2023-04-22 21:21:17 -0400 < whereiseveryone> where's rudybot when you need em'
2023-04-22 21:21:37 -0400 < Zipheir> I defined bar = (lambda* (#:key foo #:allow-other-keys) (+ foo 1)). After that, (bar #:foo 10 #:frobnitz) => 11 with no warnings about extra arguments.
2023-04-22 21:21:48 -0400 < whereiseveryone> ;; The trick is to #:allow-other-keys everywhere, so that each procedure in
2023-04-22 21:21:55 -0400 < whereiseveryone> ;; PHASES can pick the keyword arguments it's interested in.
2023-04-22 21:22:07 -0400 < Zipheir> I suppose that makes some sense.
2023-04-22 21:22:28 -0400 < whereiseveryone> phases is another guix implementation jargon for the steps in building a package
2023-04-22 21:22:33 -0400 < Zipheir> But it's very, very bad if two of those procedures use the same keywords!
2023-04-22 21:22:46 -0400 < whereiseveryone> i think they never do iirc
2023-04-22 21:22:59 -0400 < whereiseveryone> or never are supposed to
2023-04-22 21:23:01 -0400 < Zipheir> It would be like the systemd/Linux command line "debug" bug.
--- Day changed Sun Apr 23 2023
2023-04-23 02:35:42 -0400 < mnieper> The discussion on keywords and procedures better not using the same reinforces my doubts that keywords that are identified just by symbolic name is a good approach.
2023-04-23 02:40:43 -0400 < mnieper> Keywords that basically work like "unhygienic" symbols (and may be passed down) are like (SRFI 39) parameter objects that are not identified by lexical scoping (as usual in Scheme) but by name.
2023-04-23 02:47:30 -0400 < Zipheir> That's a useful way to put it.
2023-04-23 02:56:00 -0400 < wasamasa> who in here questioned people not understanding quote?
2023-04-23 02:56:05 -0400 < wasamasa> acdw: I think it was you
2023-04-23 02:56:18 -0400 < wasamasa> acdw: so here have a demonstration: https://github.com/emacs-circe/circe/issues/368#issuecomment-753627292
2023-04-23 04:53:50 -0400 < mdhughes> quasiquote is harder to understand than regular quote, esp. if you're not lispin' every day. People having problems with double quotes are even noobier than that, tho.
2023-04-23 04:54:33 -0400 < mdhughes> Take a remedial course of The Little Lisper.
2023-04-23 04:58:02 -0400 < mnieper> When people come from a different language background, the best explanation for quasiquote is possibly that it basically works like format strings or template strings.
2023-04-23 05:03:50 -0400 < mdhughes> But most template strings don't let you put live code in there, just variables.
2023-04-23 05:04:46 -0400 < mnieper> Think of "blabla ${1} blublu ${2]
2023-04-23 05:05:10 -0400 < mnieper> Think of "blabla ${1} blublu ${2} ...".(val1, val2)
2023-04-23 05:05:20 -0400 < mnieper> in some hypothetical programming language.
2023-04-23 05:05:36 -0400 < mnieper> So to be precise: template string + instantiation.
2023-04-23 05:05:50 -0400 < mnieper> The mechanism is exactly the same as with quasiquote.
2023-04-23 06:35:21 -0400 < edgar-rft> double quote equals (quote (quote <string>)) :-)
2023-04-23 08:59:03 -0400 < acdw> wasamasa: I was questioning how people don't understand that a quote quotes the whole form after it so you don't have to quote inside forms, yeah
2023-04-23 08:59:12 -0400  * acdw looks at circe code
2023-04-23 09:03:32 -0400 < acdw> i didnt mean to imply I think quoting is easy, it can be complex! I don't really get how one can think that in '(foo (bar baz)), the quote doesn't apply to the inner form
2023-04-23 09:03:43 -0400 < wasamasa> "think"
2023-04-23 09:04:03 -0400 < wasamasa> that's where the mistake is
2023-04-23 09:04:04 -0400 < acdw> I mean after learning what quote is
2023-04-23 09:04:11 -0400 < wasamasa> "learning"
2023-04-23 09:04:15 -0400 < mnieper> acdw: If ' is read as "list", then it makes sense.
2023-04-23 09:04:16 -0400 < acdw> lolol
2023-04-23 09:04:22 -0400 < acdw> I mean that is the problem
2023-04-23 09:04:23 -0400 < wasamasa> I mean, this is about emacs configuration
2023-04-23 09:04:35 -0400 < wasamasa> do you expect everyone who wants to configure emacs learns lisp first?
2023-04-23 09:04:36 -0400 < acdw> mnieper: well it shouldn't be read as list lol
2023-04-23 09:04:44 -0400 < acdw> lmaooooo
2023-04-23 09:05:05 -0400 < acdw> I guess I might be strange for learning programming languages by configuring thinfs
2023-04-23 09:05:08 -0400 < mnieper> I just wanted to say that the other interpretation is not unsound.
2023-04-23 09:05:27 -0400 < mnieper> So if people don't know precisely about quote, it is not the worst guess.
2023-04-23 09:05:56 -0400 < mnieper> Which lets us come back to the issue: one needs to learn a bit about the configuration language.
2023-04-23 09:07:36 -0400 < wasamasa> it's already effort enough to get the syntax right
2023-04-23 09:07:45 -0400 < wasamasa> quote to produce the list, then various strings and keywords
2023-04-23 09:07:55 -0400 < wasamasa> and then, the function invocation doesn't work for some mysterious reason
2023-04-23 09:43:57 -0400 < amirouche> Exceptional suite of article started at https://wingolog.org/
2023-04-23 09:44:01 -0400 < amirouche> check out the first two posts
2023-04-23 09:44:42 -0400 < amirouche> about frontend tools from the point of view of wingo, GNU Guile maintainer
2023-04-23 09:47:52 -0400 < acdw> maybe this is where schemes inability to run a function from a symbol works better: you cant funcall a quoted function, you can only apply a procedure object
2023-04-23 09:48:53 -0400 < wasamasa> so you'd think, but in practice people are even more surprised they have to unquote lambdas
2023-04-23 09:49:14 -0400 < wasamasa> they think elegance means having less code to type rather than more visual noise
2023-04-23 09:49:47 -0400 < amirouche> what about quote disabled evaluation, except self-evaluation?
2023-04-23 09:50:12 -0400 < amirouche> what about describing quote as a device that _disable evaluation, except self-evaluation_
2023-04-23 09:50:47 -0400 < amirouche> and quasiquote works the same except it is possible to re-enable evaluation inside it
2023-04-23 09:52:02 -0400 < mnieper> The problem with all this is that it somehow sounds that quote and quasiquote are doing something magic (and need to be tightly integrated into the evaluator).
2023-04-23 09:52:30 -0400 < mnieper> Quasiquote is just a macro building code consisting of some conses, appends and lists.
2023-04-23 09:52:43 -0400 < amirouche> yes, I was going to try to say that :)
2023-04-23 09:53:46 -0400 < amirouche> in fact, they are integrated into the evaluator, the problem is the evaluator is split into compile time, and runtime..
2023-04-23 09:54:13 -0400 < amirouche> It is only a problem because one needs to explain that
2023-04-23 09:54:17 -0400 < wasamasa> yes
2023-04-23 09:54:21 -0400 < wasamasa> it's an elegant hack
2023-04-23 09:54:28 -0400 < wasamasa> but a hack nonetheless
2023-04-23 09:55:35 -0400 < wasamasa> in clojure this is skipped (except in macros) and instead people build their DSLs with vectors and keywords (and unnest things that are meant to be unspliced)
2023-04-23 10:37:21 -0400 < acdw> why doesn't scheme have intersperse built in
2023-04-23 11:04:27 -0400 < wasamasa> the overall design philosophy is that if it doesn't need to be part of core, then it's not a part of core
2023-04-23 11:04:40 -0400 < wasamasa> I'd expect intersperse in srfi-1 though
2023-04-23 11:14:32 -0400 < acdw> it's not! i checked
2023-04-23 11:14:47 -0400 < acdw> i wrote it meself, i'm not sure if it's really .. like good, but it works well enough for me
2023-04-23 11:16:47 -0400 < wasamasa> that's expected with scheme
2023-04-23 11:16:53 -0400 < wasamasa> just write the damn helper function yourself
2023-04-23 11:18:44 -0400 < acdw> hahahah
2023-04-23 11:36:40 -0400 < wasamasa> we're not in npm land
2023-04-23 11:40:33 -0400 < acdw> akku install left-pad
2023-04-23 13:20:18 -0400 < jcowan> Consider two procedures that take allow-other-keys, a caller and a callee.  The caller can take arguments that are applicable to the callee without having to know what they are, and pass them along using a rest argument.
2023-04-23 13:21:29 -0400 < jcowan> The callee, on the other hand, can specify allow-other-keys so it can accept the caller's arguments (which it ignores), so it doesn't need a rest argument.
2023-04-23 13:22:43 -0400 < jcowan> In CL there is both a lambda keyword &allow-other-keys and a keyword argument :allow-other-keys, which when its value is true, means that this particular call accepts other keywords.
2023-04-23 13:24:27 -0400 < jcowan> Note that :allow-other-keys doesn't have to be declared: it is always permitted
2023-04-23 13:27:24 -0400 < jcowan> See https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node64.html and search on the page for "As an example of"
2023-04-23 13:33:43 -0400 < jcowan> whereiseveryone: Zipheir: ^^
2023-04-23 14:18:50 -0400 < Zipheir> jcowan: Thanks. That makes sense now.
--- Log closed Sun Apr 23 14:25:06 2023
--- Log opened Sun Apr 23 14:26:03 2023
2023-04-23 14:26:03 -0400 -!- Irssi: #scheme: Total of 201 nicks [0 ops, 0 halfops, 0 voices, 201 normal]
2023-04-23 14:26:04 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-04-23 14:32:37 -0400 < whereiseveryone> jcowan: damn, that is the best explanation I have read. I am 100% onboard now with #:allow-other-keys
2023-04-23 14:33:06 -0400 < whereiseveryone> I wish someone could have explained it to me like that 2 years ago
2023-04-23 14:33:39 -0400 < wasamasa> on a CL channel, yes, that might have happened
2023-04-23 14:33:50 -0400 < whereiseveryone> I have tried asking on a CL channel before
2023-04-23 14:33:58 -0400 < whereiseveryone> and they didn't explain it like that
2023-04-23 14:34:03 -0400 < whereiseveryone> I was still confused
2023-04-23 14:34:13 -0400 < wasamasa> yes, they enjoy their language lawyering and other questionable tactics
2023-04-23 14:35:52 -0400 < wasamasa> I've been told #c is similarly terrible
2023-04-23 14:35:53 -0400 < whereiseveryone> They had a GNU style in their irc prose
2023-04-23 14:36:32 -0400 < whereiseveryone> I mean this is the internet. just talk to me for realz and explain it to me like cs.cmu.edu did
2023-04-23 14:37:34 -0400 < whereiseveryone> I have truly had an epiphanous moment just now on irc thanks to jcowan's link
2023-04-23 14:37:56 -0400 < whereiseveryone> I have hit a personal milestone of finally understanding allow-other-keys well enough to explain it to my cat
2023-04-23 14:38:07 -0400 < Zipheir> There is still something fishy and unhygienic to me about allow-other-keys.
2023-04-23 14:38:36 -0400 < whereiseveryone> Zipheir: on a practical level though the explanation is good enough to finally understand how to use it in a practical setting
2023-04-23 14:38:46 -0400 < wasamasa> it's a practical solution to an otherwise intractable problem: how do you deal with undeclared keys in a procedure accepting keyword arguments?
2023-04-23 14:38:56 -0400 < Zipheir> Yes. I'm just thinking in general language design terms.
2023-04-23 14:39:06 -0400 < wasamasa> by default they're considered an error, but you can either declare them to not be one or specify them to not be one on use
2023-04-23 14:39:14 -0400 < whereiseveryone> I guess it also didn't help that my encounter with allow-other-keys was always in the context of the same convoluted example in a guix package record that was highly abstracted
2023-04-23 14:40:04 -0400 < Zipheir> It would be better if unspecified keyword arguments were opaque to a procedure.
2023-04-23 14:40:21 -0400 < whereiseveryone> the callee of allow-other-keys was highly abstracted away from where that keyword argument is actually passed in, that is
2023-04-23 14:40:27 -0400 < Zipheir> So, e.g., your 'caller' could pass them to 'callee', but not inspect them.
2023-04-23 14:40:32 -0400 < whereiseveryone> in the guix example
2023-04-23 14:40:45 -0400 < whereiseveryone> the cs.cmu.edu example was the rosetta stone
2023-04-23 14:40:57 -0400 < whereiseveryone> for the complicated GNU design
2023-04-23 14:41:03 -0400 < Zipheir> Yes, the Guix example was very complicated.
2023-04-23 14:41:10 -0400 < whereiseveryone> Yup, extremely
2023-04-23 14:41:41 -0400 < whereiseveryone> But it is the bread and butter of how arguments other than the usual are passed in to the package record
2023-04-23 14:42:01 -0400 < whereiseveryone> in the context of how a build system fenangles a package record object
2023-04-23 14:42:13 -0400 < Zipheir> It's still sort of dirty.
2023-04-23 14:42:30 -0400 < whereiseveryone> gnu-build-system, haskell-build-system, python-build-system, etc
2023-04-23 14:42:45 -0400 < whereiseveryone> which are also records with more abstractions and hofs
2023-04-23 14:43:25 -0400 < Zipheir> Why not pass a build-system configuration structure instead?
2023-04-23 14:43:31 -0400 < wasamasa> what I'm surprised is that it's possible to override the behavior on function invocation, rather than in the definition of the function
2023-04-23 14:43:35 -0400 < whereiseveryone> allow-other-keys is such a simple concept
2023-04-23 14:43:40 -0400 < Zipheir> I don't think it is.
2023-04-23 14:43:44 -0400 < wasamasa> that seems like the error-prone part of it
2023-04-23 14:44:54 -0400 < whereiseveryone> And the Guile manual just sh😇ts on the reader in explaining it lucidly
2023-04-23 14:45:08 -0400 < wasamasa> I mean, it's written in a very GNU style
2023-04-23 14:45:15 -0400 < wasamasa> you need to go over it over and over again
2023-04-23 14:45:19 -0400 < whereiseveryone> like cs.cmu.edu did
2023-04-23 14:45:20 -0400 < Zipheir> Again, I think of that infamous systemd bug. The daemon was getting its startup arguments from the kernel command line, and one day the authors decided that it would be OK to have "debug" be a systemd argument. This caused serious problems when people tried to pass 'debug' to their kernels, instead.
2023-04-23 14:45:48 -0400 < wasamasa> lol
2023-04-23 14:45:54 -0400 < whereiseveryone> cs.cmu.edu should run the FSF and the GNU project
2023-04-23 14:46:16 -0400 < wasamasa> you are aware it merely hosts a copy of CLtL2?
2023-04-23 14:47:01 -0400 < Zipheir> (Being the systemd authors, their response to the bug report was "no program has a monopoly on generic terms".)
2023-04-23 14:47:22 -0400 < wasamasa> yes, that sounds like them
2023-04-23 14:47:24 -0400 < whereiseveryone> Well they are doing the right thing in the world
2023-04-23 14:47:51 -0400 < wasamasa> I find stuff like CLHS similarly challenging to read
2023-04-23 14:48:14 -0400 < whereiseveryone> The community spec gives the CLHS new clothes
2023-04-23 14:49:08 -0400 < whereiseveryone> When confused just wear something different: https://cl-community-spec.github.io/pages/index.html
2023-04-23 14:49:43 -0400 < wasamasa> that one makes it completely impossible to even find allow-other-keys
2023-04-23 14:49:55 -0400 < whereiseveryone> Ya, but atleast it looks nice
2023-04-23 14:50:45 -0400 < Zipheir> CLHS looks fine to me.
2023-04-23 14:51:01 -0400 < Zipheir> It's a lightweight site by current standards.
2023-04-23 14:51:37 -0400 < Zipheir> The community spec site doesn't even work for me in links.
2023-04-23 14:52:24 -0400 < whereiseveryone> But the CLHS website can't be modified.
2023-04-23 14:52:29 -0400 < whereiseveryone>  But maybe that doesn't matter given that the CLHS can't be modified...
2023-04-23 14:53:02 -0400 < wasamasa> yeah, I guess cltl2 is the better resource for learning the language than clhs
2023-04-23 14:53:30 -0400 < whereiseveryone> I'm still confused: https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/admin.scm?id=db4ddd04542c9632648f7aea103e421a3c94fb21#n4279
2023-04-23 14:53:30 -0400 < rudybot> https://teensy.info/CXBXHLtZLA
2023-04-23 14:54:06 -0400 < whereiseveryone>    (lambda* (#:key outputs inputs #:allow-other-keys)
2023-04-23 14:54:30 -0400 < whereiseveryone> What will allow-other-keys actually allow in that example
2023-04-23 14:54:32 -0400 < whereiseveryone> ?
2023-04-23 14:54:57 -0400 < wasamasa> I guess it will ignore any unknown keywords
2023-04-23 14:55:12 -0400 < whereiseveryone> I mean what keyword are you going to want to pass in to the body of that lambda besides inputs and outputs?
2023-04-23 14:55:50 -0400 < whereiseveryone> pcap is the only other free variable in the body of the lambda
2023-04-23 14:56:47 -0400 < whereiseveryone> so I guess it would allow you to pass in a different pcap package?
2023-04-23 14:57:11 -0400 < whereiseveryone> I've never seen a Guixer actually do that though
2023-04-23 14:57:24 -0400 < whereiseveryone> in a phase macro body
2023-04-23 14:58:34 -0400 < whereiseveryone> Maybe the #:allow-other-keys in that context is a "software design for flexibility" thing...
2023-04-23 14:59:05 -0400 < whereiseveryone> thinking in retro
2023-04-23 15:02:47 -0400 -!- rgherdt_ is now known as rgherdt
2023-04-23 15:09:28 -0400 < Zipheir> With no "rest" argument, it's just a black hole for extra keywords.
2023-04-23 15:09:50 -0400 < Zipheir> It may well be a flexibility feature.
2023-04-23 15:15:50 -0400 < jcowan> All praise to Guy Steele, CL Explainer Extraordinaire
2023-04-23 20:02:57 -0400 < flatwhatson> the phases are all called with one big bag of arguments, so #:allow-other-keys without #:rest prevents bombing on arguments which were intended for siblings
2023-04-23 20:03:08 -0400 < flatwhatson> so yes, "design for flexibility"
2023-04-23 20:04:03 -0400 < flatwhatson> you could think of it something like shell environment variables
--- Day changed Mon Apr 24 2023
2023-04-24 02:07:54 -0400 -!- m5zs7k_ is now known as m5zs7k
--- Day changed Tue Apr 25 2023
2023-04-25 05:04:56 -0400 -!- Netsplit *.net <-> *.split quits: adanwan, madage
2023-04-25 16:31:35 -0400 < cpli> https://github.com/chebert/schemeish implements a unified "namespace" for values and functions in common lisp (i.e. treats forms as LISP-1 in a LISP-2)
2023-04-25 16:32:28 -0400 < cpli> are there dual implementations of a seperate function namespace and funcall in scheme?
2023-04-25 16:33:08 -0400 < wasamasa> well, you could emulate that with symbols and symbol plists
2023-04-25 16:33:34 -0400 < wasamasa> picolisp does this
2023-04-25 16:33:56 -0400 < wasamasa> it's a lisp-1, but you can do a lot of indirection due to the many built-ins working upon symbols
2023-04-25 16:35:34 -0400 < wasamasa> some schemes offer symbol introspection and symbol plists, but it doesn't seem to be actually used in practice
2023-04-25 16:40:36 -0400 < cpli> wasamasa: in practice i would believe no plist but a hash-map would be used to store the indirection. is this an existing pattern: for a single-namespace language (i.e. LISP-1) to emulate namespaces with specifically plists?
2023-04-25 16:40:58 -0400 < cpli> wasamasa: also thanks for the reply!
2023-04-25 16:43:01 -0400 < wasamasa> the use of hash tables came pretty late to lisps, lol
2023-04-25 16:43:22 -0400 < wasamasa> plists or rather, property lists are how it's done traditionally
2023-04-25 16:44:44 -0400 < wasamasa> symbol plists are a thing in lisp-2 actually
2023-04-25 16:45:24 -0400 < wasamasa> in elisp they're for example used for face definitions
2023-04-25 16:47:29 -0400 < cpli> wasamasa: O(n/2) tho. but yeah, makes sense that list processors would hesitate to introduce funny fill-pointer arrays etc
2023-04-25 16:47:48 -0400 < wasamasa> sure, but usually the n is small
2023-04-25 16:47:57 -0400 < wasamasa> a hash table pays off for bigger n
2023-04-25 16:50:02 -0400 < cpli> wasamasa: concerning (2/e)lisps still emulating additional namespaces: https://github.com/guicho271828/lisp-namespace
2023-04-25 16:50:18 -0400 < cpli> > hash table pays off for bigger n
2023-04-25 16:50:23 -0400 < cpli> or frequent accesses.
2023-04-25 19:38:35 -0400 < Zipheir> What's the use-case for a separate procedure namespace?
2023-04-25 19:48:06 -0400 < cpli> Zipheir: the obvious one is always LIST and LIST
2023-04-25 20:11:27 -0400 < Zipheir> You mean if you want to call something LIST?
2023-04-25 20:12:19 -0400 < Zipheir> I suppose people do when they don't intend to use 'list' in their procedure.
2023-04-25 20:39:03 -0400 < jcowan> Zipheir: Which is most of the time.  It's one of the classic complaints of Lisp-2 users about Lisp-1s: "You can't use `list` as a variable!`  Well of course you can unless you are also going to use the `list` function in the same lexical scope.
2023-04-25 21:28:12 -0400 < acdw> or just use xs
2023-04-25 21:28:16 -0400 < acdw> or like wgatever
2023-04-25 21:32:21 -0400 < jcowan> xs suggests a list where each of the elements is an x
2023-04-25 21:32:24 -0400 < jcowan> to me, at least
2023-04-25 21:32:45 -0400 < jcowan> If the list is heterogeneous, I wouldn't name it "anys"
2023-04-25 21:46:16 -0400 < Zipheir> I tend to use 'xs' or 'lis' for a list when there's no better name.
2023-04-25 21:48:23 -0400 < jcowan> Fair enough, I just think "lis" is ugly
2023-04-25 21:51:29 -0400  * daviid uses lst or l1 l2 ... when more then one local binding to lists is necessary ... fwiw
2023-04-25 22:15:39 -0400 < jcowan> so I use "list" unless I'm going to need the `list` procedure in the local scope, which I rarely do
2023-04-25 23:01:37 -0400 < acdw> I mean. it is a list of unknowns or whatever's
2023-04-25 23:01:56 -0400 < acdw> you could do ns for numbers or ss or strs for string s...etc
--- Day changed Wed Apr 26 2023
2023-04-26 05:32:24 -0400 < sham1> xs is a good name to inform the reader of the meaninglessness of the actual elements. There's a reason why that naming convention is used by MLs
2023-04-26 05:32:51 -0400 < sham1> Other than it being slightly mathematical
2023-04-26 06:21:05 -0400 < mdhughes> I write ls if it's some short mathy bullshit, same as I use one-letter names in one-liners. Anything longer, I name the collection. points-list or such.
2023-04-26 07:37:29 -0400 < cow_2001> how do you call it when you have a string, you want to use it as an inanimate string, but your stupid code treats it as part of the code? like in sql injections, but in general, not just sql injections
2023-04-26 07:38:29 -0400 < wasamasa> https://www.more-magic.net/posts/structurally-fixing-injection-bugs.html
2023-04-26 07:38:47 -0400 < cow_2001> that's it? injection?
2023-04-26 07:39:07 -0400 < cow_2001> would not quoting bash $stuff be injection bugs?
2023-04-26 07:39:09 -0400 < wasamasa> yes
2023-04-26 07:39:13 -0400 < cow_2001> okay! thank you!
2023-04-26 07:39:19 -0400 < wasamasa> that's how OS command injection happens
2023-04-26 07:39:47 -0400 < cow_2001> i don't like shells because of that. too easy to get injections.
2023-04-26 07:39:49 -0400 < wasamasa> when I suspect my user input ends up in a shell command, I naturally try some shell control characters and see what happens
2023-04-26 07:39:57 -0400 < cow_2001> oh wow
2023-04-26 07:40:02 -0400 < wasamasa> it's my job
2023-04-26 07:40:14 -0400 < cow_2001> i didn't think of shell commands down the line
2023-04-26 07:40:25 -0400 < wasamasa> try it next time you buy a new router
2023-04-26 07:40:33 -0400 < wasamasa> embedded devices tend to be riddled with such issues
2023-04-26 07:40:36 -0400 < cow_2001> the ground on which we stand is not stable
2023-04-26 07:40:37 -0400 < sham1> Love it when people just push user input into a shell line
2023-04-26 07:40:41 -0400 < sham1> Not unsafe at all
2023-04-26 07:41:35 -0400 < wasamasa> the problem is basically that you are dealing with a language and control characters present in user input are interpreted specially
2023-04-26 07:42:10 -0400 < wasamasa> depending on the language, control characters can be surprising
2023-04-26 07:42:32 -0400 < wasamasa> in C APIs, NUL is an important control character
2023-04-26 07:42:51 -0400 < cow_2001> wasamasa: can i msg you?
2023-04-26 07:43:07 -0400 < dpk> is there a name in mathematics for taking the mean only of the minimum and maximum values in a range?
2023-04-26 07:43:10 -0400 < cow_2001> it's a silly message
2023-04-26 07:43:13 -0400 < wasamasa> sure
2023-04-26 08:12:26 -0400 < edgar-rft> cow_2001: why don't you post your message here? IRC was made for silly messages!
2023-04-26 08:12:46 -0400 < cpli> how does this make you schemers feel?:
2023-04-26 08:12:47 -0400 < cpli> #0=(lambda (n k) (if (= 0 n)) k (#0# (- n 1) (* n k)))
2023-04-26 08:15:30 -0400 < cpli> - and have there been attempts at encoding recursive forms as circular lists..
2023-04-26 08:21:17 -0400 < sham1> Well, given that it's an illegal program, not great
2023-04-26 08:22:36 -0400 < cpli> transformer magic could obviously fix that, but it feels strangely elegant
2023-04-26 09:40:31 -0400 < cow_2001> oh
2023-04-26 09:40:33 -0400 < cow_2001> well
2023-04-26 09:41:29 -0400 < cow_2001> edgar-rft: just said the nickname reminds me of some ancient cheeky photography blog about japanese culture https://www.metafilter.com/36484/Masamania
2023-04-26 09:42:06 -0400 < cow_2001> available on https://web.archive.org/
2023-04-26 16:42:44 -0400 < cow_2001> how do i learn records well
2023-04-26 16:42:54 -0400 < cow_2001> it's alien to me
2023-04-26 16:45:28 -0400 < edgar-rft> you could start with reading the Guiness Book of World Records
2023-04-26 16:47:53 -0400 < cow_2001> okay, tspl4 is thorough and guilelike
2023-04-26 16:48:09 -0400 < cow_2001> let us read the good book
2023-04-26 17:00:13 -0400 < cow_2001> turns out there is a handy epub of tspl
2023-04-26 17:09:54 -0400 < cow_2001> so tspl4 is r6rs, right? and srfi-9 is a bit different, right?
2023-04-26 17:19:10 -0400 < Zipheir> cow_2001: Yes.
2023-04-26 17:19:43 -0400 < Zipheir> cow_2001: SRFI 9/R7RS-small records are simpler. The syntax is also different from R6RS, which can trip you up.
2023-04-26 17:34:01 -0400 < cow_2001> alas
2023-04-26 18:05:04 -0400 < acdw> records are confusing
2023-04-26 18:08:50 -0400 < Zipheir> Why?
2023-04-26 18:09:23 -0400 < aeth> they're just structs, aren't they?
2023-04-26 18:09:30 -0400 < aeth> some Lisps even call them structs
2023-04-26 18:09:32 -0400 < Zipheir> Whatever structs are.
2023-04-26 18:09:40 -0400 < aeth> "static" hash tables, really.
2023-04-26 18:09:46 -0400 < Zipheir> Possibly.
2023-04-26 18:10:16 -0400 < Zipheir> "Records" in Haskell are just another syntax for types.
2023-04-26 18:10:34 -0400 < aeth> which would suggest that "records" in Haskell don't refer to the same concept
2023-04-26 18:10:45 -0400 < aeth> happens all of the time between programming languages
2023-04-26 18:10:50 -0400 < aeth> the problem is the lack of a common terminology
2023-04-26 18:11:15 -0400 < acdw> Zipheir: oh they're not so bad really but i do not really understand why lists etc aren't just sued
2023-04-26 18:11:17 -0400 < acdw> used*
2023-04-26 18:11:27 -0400 < Zipheir> I think they do. It's just that a record is simply a type with an associated constructor, set of accessors, and possibly a set of mutators. It's an abstract type family.
2023-04-26 18:11:42 -0400 < aeth> acdw: you could implement such a concept with an alist/plist... it just wouldn't be as potentially efficient
2023-04-26 18:11:53 -0400 < acdw> ohhhh
2023-04-26 18:11:53 -0400 < aeth> it's a low-level enough concept that the language can optimize it to some extent
2023-04-26 18:11:54 -0400 < Zipheir> acdw: Abstraction.
2023-04-26 18:12:02 -0400 < Zipheir> acdw: They MIGHT be lists.
2023-04-26 18:12:09 -0400 < aeth> you can't quite use an alist
2023-04-26 18:12:19 -0400 < acdw> not with that attitude :P
2023-04-26 18:12:35 -0400 < Zipheir> Records are just an abstraction.
2023-04-26 18:12:36 -0400 < aeth> you'd need a CDR so the predicate works. And then CDR to operate on it
2023-04-26 18:12:39 -0400 < aeth> but otherwise, you could use a list
2023-04-26 18:12:50 -0400 < aeth> at least, going off of SRFI-9, which is probably the simplest form in Scheme
2023-04-26 18:13:26 -0400 < Zipheir> A good excercise: implement SRFI 9 with three different structures.
2023-04-26 18:13:56 -0400 < aeth> of course, alist/plist/hash-table are all dynamic runtime structures that you can insert/delete to at runtime (you can't do that with records/structs except perhaps to leave an item undefined/uninitialized/whatever depending on the variant)
2023-04-26 18:14:24 -0400 < aeth> and alists and plists don't even have anything to tell you that they're more than just ordinary lists
2023-04-26 18:14:30 -0400 < aeth> unless you give them a special CAR yourself
2023-04-26 18:14:56 -0400 < aeth> You could implement records with vectors. You'd need adjustable ones for hash tables.
2023-04-26 18:15:16 -0400 < Zipheir> Lists, vectors, and hash-tables are all easy ways to implement them.
2023-04-26 18:15:32 -0400 < Zipheir> SICP uses tagged lists, IIRC.
2023-04-26 18:15:34 -0400 < acdw> i should git gud at vectors too... and hash-tablers
2023-04-26 18:15:40 -0400 < aeth> yes, you don't even need an alist because you can just associate an index with the accessor procedure
2023-04-26 18:15:49 -0400 < aeth> you do need the tag, though
2023-04-26 18:16:05 -0400  * acdw makes a lisp with all tagged lists
2023-04-26 18:16:10 -0400 < aeth> but if you're going to use an index might as well make that implementation a vector for O(1) since you don't need to insert at runtime
2023-04-26 18:16:17 -0400 < aeth> (for records, anyway)
2023-04-26 18:16:22 -0400 < Zipheir> Although SICP's use of a symbol tag is not robust. You need a magic cookie.
2023-04-26 18:16:48 -0400 < acdw> mmm cookie
2023-04-26 18:17:25 -0400 < aeth> e.g. (cons TAG alist) making it tag the head of a list vs. (cons TAG vector) and it's basically the same thing (since the accessor procedures can go by index instead of doing an alist or plist lookup) except it's no longer a proper list
2023-04-26 18:17:40 -0400 < aeth> off the top of my head, anyway. Similar for hash tables, I guess.
2023-04-26 18:18:24 -0400 < Zipheir> If your list has k fields, then accessing/setting one is O(k) = O(1).
2023-04-26 18:19:54 -0400 < Zipheir> Sometimes that will be important, but we should be careful when throwing big Os around. "O(1)" doesn't mean "it does exactly one thing".
2023-04-26 18:21:19 -0400 < Zipheir> (I mean sometimes those k steps for each operation will be important.)
2023-04-26 18:21:43 -0400 < aeth> what's more relevant with lists vs vectors where the properties of lists aren't actually required is probably that it's not necessarily together in memory
2023-04-26 18:22:01 -0400 < aeth> although from a memory perspective, most of the contents of a vector in a Lisp are probably pointers
2023-04-26 18:22:31 -0400 < Zipheir> I don't know much about how modern kernels/hardware handle that. I guess so.
2023-04-26 18:22:31 -0400 < aeth> lists will also use twice the memory, I think?
2023-04-26 18:23:03 -0400 < aeth> all of this seems rather theoretical with how much RAM people have, but people on IRC do from time to time complain about running out of (linked list) memory on the Lisp/Scheme channels
2023-04-26 18:23:20 -0400 < aeth> so clearly some people work on larger data sets than most
2023-04-26 18:23:34 -0400 < aeth> and a macro language lets you make this mess with records if you choose
2023-04-26 18:24:24 -0400 < acdw> how hard could it be to just have the computer figure out whether a given data structure should be internally implmeneted as a list/vector/hashmap/whatever
2023-04-26 18:25:03 -0400 < aeth> they tried that. https://en.wikipedia.org/wiki/Fifth-generation_programming_language
2023-04-26 18:25:26 -0400 < aeth> lots of it in Lisp-adjacent spaces because of course the timelines match up ('80s and early '90s)
2023-04-26 18:25:37 -0400 < aeth> and it is definitely something you'd think of if you use Scheme
2023-04-26 18:26:19 -0400 < aeth> I guess it was just found to be easier to make the programmer do a little bit of thought about data structures rather than to try to make really smart compilers
2023-04-26 18:26:21 -0400 < acdw> lemme guess it doesn't work for Reasons
2023-04-26 18:26:28 -0400 < acdw> ahhh that makes sense
2023-04-26 18:26:35 -0400 < acdw> i GUESS
2023-04-26 18:26:39 -0400  * acdw kicks a rock
2023-04-26 18:26:42 -0400 < aeth> but... some JIT really are magic. Takes a lot of resources to make them that way. https://accidentallyquadratic.tumblr.com/post/142387131042/nodejs-left-pad
2023-04-26 18:27:18 -0400 < aeth> the tl;dr is the blog author expected to describe left-pad as accidentally quadratic, but it's not, because string append in modern JS is special
2023-04-26 18:27:21 -0400 < Zipheir> It's also the legacy of C. "Optimization is the programmer's job, not the compilers."
2023-04-26 18:27:34 -0400 < Zipheir> *compiler's
2023-04-26 18:27:37 -0400 < aeth> nah, C/C++ require way more thought than the happy medium that people settled on
2023-04-26 18:27:54 -0400 < Zipheir> Yes.
2023-04-26 18:28:22 -0400 < aeth> but only JS and LuaJIT seem to aim at eliminating all such thinking. Maybe LuaJIT more than JS
2023-04-26 18:28:29 -0400 < Zipheir> As Kernighan & Pike say, "C is a razor-sharp tool. You can use it to make an efficient program, or a bloody mess."
2023-04-26 18:30:25 -0400 < Zipheir> aeth: Clearly the compilers of the near future will just use machine learning blobs to figure out what structures to use.
2023-04-26 18:31:09 -0400 < Zipheir> (Compiler output is already very hard to understand, but wait until we add AI to the mix.)
2023-04-26 18:31:25 -0400 < aeth> why stop at the software?
2023-04-26 18:31:50 -0400 < Zipheir> True. :)
2023-04-26 18:31:55 -0400 < aeth> https://en.wikichip.org/wiki/amd/microarchitectures/zen_2#Branch_Prediction_Unit
2023-04-26 18:32:08 -0400 < aeth> "Perceptrons are the simplest form of machine learning and lend themselves to somewhat easier hardware implementations compared to some of the other machine learning algorithms. They also tend to be more accurate than predictors like gshare but they do have more complex implementations. When the processor encounters a conditional branch, its address is used to fetch a perceptron from a table of perceptrons.
2023-04-26 18:32:14 -0400 < aeth> A perceptron for our purposes is nothing more than a vector of weights."
2023-04-26 18:32:33 -0400 < aeth> so if you have a 2019+ AMD chip, you can't avoid machine learning!
2023-04-26 18:33:05 -0400 < Zipheir> That's a really cool site.
2023-04-26 18:34:14 -0400 < Zipheir> Then again, a thermostat with a memory is a learning machine.
2023-04-26 18:34:25 -0400 < aeth> but you can tell from page length that Zen and Zen 2 (which is actually the 3rd Zen after Zen+) got all of the hype and marketing
2023-04-26 18:35:57 -0400 < Zipheir> It's funny how Zen is so frequently used as a brand name. It seems that the names of Christian sects have been underused.
2023-04-26 18:40:00 -0400 < aeth> nobody's going to use names that offend people
2023-04-26 18:40:06 -0400 < Zipheir> (Perhaps marketing departments only grab names from laid-back religions.)
2023-04-26 19:31:05 -0400 < wklew> tech people much prefer cultural appropriation wherever possible
2023-04-26 19:31:32 -0400 < wklew> Ubuntu, Apache, etc...
2023-04-26 19:32:02 -0400 < aeth> huh
2023-04-26 19:32:38 -0400 < aeth> I thought Ubuntu was a South African concept, and a South African distro
2023-04-26 19:32:45 -0400 < aeth> looks like Canonical is based in the UK, though
2023-04-26 19:35:02 -0400 < fizzie> Canonical's founder (Mark Shuttleworth) was born in South Africa, that much is true. (Not taking a position on whether that makes it any better or not.)
2023-04-26 19:36:42 -0400 < aeth> https://en.wikipedia.org/wiki/File:Experience_ubuntu.ogv
2023-04-26 19:38:06 -0400 < aeth> doesn't seem like cultural appropriation?
2023-04-26 19:39:37 -0400 < aeth> the concern is generally inappropriate use of the cultural artifacts of a minority, mainly Native American outfits in the US
2023-04-26 19:40:19 -0400 < aeth> while this seems to be an appropriate use of an abstract cultural concept from the majority of South Africa?
2023-04-26 19:41:00 -0400 < Zipheir> My definition of cultural appropriation is pretending the original usage doesn't exist.
2023-04-26 19:42:34 -0400 < Zipheir> But using the name of an ethical philosophy or religion for a product seems a bit tasteless.
2023-04-26 19:43:05 -0400 < cow_2001> cultural appropriation was one of the dumbest ideas i had ever met
2023-04-26 19:44:06 -0400 < aeth> hmm... is me speaking English cultural appropriation? None of my ancestors are from that part of Europe. And for all practical purposes, if England sank into the sea tomorrow it wouldn't have much of an effect on me. I only went to London once, but just to switch planes and I stayed in the airport.
2023-04-26 19:44:10 -0400 < cow_2001> it is cross cultural pollination
2023-04-26 19:44:41 -0400 < wklew> I may be wrong about Ubuntu in that case. It's certainly a problem with naming tech products though.
2023-04-26 19:45:02 -0400 < cow_2001> they should name their stuff whatever they like
2023-04-26 19:45:18 -0400 < Zipheir> cow_2001: It is, but there is also claiming you've invented something in order to wipe out another culture.
2023-04-26 19:45:20 -0400 < aeth> Zipheir: As far as Zen goes, though, I don't think anyone is offended? That seems to be the (modern) line product naming doesn't cross, if people get offended.
2023-04-26 19:45:28 -0400 < cow_2001> call it khanukiyah or sufganyah, who cares
2023-04-26 19:45:29 -0400 < Zipheir> aeth: Yes.
2023-04-26 19:45:45 -0400 < wklew> cow_2001 obviously you don't
2023-04-26 19:45:55 -0400 < cow_2001> Zipheir: i had never seen it used that way
2023-04-26 19:46:25 -0400 < cow_2001> Zipheir: you are the first
2023-04-26 19:46:56 -0400 < Zipheir> cow_2001: You might look up Japanese "reeducation" in Korea during the mid 20th century.
2023-04-26 19:47:38 -0400 < Zipheir> Or indeed, re-education in Xinjiang and elsewhere now. But, anyway.
2023-04-26 19:47:50 -0400 < cow_2001> the way i've seen it used is where people think of their culture as some intellectual property no one can ever touch
2023-04-26 19:48:03 -0400 < cow_2001> like they are Disney Corp. or something
2023-04-26 19:48:05 -0400 < Zipheir> Yes. I think that's a mistake.
2023-04-26 19:49:07 -0400 < aeth> oh, and considering that East Asia is basically the main place for computer hardware, I find it unlikely that nobody who is actually Zen Buddhist was involved in the process. "Zen" as it entered English is the Japanese name, but it was originally Chinese. https://en.wikipedia.org/wiki/Chan_Buddhism#Taiwan
2023-04-26 19:49:48 -0400 < Zipheir> Right.
2023-04-26 19:49:48 -0400 < cow_2001> chinese culturally appropriated hindu Jhana into Chan
2023-04-26 19:49:56 -0400 < aeth> Taiwan today seems to be 20% Buddhist
2023-04-26 19:50:22 -0400 < cow_2001> see how absurd it is? chan buddhism is really jhana
2023-04-26 19:50:37 -0400 < cow_2001> just let information be free
2023-04-26 19:51:03 -0400 < Zipheir> cow_2001: The example of casual appropriation I always think of is _The Song of the Thin Man_, a US movie from 1947. There's a movie about jazz without a single black actor.
2023-04-26 19:51:35 -0400 < aeth> so I think one distinction is that unlike with Apache, where almost certainly nobody of Apache background was involved, Zen wasn't made entirely by people entirely removed from the relevant cultures that are referenced by the name
2023-04-26 19:51:42 -0400 < Zipheir> I think there may be a black porter. But that makes the point even more strongly.
2023-04-26 19:51:52 -0400 < aeth> idk what South Africans think about the Ubuntu distro.
2023-04-26 19:51:57 -0400 < aeth> if it's an offensive name or not
2023-04-26 19:53:04 -0400 < cow_2001> Zipheir: sure, but now we know where it came from, but also, now that jazz is global it is no longer a Black thing. it is a Japanese thing more than anything, what with all their huge jazz fusion scene
2023-04-26 19:53:06 -0400 < wklew> yeah idk either, I was probably confusing it with Apache, which people are mad about for good reason.
2023-04-26 19:54:05 -0400 < cow_2001> things change. ideas migrate. lose favour in one part, gain in another
2023-04-26 19:54:29 -0400 < cow_2001> like some sort of algae bloom, forest fire algorithm
2023-04-26 19:54:39 -0400 < wklew> I mean the point is people making money off someone else's culture who they colonized. you can't just reduce it to silly metaphysics like that.
2023-04-26 19:54:51 -0400 < Zipheir> cow_2001: Oh, I wouldn't call jazz an "anyone thing". Just that the movies in those days nearyl pretended it wasn't played by black Americans.
2023-04-26 19:55:43 -0400 < Zipheir> That's where you get appropriation. "We like this music, we just want different people to play it!"
2023-04-26 19:56:39 -0400 < wklew> Anyway sorry for taking us off topic, probably not the ideal forum for this
2023-04-26 19:56:55 -0400 < cow_2001> ………
2023-04-26 19:57:08 -0400 < Zipheir> I think I started it with the comment about AMD's Zen naming. Sorry.
2023-04-26 19:57:25 -0400 < cow_2001> i was looking for a records guide that wasn't a specification <_<
2023-04-26 19:57:35 -0400 < aeth> I think I started it by saying that Zen 2 and above use machine learning at the hardware level, which is lower than even the programming language level
2023-04-26 19:58:41 -0400 < aeth> cow_2001: I suppose one problem is that records/structs sit in an uncomfortable middle ground between basic data structures (lists, vectors, hash tables) and OOP, although Scheme doesn't have (and never will have?) a portable OOP system
2023-04-26 19:58:51 -0400 < aeth> So people don't tend to advocate for them at all
2023-04-26 19:59:22 -0400 < aeth> But if someone uses e.g. Guile's object system, then they're just programming Guile, not Scheme
2023-04-26 19:59:36 -0400 < cow_2001> why can't we just cons car and cdr like normal people ~;~
2023-04-26 19:59:40 -0400 < Zipheir> Someone (who?) called record types a holdover from the days of punchcards.
2023-04-26 19:59:59 -0400 < Zipheir> cow_2001: Abstraction. The answer is always abstraction.
2023-04-26 19:59:59 -0400 < wklew> lists are stacks, not great for random access slots
2023-04-26 20:00:09 -0400 < cow_2001> sigh
2023-04-26 20:00:30 -0400 < Zipheir> Whether to use lists or vectors or whatever is George's problem.
2023-04-26 20:00:42 -0400 < cow_2001> poor george
2023-04-26 20:00:59 -0400 < aeth> two languages are based around one-data-structure-for-everything: Tcl and strings; Lua and hash tables
2023-04-26 20:01:15 -0400 < aeth> while Lisp/Scheme is often mistakenly described as "everything is a list", but that only applies to syntax, not to the runtime data structures
2023-04-26 20:01:31 -0400 < Zipheir> Those languages rest on Procrustean beds.
2023-04-26 20:02:53 -0400 < cow_2001> will i be better able to read the specy srfi-9-like stuff after reading tspl4's records chapter?
2023-04-26 20:06:28 -0400 < Zipheir> Try it and see. SRFI 9 is pretty easy. (define-record-type point (make-point x y) point? (x point-x) (y point-y))
2023-04-26 20:18:24 -0400 -!- daviid` is now known as daviid
2023-04-26 21:45:12 -0400 < mdhughes> The big difference is SRFI-9/R7RS requires naming every method, R6RS can generate a bunch of them. R6RS can also do inheritance, and protocols (constructors) are smarter (but a little tricky).
2023-04-26 21:52:55 -0400 < acdw> is that b/c of macro .. hygiene ? or something else
2023-04-26 21:55:15 -0400 < gwatt> yes. R6RS has an official way to break hygiene. SRFI-9 doesn't require that
2023-04-26 21:57:36 -0400 < aeth> record inheritance doesn't sound like a good idea
2023-04-26 21:57:58 -0400 < aeth> that's crossing one of those "use OOP instead" lines imo
2023-04-26 22:03:01 -0400 < gwatt> You can certainly implement OOP on top of record inheritance, though it might be a bit painful
2023-04-26 22:08:44 -0400 < mdhughes> Yeah, I use it sparingly, but there's cases where I only need a little inheritance, and OOP would be overkill.
2023-04-26 22:11:00 -0400 < mdhughes> And not having inheritance when you need it is a gigantic pain in the ass.
2023-04-26 22:14:04 -0400 < acdw> gwatt: oh that's neat, i didnt know that
2023-04-26 22:14:15 -0400 < acdw> i kep tryin to decide if i want ot r6rs or r7rs
2023-04-26 22:14:25 -0400 < acdw> i shuold proabbly get gud at sceme before really comiteing
2023-04-26 22:26:26 -0400 < Zipheir> git: 'gud' is not a git command. See 'git --help'.
2023-04-26 22:49:49 -0400 < gwatt> Zipheir: do you have "get" aliased to "git" ?
2023-04-26 22:55:16 -0400 < aeth> or Zipheir is using a simple text substitution of s/get/git/ which works perfectly fine as long as you, as later rules, substitute s/wgit/wget/ and (on Debian) s/apt-git/apt-get/
2023-04-26 23:08:49 -0400 < acdw> yes
2023-04-26 23:37:38 -0400 < Zipheir> No, I just misread it. From what I remember of turn-of-the-teens Web culture, the spelling is usually 'git gud'.
2023-04-26 23:54:39 -0400 < aeth> yes, so the response to 'get gud' is clearly 'git good'
--- Day changed Thu Apr 27 2023
2023-04-27 00:17:17 -0400 < acdw> dug tig
2023-04-27 00:17:21 -0400 < acdw> my bad Zipheir
2023-04-27 01:41:49 -0400 < mnieper> aeth: Scheme's record inheritance does not really have much to do with OOP, so any arguments in favor/against OOP don't apply to record inheritance.
2023-04-27 01:42:28 -0400 < mnieper> It is more like that in C, if you pass a procedure expecting a struct { int foo; } a struct { int foo; int bar; } than it still works.
2023-04-27 01:43:26 -0400 < mnieper> Where it applies, it is basically an efficient way to compose data structures.
2023-04-27 01:45:18 -0400 < mnieper> Seen from the viewpoint of type theory, Scheme's record inheritance implements a form of subtyping, which is pervasive in modelling with types.
2023-04-27 01:47:57 -0400 < mnieper> acdw: Whether R6RS or R7RS can be answered from different angles.  In any case, the difference is minor compared to the difference between not knowing Scheme and understanding Scheme, so I wouldn't worry too much.
2023-04-27 01:51:12 -0400 < mnieper> If you are just looking for the better, more thought-out programming language, R6RS would be the clear answer.  In all major areas, R6RS gives you more than R7RS-small (even without considering the number of features).
2023-04-27 01:51:42 -0400 < mnieper> If, however, you want to program in a certain environment, you have to base your selection on the availabe tools.
2023-04-27 01:52:22 -0400 < mnieper> There are lots of implementations of R6RS and even more of R7RS-small, and they all have their niche - some niches are larger, some are smaller.
2023-04-27 01:53:53 -0400 < mnieper> If you look for implementation that implement the standards exactly, the numbers of implementations will be much lower on both sides.
2023-04-27 01:58:19 -0400 < shawnw> Has anyone gotten stalin built on  modern systems?
2023-04-27 02:00:06 -0400 < Zipheir> Subtyping makes things complicated.
2023-04-27 02:00:25 -0400 < Zipheir> I think there is a real debate to be had about whether to add it to a language.
2023-04-27 02:05:49 -0400 < lockywolf> Subtyping is complicated, because there are different kinds of subtyping.
2023-04-27 02:08:01 -0400 < lockywolf> There are two very natural ways of looking at a phrase "A extends B".
2023-04-27 02:42:35 -0400 < mnieper> Zipheir: I think we have to draw a line between static type systems and typing in general.
2023-04-27 02:43:21 -0400 < mnieper> Expressing some specific form of subtyping in a static type system can be hard and there is still major work going on (see the experimental MLsub, for example).
2023-04-27 02:44:25 -0400 < mnieper> Typing programs in general, however, often means or needs the inclusion of subtypes.
2023-04-27 02:45:07 -0400 < mnieper> Consider a Scheme procedure that may raise exceptions of type e1 and e2.
2023-04-27 02:46:08 -0400 < mnieper> If you call it within a handler to be sure that no exception leaks, it is enough that the exceptions handled by the handler are at least e1 and e2.  It could handle e3 as well.
2023-04-27 02:48:25 -0400 < mnieper> A static type system (unless you have full dependent types) can only be an approximation of the "real types".  There may be reasons why you don't want subtypes in your static type system, but that does not make subtyping go away in the "real types".
2023-04-27 02:49:09 -0400 < mnieper> As Scheme has no static type system, I meant the latter, not the former when talking about inheritance and a form of subtyping.
2023-04-27 02:50:33 -0400 < mnieper> In any case, this is not strongly connected with R6RS-like inheritance (it just makes things easier); you can also implement all that on top of SRFI 9.  (It will just be somewhat inefficient and may cause you headaches.)
2023-04-27 02:55:14 -0400 < Zipheir> Lots to think about. I'll reply tomorrow when I'm less tired. Good night/morning!
2023-04-27 03:05:10 -0400 < mnieper> Zipheir: Good night!  It is too bad that we live in different time zones.
2023-04-27 06:38:46 -0400 < amirouche> Anyone knows a procedural pattern matcher to help get started. TIA!
2023-04-27 06:38:56 -0400 < amirouche> even a specification can help
2023-04-27 07:09:56 -0400 < amirouche> I want to match chez scheme annotations, the advantage over a datum is that an annotation has information about the source location
2023-04-27 07:18:59 -0400 < amirouche> shawnw: not me, but people use it
2023-04-27 07:20:01 -0400 < amirouche> shawnw: there is a guix package for stalin @ https://github.com/lfam/guix/blob/de84b24613afa4020f3f0553dad8e39a78d1f92c/gnu/packages/scheme.scm#L853
2023-04-27 08:15:40 -0400 < acdw> mnieper: thanks!
2023-04-27 13:17:03 -0400 < Zipheir> Yes, it's often useful to distinguish between "real types" and the system implemented by a compiler/interpreter. I have no problem with "real" subtypes.
2023-04-27 13:52:12 -0400 < edgar-rft> In Common Lisp, subtypes of real are float and rational :-)
2023-04-27 14:15:48 -0400 -!- pi2 is now known as johnjae
2023-04-27 14:16:06 -0400 -!- johnjae is now known as johnjay
2023-04-27 14:19:26 -0400 < Zipheir> Numbers are one place you constantly deal with subtyping in Scheme.
2023-04-27 14:57:09 -0400 < mnieper> There are also many not so obvious instances of subtyping, like proper lists among (possibly) dotted lists.
2023-04-27 15:47:05 -0400 < acdw> i wanna know why lists can't be dotted more htan once :P
2023-04-27 15:47:50 -0400 < wasamasa> ok, let's do some thought experiment
2023-04-27 15:48:20 -0400 < acdw> lets!
2023-04-27 15:49:01 -0400 < wasamasa> (a . b) essentially means (cons 'a 'b), so (a . b . c) may mean (cons 'a (cons 'b 'c)) or (cons (cons 'a 'b) 'c), depending on precedence
2023-04-27 15:49:18 -0400 < wasamasa> the former is equivalent to (a b . c)
2023-04-27 15:49:35 -0400 < wasamasa> the latter to ((a . b) . c)
2023-04-27 15:49:52 -0400 < acdw> so basically, since lispers don't want to think about operator precedence they made it a one-dot-per-list rule? :P
2023-04-27 15:50:03 -0400 < acdw> > have one infix operator
2023-04-27 15:50:08 -0400 < acdw> > only allow one per form
2023-04-27 15:50:09 -0400 < wasamasa> it seems that the former is the prevailing interpretation
2023-04-27 15:51:45 -0400 < wasamasa> racket seems to be a notable exception
2023-04-27 15:53:19 -0400 < wasamasa> it repurposes them for infix operations, lol
2023-04-27 15:53:21 -0400 < wasamasa> (1 . + . 2)
2023-04-27 15:54:33 -0400 < acdw> oh lord, that's cursed
2023-04-27 15:54:37 -0400 < acdw> this is why i don't racket :PO
2023-04-27 16:01:09 -0400 < amirouche> for one second I thought datomic was source available
2023-04-27 16:01:17 -0400 < amirouche> https://blog.datomic.com/2023/04/datomic-is-free.html
2023-04-27 16:12:38 -0400 < wasamasa> yes, I had to check that paragraph a few times
2023-04-27 16:13:10 -0400 < wasamasa> why on earth would they phrase it like this
2023-04-27 16:13:30 -0400 < wasamasa> "Datomic is freeware" would have been a lot more accurate
2023-04-27 16:14:06 -0400 < dpk> except it’s more than freeware
2023-04-27 16:14:44 -0400 < dpk> if someone wanted to reverse engineer the source code OpenTTD-style, they could do so legally without OpenTTD-style ‘it fell off the back of a truck’ chicanery
2023-04-27 16:14:55 -0400 < wasamasa> or at least answer it with "No, it's not open-source"
2023-04-27 16:17:26 -0400 < acdw> what is datomic anwyay
2023-04-27 16:18:02 -0400 < wasamasa> a database that keeps revisions
2023-04-27 16:18:09 -0400 < acdw> ohhh
2023-04-27 16:18:23 -0400 < wasamasa> so you can do things like query an object, but a day ago
2023-04-27 16:18:47 -0400 < acdw> that does sound useful
2023-04-27 16:19:24 -0400 < wasamasa> it does have its uses
2023-04-27 16:21:12 -0400 < wasamasa> another interesting property is the use of datalog rather than SQL
2023-04-27 16:30:19 -0400 < dpk> also, since it's only available in binary form, i assume username ken and password p/q2-q4!a will log you in on any box it's installed
2023-04-27 16:32:01 -0400 < wasamasa> lol
2023-04-27 16:32:05 -0400 < wasamasa> I hope not
2023-04-27 16:32:43 -0400 < wasamasa> in the years of clojure dev I've done, every jar was shipped along with a config file for setting up passwords and stuff
2023-04-27 16:35:50 -0400 < acdw> dpk: all i saw was ********
2023-04-27 17:42:44 -0400 < DeeEff> acdw: it just said hunter2
2023-04-27 17:46:29 -0400 < DeeEff> One thing I wanted to mention that may be relevant: https://github.com/KavrakiLab/tmkit
2023-04-27 17:46:51 -0400 < DeeEff> all in common lisp but one of the professors in charge of this project spoke at a local robotics meetup group I help organize yesterday
2023-04-27 17:48:08 -0400 < DeeEff> not actually #scheme but I thought it was a pretty cool presentation and a pretty novel use of Lisp in robotics which is an industry dominated by people who love C++ and hate anything else
2023-04-27 17:48:18 -0400 < DeeEff> :P
2023-04-27 17:54:09 -0400 < wklew> very cool. by presentation do you mean someone gave a presentation about it?
2023-04-27 17:58:32 -0400 < DeeEff> yeah Prof. Neil Dantam from the Colorado School of Mines went through it and various other projects adjacent to it
2023-04-27 17:58:38 -0400 < DeeEff> but that's his lab AFAIK
2023-04-27 17:59:03 -0400 < DeeEff> rather, that's the lab he used to study under, but still works on that project at School of Mines
2023-04-27 17:59:14 -0400 < DeeEff> it's complicated but there's a bunch of universities that contribute
2023-04-27 18:13:45 -0400 < acdw> DeeEff: just said what
2023-04-27 18:13:46 -0400 < acdw> ?
2023-04-27 18:29:22 -0400 < DeeEff> lol
2023-04-27 18:29:35 -0400 < DeeEff> forgot my password filter was on
2023-04-27 18:30:08 -0400 < acdw> lmao
--- Day changed Fri Apr 28 2023
2023-04-28 10:31:29 -0400 < lechner> Hi, is there a diff algorithm for sexps? I tried the one from Racket but that did not seem to work very well locally
2023-04-28 17:39:03 -0400 < wasamasa> yes, there is one
2023-04-28 17:39:15 -0400 < wasamasa> https://github.com/ChaosEternal/guile-sexp-diff
2023-04-28 17:39:48 -0400 < wasamasa> http://wiki.call-cc.org/eggref/4/sexp-diff
2023-04-28 17:40:20 -0400 < wasamasa> I guess that's the same thing as in racket
2023-04-28 17:40:34 -0400 < wasamasa> yes indeed
2023-04-28 17:41:47 -0400 < wasamasa> lechner: lucky you, have fun debugging why it does not not "work very well locally"
2023-04-28 20:25:25 -0400 < lechner> wasamasa / thanks! do you know of anyone using it successfully?
2023-04-28 21:05:17 -0400 -!- Andrew is now known as AndrewYu
--- Day changed Sat Apr 29 2023
2023-04-29 02:25:43 -0400 < dpk> JS has a new ‘oops, we added two features that aren’t composable’ https://lea.verou.me/2023/04/private-fields-considered-harmful/
2023-04-29 02:52:13 -0400 < shawnw> Javascript in general is an oops.
2023-04-29 03:12:10 -0400 < LeoNerd> It's what happens when you lock a bunch of non-(language architects) in a room for three days and tell them they can't come out until they've designed a web site extension system
2023-04-29 05:29:49 -0400 < wasamasa> lechner: nope, like many scheme things, I mostly know of people loudly thinking about using something, I barely know of people actually using it to build something concrete
2023-04-29 05:31:56 -0400 < wasamasa> dpk: so people end up using some stupid convention like python's underscore prefixed fields?
2023-04-29 05:32:12 -0400 < wasamasa> dpk: I don't really see the fuss, but then, it reminds me a lot of the "pick your preferred C++ subset" idea
2023-04-29 06:44:48 -0400 < dpk> programming languages should be designed not by piling feature on top of feature, etc.
2023-04-29 07:20:14 -0400 < sham1> Perfection is achieved not when there's nothing to add, but when there's nothing to remove
2023-04-29 08:11:21 -0400 < amirouche> hey, anyone has a procedural pattern matcher?
2023-04-29 08:44:18 -0400 < sham1> Like Scala?
2023-04-29 09:22:48 -0400 < mdhughes> amirouche: You mean like Alex Shinn's match? Or what? Because I don't really use match, but that's the one I'd use if I did.
2023-04-29 09:27:51 -0400 < mdhughes> I'm a very simple creature. Often my control messages are in the form (cmd args) handled with: (apply (href HANDLERS (car msg)) (cdr msg)) so I don't need to match anything.
2023-04-29 10:04:47 -0400 < wasamasa> yeah, it's a fun approach
2023-04-29 10:05:09 -0400 < wasamasa> case-lambda is also fun
2023-04-29 10:31:31 -0400 < mnieper> amirouche: What do you mean by "procedural">
2023-04-29 10:31:32 -0400 < mnieper> ?
2023-04-29 10:37:10 -0400 < amirouche> that is not a macro
2023-04-29 10:37:42 -0400 < amirouche> In fact, I need to match chez annotations to have source information, maybe it is possible to do that with match?
2023-04-29 10:38:41 -0400 < amirouche> mdhughes_: In the case I am dealing with I also need to recurse into forms. Indeed (apply ... is helpful to avoid match in general
2023-04-29 10:38:51 -0400 -!- mdhughes_ is now known as mdhughes
2023-04-29 10:42:23 -0400 < mnieper> dpk: I don't understand the complaint about the JS features.  This is how abstraction barriers work.
2023-04-29 10:43:43 -0400 < mnieper> amirouche: Why don't you use syntax-case?
2023-04-29 10:43:47 -0400 < wasamasa> one feature to erect abstractions, another to tear them down
2023-04-29 10:44:01 -0400 < wasamasa> I don't see any way this might backfire
2023-04-29 10:44:30 -0400 < mnieper> wasamasa: A proxy is not a debugging tool; it is not to tear down abstractions (which would be no abstractions then).
2023-04-29 10:44:40 -0400 < mdhughes> I guess you could pull out all the annotations into a list, then match them. Wrap that in a macro and you have one-liners that dispatch somewhere based on source.
2023-04-29 10:44:41 -0400 < mnieper> amirouche: syntax-case handles annotated objects.
2023-04-29 11:03:38 -0400 < mnieper> If you can say a bit more about your intended use case, I may be able to say more as well :)
2023-04-29 11:23:45 -0400 < mnieper> The proxy/private properties "observation" feels a bit like complaining that memcpy'ing some random opaque C struct won't necessarily give a working object.
2023-04-29 11:41:57 -0400 < Zipheir> wasamasa: Erecting them and tearing them down is a large part of programming.
2023-04-29 11:42:49 -0400 < Zipheir> Well, *metaprogramming.
2023-04-29 12:44:36 -0400 < cow_2001> i need to get back on the horse
2023-04-29 12:44:44 -0400 < cow_2001> and the elephant
2023-04-29 14:01:26 -0400 -!- mfiano_ is now known as mfiano
2023-04-29 16:36:48 -0400 < sham1> The whole industry of computer programming is about conditionally either erecting or tearing down abstractions
2023-04-29 16:41:13 -0400 -!- Netsplit *.net <-> *.split quits: civodul, clacke, micro, karlosz, edgar-rft
2023-04-29 16:41:25 -0400 -!- Netsplit over, joins: micro
2023-04-29 16:42:04 -0400 -!- Netsplit over, joins: edgar-rft
2023-04-29 18:57:17 -0400 < jcowan> in truth there are only two subtypes of Number in Scheme, Exact and Inexact; the rest are just representations.
--- Day changed Sun Apr 30 2023
2023-04-30 02:45:22 -0400 < mnieper> jcowan: What definition of "subtype" do you use?
2023-04-30 02:49:07 -0400 < mnieper> Conceptionally, every predicate in Scheme can define a subtype, including, say, the predicate `integer?'.  This may or may not give the full set of number objects in a particular Scheme implementation (but the latter is irrelevant).
2023-04-30 02:49:40 -0400 < jcowan> Yes, and in that sense there are aleph-one subtypes of Number.
2023-04-30 02:50:35 -0400 < mnieper> Continuing my previous message: In fact, whenever I have a theory with subtypes and that has a semantic interpretation in Scheme, I have conceptually produced a subtype in Scheme.
2023-04-30 02:51:11 -0400 < mnieper> jcowan: What is aleph-one outside set theory?
2023-04-30 02:51:27 -0400 < jcowan> Nothing.
2023-04-30 02:51:52 -0400 < jcowan> A subtype is a subset, and there are aleph-one subsets of numbers.
2023-04-30 02:53:34 -0400 < sham1> But there'd only be aleph_0 possible type predicates for subset of numbers, no? Since you can only have countably infinite programs
2023-04-30 02:54:12 -0400 < jcowan> But numeric functions are polymorphic only in exact and inexactness.
2023-04-30 02:55:29 -0400 < jcowan> sham1: There are only aleph_0 expressible predicates, yes, but there are aleph_1 predicates altogether
2023-04-30 03:21:16 -0400 < mdhughes> Lacking infinite memory, I'm pretty sure there's no more than 2^64 "types" in any modern system, and usually a bit less.
2023-04-30 03:22:42 -0400 < mdhughes> Whether the numbers are one type with some flags, or 3 or 4 different types, would depend on the impl. It's not "math" or set theory stuff, just engineering.
2023-04-30 03:49:20 -0400 < mnieper> BTW, in the above discussion, aleph_1 has to be replaced by 2^{aleph_0}.
2023-04-30 03:50:16 -0400 < mnieper> Whether aleph_1 = 2^{aleph_0} depends on the model of set theory (both is consistent with the axioms of ZFC -> see continuum hypothesis and Gödel's and Cohen's contributions).
2023-04-30 03:52:14 -0400 < mnieper> But that should be irrelevant for Scheme; if we want to count the number of subtypes, we have to see either how many different subtypes we can formulate in Scheme (countable many) or how many different subtypes we can formulate in our meta language (usually at least countably many).
2023-04-30 07:05:30 -0400 < sham1> Well I for one am a believer in the continuum hypothesis, so aleph_1 for me. But that's a good point to keep in mind
2023-04-30 07:08:16 -0400 < sham1> And of course we'd have to consider the subtypes we can formulate in Scheme. That's what a type predicate is, after all
2023-04-30 09:10:01 -0400 < mnieper> sham1: Are you a platonist?
2023-04-30 09:10:13 -0400 < mnieper> What makes you "believe" the CH?
2023-04-30 09:11:10 -0400 < mnieper> There are interesting subtypes that are not reflected by Scheme predicates.  For example the subtype of all terminating procedures (say, as arguments to map).
2023-04-30 09:14:46 -0400 < mnieper> Re models (and why thinking in ZFC captures only a small bit of what is): There are non-trivial toposes (briefly: settings/universes where one can do logic and maths) where there provably is a surjection from the naturals to the (Dedekind) reals.
2023-04-30 09:19:45 -0400 -!- civodul` is now known as civodul
2023-04-30 09:24:25 -0400 < sham1> Belief might be a strong word. It's more that I really have no reason not to think that CH is true
2023-04-30 09:27:34 -0400 < mnieper> Do you have a reason not to think that there more subsets of the real line than the CH allows?
2023-04-30 09:28:14 -0400 < mnieper> A formalist could say that "thinking the CH is true" is analogous to "thinking that groups are abelian".
2023-04-30 11:27:26 -0400 -!- Netsplit *.net <-> *.split quits: energizer, switchy, dbohdan, saorge, conjunctive, rubin55, elflng, edgar-rft, zups, rickbutton,  (+6 more, use /NETSPLIT to show all of them)
2023-04-30 11:27:39 -0400 -!- Netsplit over, joins: saorge
2023-04-30 11:27:58 -0400 -!- Netsplit over, joins: zups
2023-04-30 11:28:14 -0400 -!- Netsplit over, joins: flatwhatson
2023-04-30 11:28:28 -0400 -!- Netsplit over, joins: rubin55
2023-04-30 17:40:10 -0400 < sham1> I'll be honest, I haven't thought of it all that well
2023-04-30 18:03:17 -0400 -!- sham1_ is now known as sham1
--- Day changed Mon May 01 2023
