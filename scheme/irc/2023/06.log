2023-06-05 11:06:29 -0400 < ecraven> well, if there were non-blocking functions, I could write this as a single thread :-/
2023-06-05 11:34:53 -0400 < amirouche> IIRC you can
2023-06-05 11:35:12 -0400 < amirouche> it is similar to how I do it in petit-cloud's entangle
2023-06-05 11:35:26 -0400 < amirouche> the question is: are read, and write procedure of custom call/cc safe?
2023-06-05 11:37:14 -0400 < amirouche> e.g. inside the custom port read, you call POSIX read, if it returns WOULDBLOCK, then you pause the procedure, and add it to `select` or `epoll`, or liburing's ring with a reference the point where the pause happened
2023-06-05 11:38:20 -0400 < amirouche> the pause, unpause mechanic is similar to raise-continuable (afaiu), except you have a variable holding a reference on the continuation at the time of calling pause (the equivalent of raise)
2023-06-05 11:40:14 -0400 < amirouche> pause is wrapped itself inside a call/cc (afaiu similar to a guard) that i call a prompt, when a procedure calls pause, the prompt continuation is called, that is in the prompt handler that the pause continuation is registered against the event loop to be restarted when reading is possible
2023-06-05 11:42:37 -0400 < amirouche> the essence of transparent async is summarized in make-coroutine-generator. The equivalent of `yield` is the procedure that trigger the prompt handler that will capture the current continuation, pass it to the prompt handler, and the prompt handler will register that continuation to continue when fd is ready.
2023-06-05 11:45:44 -0400 < amirouche> the equivalent of yield from make-coroutine-generator is called `entangle-abort`, it looks very much like yield from make-coroutine-generator
2023-06-05 11:49:02 -0400 < amirouche> http://ix.io/4xxs
2023-06-05 11:50:13 -0400 < amirouche> make-coroutine-generator pass an explicit yield argument to the coroutine because that is easier that having an extra procedure such coroutine-generator-yield
2023-06-05 11:51:02 -0400 < amirouche> indeed, such a procedure will lead to confusion, as it can only be called inside a coroutine, so yield is passed as an argument so that makes it impossible to make an error about it
2023-06-05 11:53:47 -0400 < amirouche> with entangle, entangle-abort leak the abstraction of transparent async. As far as I know, it is not a problem. There is a very small set of cases where the user needs to call entangle-abort directly, in fact, for the kind of things people pay programmers to do, you will never need it ;)
2023-06-05 11:55:38 -0400 < amirouche> Also, in the case of entangle-abort, the user may call a procedure that can be paused everywhere, so having an explicit abort passed all around as argument is... ugly.
2023-06-05 11:56:47 -0400 < amirouche> Mind the fact, that there is no concurrency bug with the use of a global abort, except in the case where you run more than one event loop, that can be fixed with a thread parameter, and then I do not see a usecase for running entangle twice in the same posix thread.
2023-06-05 11:59:38 -0400 < amirouche> a case must be made about the advantage of transparent async vs. explicit async / await
2023-06-05 12:02:01 -0400 < amirouche> the gist of it is that 99% of the users do not not need the extra information provided by explicitly stating that "procedure socket-read can be paused", or "Some callee may want to pause" or "That callee may pause"
2023-06-05 12:02:45 -0400 < amirouche> afaiu only foundational libraries need to care about that, and foundation libraries are seldom.
2023-06-05 12:03:48 -0400 < amirouche> please note the primary advantage of async and await is not user ux, but interpreter / compiler ease of implementation
2023-06-05 12:06:24 -0400 < amirouche> there is another case where the knowing that "a procedure may pause" is useful: when the user explicitly need to take advantage of concurency, in that case, the execution of a procedure may be interleaved with the exception of another procedure that use the same shared states, hence may lead to bugs
2023-06-05 12:07:33 -0400 < amirouche> there is several approaches to work around that: 0) avoid global states 1) use cml or actor model 2) implement critical sections around the shared states
2023-06-05 12:08:24 -0400 < amirouche> btw a critical section is very much a transaction as understood in database softwares
2023-06-05 12:41:42 -0400 < ecraven> this seems a lot more complex than "just" allowing read and write to return #f if they can't do their work right now
2023-06-05 12:42:05 -0400 < ecraven> (and by "read and write" I mean things like `read-bytevector' and `write-bytevector')
2023-06-05 12:43:13 -0400 < Zipheir> Returning #f from read would be very bad.
2023-06-05 12:44:05 -0400 < acdw> we need a #actuallyf
2023-06-05 12:44:40 -0400 < Zipheir> The main question about non-blocking procedures is how to integrate them with Scheme's semantics. What's the continuation of a blocked procedure? Do they take some "would-block" continuation?
2023-06-05 12:45:17 -0400 < Zipheir> The whole convention of using #f as an in-band signal is an artifact.
2023-06-05 12:45:51 -0400 < Zipheir> It's convenient for a lot of things, but it would be bad to use it to implement non-blocking stuff.
2023-06-05 12:52:36 -0400 < Zipheir> Interesting question about non-blocking semantics: If you have a non-blocking 'read', what happens when you invoke it and then drop its continuation? e.g. (call/cc (lambda (abort) (let ((res (read))) (if (eqv? res 'blocked) (abort) res))))
2023-06-05 12:53:28 -0400 < Zipheir> (I don't mean to endorse the "magic cookie" approach to non-blocking read; it's just an exampl.)
2023-06-05 12:53:30 -0400 < Zipheir> *example
2023-06-05 13:02:55 -0400 < gwatt> You'd probably want callbacks or fibers/green threads.
2023-06-05 13:06:39 -0400 < ecraven> I'm not sure I understand, why would it be that bad if `read-bytevector' returned #f if there *is* nothing to read (using peek-u8 internally, or something like it)?
2023-06-05 13:08:20 -0400 < gwatt> well, read-{bytevector,string} are probably fine with that, but you couldn't use that for read
2023-06-05 13:08:35 -0400 < Zipheir> ecraven: It would be better in that case, since read-bytevector can't "normally" return #f.
2023-06-05 13:08:48 -0400 < Zipheir> Yeah, it was really 'read' I was complaining about.
2023-06-05 13:08:58 -0400 < ecraven> yea, sorry for writing "read and write", I actually meant the low-level functions
2023-06-05 13:47:01 -0400 < cow_2001> haven't got a clue what i'm doing https://gitlab.com/flatwhatson/prescheme-demo/-/merge_requests/1/diffs?diff_id=699844001&start_sha=876ccebdae133272ee8c2904ca8f7149f4415504
2023-06-05 13:47:02 -0400 < rudybot> https://teensy.info/0Bo3UCP4tI
2023-06-05 14:09:09 -0400 -!- abraxas_ is now known as abraxas
2023-06-05 15:01:55 -0400 -!- mirai_ is now known as mirai
2023-06-05 15:46:53 -0400 -!- mode/#scheme [+o Zipheir] by ChanServ
2023-06-05 15:47:05 -0400 -!- mode/#scheme [+b *!*ec@gateway/tor-sasl/ec] by Zipheir
2023-06-05 15:47:05 -0400 -!- ec_ was kicked from #scheme by Zipheir [Excess JOIN/QUIT.]
2023-06-05 15:47:14 -0400 -!- mode/#scheme [-o Zipheir] by ChanServ
2023-06-05 16:39:56 -0400 < Zipheir> OK, my question about continuations of blocked procedures didn't make a lot of sense. Maybe I need to use continuation marks to try to clarify what I was getting at.
2023-06-05 17:19:07 -0400 < cow_2001> oof. no forward definitions (that i know of) in prescheme
2023-06-05 17:19:46 -0400 < cow_2001> wanted to have a general dynamic type so i could have dynamic cons
2023-06-05 17:20:05 -0400 < cow_2001> but cons and……… wait a minute
2023-06-05 17:23:52 -0400 < cow_2001> maybe i could use a tuple?
2023-06-05 17:23:58 -0400 < cow_2001> inside of the dynamic type
2023-06-05 17:45:09 -0400 < cow_2001> http://lambda.bugyo.tk/cdr/mwl/
2023-06-05 17:45:17 -0400 < cow_2001> manga guide to lisp
--- Day changed Tue Jun 06 2023
--- Log closed Tue Jun 06 01:11:49 2023
--- Log opened Tue Jun 06 01:18:03 2023
2023-06-06 01:18:03 -0400 -!- Irssi: #scheme: Total of 193 nicks [0 ops, 0 halfops, 0 voices, 193 normal]
2023-06-06 01:18:04 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-06-06 02:05:16 -0400 < mdhughes> You could make another unrepresentable (non-block-object), but now every IO that expects eof-object is going to process that and have problems.
2023-06-06 11:22:26 -0400 < gwatt> I guess it depends if you want to use the standard IO procedures with the async ports.
2023-06-06 11:58:55 -0400 < amirouche> Any one has feedback on little learner book?
2023-06-06 12:00:31 -0400 < amirouche> amazon reviews are not helpful
2023-06-06 12:00:58 -0400 < acdw> that's a given
2023-06-06 12:23:21 -0400 < Zipheir> amirouche: I couldn't get the Racket library to install correctly. I figured I'd try it again in a few months.
2023-06-06 12:28:20 -0400 < edgar-rft> I learned only very little, didn't know there's a book about it.
2023-06-06 13:01:05 -0400 < cow_2001> Zipheir: is there a schemeish book about common data structures and algorithms?
2023-06-06 13:01:45 -0400 < cow_2001> it's a huge gaping hole in my education
2023-06-06 13:02:12 -0400 < cow_2001> search, trees, sorts, graphs
2023-06-06 13:03:47 -0400 < acdw> honeslty i could use that too lol
2023-06-06 13:04:01 -0400 < acdw> rn i have a youtube education and kinda sorta get graphs
2023-06-06 13:16:30 -0400 < cow_2001> what is a proper education?
2023-06-06 13:16:49 -0400 < acdw> books? idk
2023-06-06 13:16:55 -0400 < acdw> youtube is not bad these days
2023-06-06 13:17:42 -0400 < cow_2001> link?
2023-06-06 13:18:35 -0400 < acdw> youtube.com
2023-06-06 13:18:45 -0400 < acdw> like i have no links to specific videos
2023-06-06 13:18:56 -0400 < acdw> i've got bits and pieces from various random videos strewn everywhere
2023-06-06 13:19:11 -0400 < acdw> afaict a graph is just a big bunch of "nodes" that are connected (or not connected!) by "edges"
2023-06-06 13:19:18 -0400 < cow_2001> random walks aka drunken sailor ~_~
2023-06-06 13:19:23 -0400 < acdw> those edges can have direction or not too
2023-06-06 13:19:29 -0400 < acdw> cow_2001: ... a GRAPH
2023-06-06 13:19:30 -0400 < acdw> :O
2023-06-06 13:20:03 -0400 < cow_2001> i mean, going through youtube randomly now reminds me of that
2023-06-06 13:20:58 -0400 < acdw> it's graphs all the way down
2023-06-06 13:21:26 -0400 < cow_2001> by the way, Ross Scott of Accursed Farms is now interviewing people who say they know something about the impending ai apocalypse, for which he is a sceptic
2023-06-06 13:23:44 -0400 < acdw> i mean i know that ai is a bubble that's going to pop at some point, idk if i'd call that an apocalypse
2023-06-06 13:26:39 -0400 < cow_2001> bubble?
2023-06-06 13:26:52 -0400 < acdw> like the dot com bubble or the real estate bubble or
2023-06-06 13:27:01 -0400 < acdw> market bubble
2023-06-06 13:27:30 -0400 < cow_2001> you mean it is not as useful as it seems?
2023-06-06 13:28:30 -0400 < acdw> i mean that the current market is a speculative bubble, i.e. the value of all this tech is way overblown. and at some point people will realize it and pull out their investments, causing the bubble to "pop"
2023-06-06 13:28:37 -0400 < acdw> or yeah, what you said
2023-06-06 13:33:49 -0400 < sham1> I've gone through the proper education. It's nice and you learn some things that might be useful but you might not get from just googling tutorials, but at the same time some of the most illuminating times for programming have been at job
2023-06-06 13:34:19 -0400 < sham1> (well technically still going through the proper education, but it's very close to the end)
2023-06-06 13:38:48 -0400 < acdw> i've heard similar
2023-06-06 13:39:35 -0400 < acdw> honestly /many/ jobs that require degrees use those degrees as some kind of proxy, really
2023-06-06 13:39:47 -0400 < acdw> for ... stick-to-it-ive-ness, or possibly just class
2023-06-06 13:41:06 -0400 < sham1> Stick-to-it-ive-ness, class or even just as a proxy for skill. Like how does one assess how good someone is? It's a big problem for doing programmer interviews
2023-06-06 13:41:11 -0400 < acdw> mmm yeah
2023-06-06 14:15:34 -0400 < Zipheir> cow_2001: ... SICP?
2023-06-06 14:16:23 -0400 < Zipheir> If you want functional-flavored books on algorithms and data structures, I recommend Chris Okasaki and Richard Bird.
2023-06-06 14:16:36 -0400 < Zipheir> They tend to use ML or Haskell, though.
2023-06-06 14:18:08 -0400 < Zipheir> acdw: Another important function of degrees is ass-coverage. If you hire someone and something bad happens, you can say "but they were qualified!"
2023-06-06 14:18:43 -0400 < Zipheir> It's all about confidence.
2023-06-06 14:20:30 -0400 < Zipheir> Anyway, Bird & Gibbons's recent _Algorithm Design with Haskell_ looks pretty good. https://www.cs.ox.ac.uk/publications/books/adwh/
2023-06-06 14:21:04 -0400 < Zipheir> They don't use any fancy Haskell features, so everything should be directly translatable to Scheme.
2023-06-06 14:27:55 -0400 < acdw> Zipheir: yeah that's true. fits in with my main point, though, which is that degrees are often not required for their actual merit
2023-06-06 14:28:08 -0400 < acdw> but for like... ancillary reasons
2023-06-06 14:28:18 -0400 < acdw> which is something i think should be more explicit
2023-06-06 14:29:54 -0400 < Zipheir> Yes.
2023-06-06 14:47:45 -0400 -!- ced2 is now known as cedb
2023-06-06 15:50:06 -0400 < cow_2001> a cs friend of mine says Corman
2023-06-06 15:50:15 -0400 < cow_2001> acdw: Zipheir:
2023-06-06 16:04:25 -0400 < acdw> corman?
2023-06-06 17:21:32 -0400 < Zipheir> acdw: https://en.wikipedia.org/wiki/Introduction_to_Algorithms
2023-06-06 17:21:49 -0400 < Zipheir> cow_2001: It is good (I haven't read all of it), but very imperative.
2023-06-06 17:23:55 -0400 < acdw> ooo
2023-06-06 17:23:58 -0400 < acdw> thanks Zipheir
--- Day changed Wed Jun 07 2023
--- Log closed Wed Jun 07 01:31:59 2023
--- Log opened Wed Jun 07 01:32:13 2023
2023-06-07 01:32:13 -0400 -!- Irssi: #scheme: Total of 199 nicks [0 ops, 0 halfops, 0 voices, 199 normal]
2023-06-07 01:32:13 -0400 -!- Irssi: Join to #scheme was synced in 6 secs
2023-06-07 02:49:02 -0400 < amirouche> I made a pre-release of petit-cloud @ https://github.com/letloop/petit-cloud/releases
2023-06-07 02:49:16 -0400 < amirouche> feedback, and emojis welcome ;)
2023-06-07 03:33:53 -0400 < sham1> 👍
2023-06-07 03:42:32 -0400 < dave0> 🐈
2023-06-07 07:26:54 -0400 < amirouche> I started going through Teaching and Learning Compilers Incrementally, written by a student of Dybvig
2023-06-07 07:26:56 -0400 < amirouche> https://iucompilercourse.github.io/tutorial-web-page/
2023-06-07 07:27:16 -0400 < amirouche> it rely on nanopass approach
2023-06-07 07:34:23 -0400 < amirouche> not bad :)
2023-06-07 09:22:19 -0400 < leah2> neat
2023-06-07 09:34:34 -0400 < cow_2001> Caveat It is traditional for the author to magnanimously accept the blame for whatever deficiencies remain. I don’t. Any errors, deficiencies, or problems in this book are somebody else’s fault, but I would appreciate knowing about them so as to determine who is to blame.
2023-06-07 09:35:23 -0400 < leah2> =)
2023-06-07 09:35:30 -0400 < leah2> i can't believe it's not shivers :p
2023-06-07 09:36:44 -0400 < cow_2001> some of these people have a great sense of humour. did you read the scsh manual acknowledgements page?
2023-06-07 09:37:14 -0400 < cow_2001> a great sense of humour and/or confession to crime
2023-06-07 09:37:54 -0400 < leah2> yes
2023-06-07 09:42:16 -0400 < cow_2001> leah2: chto eta Shivers?
2023-06-07 09:43:14 -0400 < leah2> what?
2023-06-07 09:43:30 -0400 < cow_2001> who is shivers?
2023-06-07 09:45:52 -0400 < leah2> ... the scsh author
2023-06-07 09:50:41 -0400 < Zipheir> Haha.
2023-06-07 09:56:05 -0400 < leah2> amirouche: aah this book is excellent
2023-06-07 09:56:17 -0400 < leah2> but how do i find time to read it :D
2023-06-07 10:25:19 -0400 < Zipheir> leah2: amirouche: Python?! I'm surprised.
2023-06-07 10:26:43 -0400 < Zipheir> Jeremy Siek also wrote a good paper on gradually-typed Scheme. http://scheme2006.cs.uchicago.edu/13-siek.pdf
2023-06-07 11:29:46 -0400 < cow_2001> acdw: Zipheir: first corman exercise. i don't know some algebra. https://0x0.st/Hc-Y.txt
2023-06-07 11:30:55 -0400 < acdw> nicew
2023-06-07 11:32:47 -0400 < cow_2001> https://0x0.st/Hc-E.txt
2023-06-07 11:32:51 -0400 < cow_2001> org source
2023-06-07 12:33:44 -0400 < cow_2001> im learnding! https://youtu.be/nsp72Bx4o8s
2023-06-07 12:51:43 -0400 < hexology> does anyone here know how to keep gauche in "gauche mode" and not "r7rs mode" when importing srfi modules? `(import (srfi 13))` seems to kick it into "r7rs mode" no matter what i do. maybe i'm misreading the docs here
2023-06-07 12:52:33 -0400 < wasamasa> is there any downside to enabling r7rs mode?
2023-06-07 12:52:39 -0400 < wasamasa> I've enabled it manually for a project
2023-06-07 12:53:00 -0400 < hexology> mostly it's annoying in the repl
2023-06-07 12:53:17 -0400 < hexology> because then i have to remember to re-import all the gauche stuff
2023-06-07 12:56:14 -0400 < amirouche> first gauche question I read for a... long while
2023-06-07 12:56:16 -0400 < amirouche> :)
2023-06-07 12:56:28 -0400 < hexology> i've been drawn to it as my go-to scheme now
2023-06-07 12:56:43 -0400 < amirouche> fwiw, I rely on rlwrap
2023-06-07 12:56:52 -0400 < amirouche> It is unclear what R7RS repl will entice
2023-06-07 12:57:18 -0400 < amirouche> sorry, what is the difference between r7rs mode, and gauche mode?
2023-06-07 12:57:36 -0400 < wasamasa> r7rs requires reimporting gauche things apparently
2023-06-07 12:57:48 -0400 < hexology> if you run `gosh` and type `(import (srfi 13))` then it assumes you want to be strictly r7rs compliant, and all the extra gauche functions that would normally be available are now hidden in the gauche.base module which you need to import
2023-06-07 12:58:00 -0400 < hexology> it's a small annoyance
2023-06-07 12:58:46 -0400 < amirouche> Zipheir: I was expecting it, nowadays Python has a `match` that makes nanopass approach possible
2023-06-07 12:58:56 -0400 < amirouche> but still quiet painful without quasiquote
2023-06-07 12:59:36 -0400 < hexology> nanopass is what chez uses right?
2023-06-07 13:00:06 -0400 < acdw> what's nanopass
2023-06-07 13:01:04 -0400 < amirouche> nanopass is a framework, it means: a compiler architecture with very small pass
2023-06-07 13:01:50 -0400 < amirouche> an example pass can be: (let ((a x) ...) body ...) => ((lambda (a ...) body ...) x ...)
2023-06-07 13:02:44 -0400 < amirouche> look into andy keep scheme to c compiler on github, it was done in one afternoon, and presented at strangeloop
2023-06-07 13:03:13 -0400 < amirouche> it is the framework used in Chez nowadays
2023-06-07 13:03:15 -0400 < acdw> amirouche: ohhh thanks
2023-06-07 13:03:17 -0400 < acdw> cool
2023-06-07 13:04:46 -0400 < amirouche> hexology: sorry, I can't help..
2023-06-07 13:12:04 -0400 < hexology> it's ok, i'll just live with it. r7rs mode is probably better anyway
2023-06-07 13:34:10 -0400 < acdw> I setup my scheme to read a .repl file if it exists
2023-06-07 13:34:35 -0400 < Zipheir> amirouche: Yeah, nanopass without quasiquote sounds annoying.
2023-06-07 13:42:40 -0400 < jcowan> amirouche: I seem to remember that "import" is not the native Gauche term, which is "use".  So perhaps "import" triggers a switch to R7RS so you don't have to do that yourself.
2023-06-07 13:43:02 -0400 < jcowan> hexology: ^^
2023-06-07 13:44:25 -0400 < hexology> jcowan: that was my understanding as well, based on the docs i read this morning. but i couldn't figure out how to "use" an r7rs module,
2023-06-07 13:44:36 -0400 < hexology> aha... it's `(use srfi.13)` and not `(use (srfi 13))`
2023-06-07 13:44:45 -0400 < hexology> thanks!
2023-06-07 13:44:54 -0400 < jcowan> that makes sense, native modules don't have names that are lists.
2023-06-07 13:45:17 -0400 < hexology> i see
2023-06-07 14:26:06 -0400 < mdhughes> hexology: See the gauche-ref, 10.1
2023-06-07 14:27:03 -0400 < mdhughes> You can stick with use, or (select-module user) to go back to normal gauche
2023-06-07 14:27:03 -0400 < hexology> ah, it's right there in front of my face. i was reading that doc earlier but i missed the "use" example: (use mylib.foo)
2023-06-07 14:27:12 -0400 < hexology> ty
2023-06-07 17:34:05 -0400 -!- andydude1 is now known as andydude
2023-06-07 19:34:50 -0400 < cow_2001> okay, some insertion sort
2023-06-07 19:35:31 -0400 < cow_2001> speaking of sorts https://www.deepmind.com/blog/alphadev-discovers-faster-sorting-algorithms
2023-06-07 19:36:15 -0400 < cow_2001> corman's here. https://codeberg.org/yuvallangerontheroad/im-learnding-corman4/src/branch/master/a.org
--- Day changed Thu Jun 08 2023
2023-06-08 08:08:18 -0400 < cow_2001> i don't get this initialisation, maintenance, and termination non-changing attributes thing. i understand they are used in induction arguments
2023-06-08 08:09:11 -0400 < cow_2001> i am sinning with imperative cormen (yes, it is cormen, not corman!)
2023-06-08 08:10:56 -0400 < cow_2001> in insertion sort, A[1:i-1] was always sorted before and A[1:i] always sorted after the outer loop
2023-06-08 08:12:50 -0400 < cow_2001> in the first iteration (it iterated i = 2 to n) A[1:i-1] is trivially sorted, because it has only one element.
2023-06-08 08:13:31 -0400 < cow_2001> after the last iteration i = n and A[1:i] is sorted, so A[1:n] is sorted
2023-06-08 08:14:17 -0400 < cow_2001> maybe i should keep on reading even if the exercises don't make sense right now? they said it will be more rigorous later on
2023-06-08 11:00:41 -0400 < Zipheir> cow_2001: Reading more is usually a good idea if the exercises aren't making sense.
2023-06-08 11:19:43 -0400 < edgar-rft> I never do exercises, that's why I'm so fat.
2023-06-08 12:31:50 -0400 < saravia> Hi colleges for develop a mvc web project with scheme, what I could use?
2023-06-08 14:33:29 -0400 < amirouche> ah mvc... be back in a minute...
2023-06-08 14:33:38 -0400 < amirouche> I know the saravia is gone.
2023-06-08 14:34:12 -0400 < amirouche> well... pursuing another feature is a lost cause i guess
2023-06-08 14:51:27 -0400 < Zipheir> Model, View, Controller?
2023-06-08 14:54:23 -0400 < amirouche> yes
2023-06-08 14:55:30 -0400 < amirouche> By MVC, they think filling-the-blank-frameworks. I can't blame them.
2023-06-08 14:56:58 -0400 < amirouche> That is representative of large set of users. Users that will be hard to stiff into a creative, hence productive mindset
2023-06-08 14:58:01 -0400 < amirouche> By the way, I tought about a better way to explain good code: a code base for which you have good story.
2023-06-08 14:59:59 -0400 < amirouche> I am thinking about that, because people always fallback to known authoritative words such as "singleton", "functional", "mvc", "entreprise", "facade", "inversion control", "monad", whatever... but the gist of it is: a good story.
2023-06-08 15:00:34 -0400 < amirouche> writing a good story with simple words, that, that is a challenge.
2023-06-08 15:01:46 -0400 < Zipheir> It gives a new meaning to "literate programming".
2023-06-08 15:01:55 -0400 < acdw> literary programming
2023-06-08 15:02:03 -0400 < Zipheir> There we go.
2023-06-08 15:04:44 -0400 < edgar-rft> no littering here please
2023-06-08 15:05:21 -0400 < acdw> how about literaring
2023-06-08 15:06:38 -0400 < amirouche> I reviewed visual programming on github, or programming through visual paradigms thanks to Maciej Godek @ https://github.com/panicz look at grasp, then https://github.com/yairchu/awesome-structure-editors
2023-06-08 15:07:30 -0400 < amirouche> I got into that topic because no-code, low-code beating the sound of awesome recently
2023-06-08 15:07:59 -0400 < edgar-rft> let's practice invisible programming
2023-06-08 15:08:21 -0400  * acdw alreayd is
2023-06-08 15:08:23 -0400 < amirouche> as far as I concerned, I am too much into keyboard, and the text editor to seriouly get into that kind of ui/ux
2023-06-08 15:09:20 -0400 < amirouche> I can understand that margins, border, boxes, etc... may be helpful
2023-06-08 15:09:42 -0400 < gwatt> edgar-rft: ah, a fan of whitespace programming language
2023-06-08 15:10:38 -0400 < Zipheir> amirouche: Most of the "visual" languages I've seen are heavily into OO concepts. I wonder if anyone's done anything more functional-flavored.
2023-06-08 15:10:59 -0400 < Zipheir> Stream processing seems like an easy thing to visualize.
2023-06-08 15:11:07 -0400 < amirouche> re invisible programming, a long time ago, we had serious hard to debug errors, with completly opaque traceback, I was yelling my collegue: "I am certain it is an invisible whitespace!..." my older peer looked at me: "No, it is a sun cosmic radition!"
2023-06-08 15:11:09 -0400 < edgar-rft> OO concepts do not function?
2023-06-08 15:12:27 -0400 < amirouche> Re visual language, what I have in mind is a regular scheme, the only thing that change is the way the user input the code, the language can be anything.
2023-06-08 15:13:36 -0400 < amirouche> re cosmic radition, after much sweat, we discovered that it was a spaceless character...
2023-06-08 15:13:49 -0400 < amirouche> there is an option in emacs to display them
2023-06-08 15:15:26 -0400 < amirouche> e.g. \r is spaceless
2023-06-08 15:15:32 -0400 < Zipheir> Scheme is visual. We have parens and indentation.
2023-06-08 15:16:54 -0400 < amirouche> hey zipher, I got the little learner
2023-06-08 15:16:56 -0400 < acdw> parens <3
2023-06-08 15:17:12 -0400 < acdw> my biggest gripe w clojure and fennel are their usage of []
2023-06-08 15:17:15 -0400 < amirouche> One of the author "thanks" is totally "depressing"
2023-06-08 15:17:15 -0400 < Zipheir> PureData and Max/MSP had some good ideas for visual programming. Objects (procedures, if you prefer) are widgets which you can open to see the gory details. That's a nice concrete way to think of abstraction.
2023-06-08 15:17:35 -0400 < Zipheir> amirouche: Ah, glad to hear you got it.
2023-06-08 15:18:35 -0400 < amirouche> "To the shinning stars in my life, [...]. Without you there would only be darkness" - Anurarg
2023-06-08 15:18:58 -0400 < amirouche> s/Anurarg/Anurag/
2023-06-08 15:19:20 -0400 < amirouche> I only got it to make the sales go up ;)
2023-06-08 15:20:53 -0400 < gwatt> lego mindstorms was probably one of the more successful visual programming platforms
2023-06-08 15:21:31 -0400 < Zipheir> Right, that was a good one.
2023-06-08 15:21:50 -0400 < acdw> mindstorms ' rocked
2023-06-08 15:23:16 -0400 < gwatt> I wish I had had one. It seemed super cool
2023-06-08 15:23:39 -0400 < acdw> i think i had one? pretty sure. i had the OG big yellow brick boi tho
2023-06-08 15:23:49 -0400 < amirouche> that definitly looks pretty
2023-06-08 15:25:06 -0400 < Zipheir> I wonder whether they were named after https://en.wikipedia.org/wiki/Mindstorms_(book)  It seems like the kind of toy that Papert would've liked.
2023-06-08 15:25:47 -0400 < Zipheir> Oh, apparently they were.
2023-06-08 18:07:08 -0400 < tomhg> wasamasa: In case you would like to receive second opinions prompting it here would be a good idea. At least I would like to look into it. It's just a json lib.
2023-06-08 18:09:15 -0400 < tomhg> Sorry, I intertwened the comments. its was meant to mdhughes. Nonetheless, I agree with your standpoint, wasamasa.
2023-06-08 18:13:56 -0400 < tomhg> https://www.youtube.com/watch?v=tRaq4aYPzCc *bye*
2023-06-08 19:31:23 -0400 < acdw> are there any srfis defining heredoc -like formatting a la chicken #<<end forms?
2023-06-08 19:36:46 -0400 < Zipheir> acdw: SRFI 109 describes that https://srfi.schemers.org/srfi-109/srfi-109.html
2023-06-08 19:36:55 -0400 < Zipheir> I had to look it up.
2023-06-08 19:37:24 -0400 < Zipheir> The syntax is not as sh-y as CHICKEN's.
2023-06-08 19:39:34 -0400 < edgar-rft> is "sh-y" intentionally ambiguous? :-)
2023-06-08 19:39:55 -0400 < acdw> oo thanks
2023-06-08 19:41:23 -0400 < Zipheir> edgar-rft: Now that you mention it...
2023-06-08 19:44:37 -0400 < acdw> lol
2023-06-08 20:29:29 -0400 < cow_2001> Although we typically do not concern ourselves with precision for floating-point values in this book (many numbers cannot be represented exactly in floating point), precision is crucial for most applications. "many numbers cannot be represented exactly in floating point"
2023-06-08 20:29:41 -0400 < cow_2001> such an understatement
2023-06-08 21:30:07 -0400 < Zipheir> Reminds me of https://www.volkerschatz.com/science/float.html
2023-06-08 21:45:23 -0400 -!- fkinjoe is now known as money
2023-06-08 22:31:22 -0400 -!- money is now known as Guest2048
--- Day changed Fri Jun 09 2023
2023-06-09 03:14:15 -0400 < mdhughes> You can't grep a "visual structure editor". All the existing text tools work on plain text code.
2023-06-09 03:15:00 -0400 < mdhughes> Ah, previously: https://mdhughes.tech/2017/10/25/the-future-of-programming-is-text/
2023-06-09 07:19:00 -0400 < sham1> Almost no numbers can be represented accurately with floats
2023-06-09 07:19:24 -0400 < sham1> And in this case "almost no" is the technical term
2023-06-09 07:28:10 -0400 < mdhughes> In an infinite number scale, that's true, but all integers from -(2^52) to 2^52 can, and binary fractions while you take away bits from the mantissa, so on a Human scale it handles most numbers fine. Just not decimal fractions.
2023-06-09 07:28:58 -0400 < mdhughes> This is why Metric was a mistake. We should only measure things in traditional units, and 1/2, 1/4, 1/8 etc. fractions.
2023-06-09 07:32:00 -0400 < wasamasa> I think the Babylonians were on to something
2023-06-09 07:32:15 -0400 < mdhughes> Society would be improved if we didn't count on thumbs, and switched to octal. Hex requires taking off your shoes, and anyway you'd have to put A-F on keypads. Octal just requires pulling the useless 8 & 9 keys.
2023-06-09 07:33:02 -0400 < mdhughes> Base 60 is entirely reasonable.
2023-06-09 07:33:52 -0400 < mdhughes> But it doesn't represent well in IEEE numbers, so they should've used base 64 instead.
2023-06-09 07:34:07 -0400 < mdhughes> Or as I call it, 100
2023-06-09 08:12:59 -0400 < dpk> metric was indeed a mistake
2023-06-09 08:13:01 -0400 < dpk> it should have been based on powers of 12 or, indeed, 60
2023-06-09 08:13:17 -0400 < dpk> as superior highly composite numbers
2023-06-09 08:13:37 -0400 < dpk> as opposed to 10, which is a semiprime
2023-06-09 08:13:44 -0400 < acdw> 6
2023-06-09 08:15:36 -0400 < dpk> whether you should complain to God for giving us 10 fingers instead of 12, the ancient Indians for choosing a base 10 numeral system, or Lavoisier for making the actual measurement system based on 10s instead of 12s, is your choice
2023-06-09 08:35:40 -0400 < sham1> Number bases literally don't matter
2023-06-09 08:42:06 -0400 < mdhughes> They do, if you work in decimal, or base 13, or any other dumb non-binary base, you'll often choose arbitrary numbers not cleanly representable in binary.
2023-06-09 09:01:34 -0400 < acdw> base-12 metric.... what would we call it? tetric? dozetric? the mind boggles
2023-06-09 09:52:23 -0400 < acdw> tantric?
2023-06-09 10:20:51 -0400 -!- mirai_ is now known as mirai
2023-06-09 11:03:39 -0400 < gwatt> If we used it by default we'd obviously call it base-10
2023-06-09 11:04:05 -0400 < unpx> Hello there, is there a scheme to html converter like gnathtml?
2023-06-09 11:15:01 -0400 < wklew> unpx: SXML: https://okmij.org/ftp/Scheme/SXML.html
2023-06-09 11:19:24 -0400 < jcowan> "base" has two meanings, unfortunately: the reprsentation base, which controls which fractions are terminating and which are not, and the exponent base, which is more fundamental
2023-06-09 11:30:26 -0400 < gwatt> are those not the same base?
2023-06-09 11:35:37 -0400 < unpx> wklew: if you are saying ``build it yourself'', then yes, thank you, I did know that option
2023-06-09 11:38:10 -0400 < Zipheir> Something like Slatex with HTML output? https://github.com/racket/slatex
2023-06-09 11:39:00 -0400 < Zipheir> Even Racket seems to lake an HTML pretty-printer.
2023-06-09 11:39:08 -0400 < Zipheir> Argh, s/lake/lack/
2023-06-09 11:46:21 -0400 < civodul> unpx: check out https://dthompson.us/projects/guile-syntax-highlight.html
2023-06-09 12:04:33 -0400 < unpx> civodul: fancy, but that's not even half of the work I guess
2023-06-09 12:04:45 -0400 < unpx> Will keep it in mind tho
2023-06-09 12:09:41 -0400 < Zipheir> "It can parse code written in various programming languages into a simple s-expression that can be easily converted to HTML" What's missing?
2023-06-09 12:10:21 -0400 < Zipheir> Granted that syntax highlighting for Scheme is difficult to do well.
2023-06-09 12:17:48 -0400 < amirouche> unpx: look at scribble
2023-06-09 12:18:10 -0400 < amirouche> if it is a documentation generator that you are looking for
2023-06-09 12:24:34 -0400 < unpx> Zipheir: hyperlinks to definitions for example
2023-06-09 12:47:05 -0400 < Zipheir> unpx: That would be a big project if you want to do it right.
2023-06-09 12:47:48 -0400 < Zipheir> I mean, with taking lexical scope fully into account.
2023-06-09 12:57:47 -0400 < unpx> Zipheir: indeed, but I hate sitting with "good enough" approximations of tools
2023-06-09 13:38:53 -0400 < Zipheir> So it's really a Scheme -> HTML compiler, since you'll need the semantic info to be able to link names to bindings.
2023-06-09 13:39:11 -0400 < Zipheir> I wonder if an existing compiler could be repurposed for this.
2023-06-09 15:25:58 -0400 < gwatt> Probably. If the implementation tracks source locations, I think you could modify the existing define forms to optionally spit out some documentation as well
2023-06-09 16:03:02 -0400 < mirai> What are the "must read" manuals/docs/… for someone learning (guile) Scheme? I can do some basic things with it but tbh I don't really know the "standard catalog" of procedures available save for a few from muscle memory
2023-06-09 16:10:12 -0400 < acdw> guile's info manual is good
2023-06-09 16:10:25 -0400 < acdw> r5rs, r6rs, and r7rs specs too
2023-06-09 16:15:18 -0400 < Zipheir> mirai: As acdw says, the RnRS reports are important. TSPL is a good reference for R6RS https://www.scheme.com/tspl4/
2023-06-09 16:16:02 -0400 < Zipheir> Springer & Friedman did a good practical intro to Scheme, _Scheme and the Art of Programming_, that is not available online, unfortunately.
2023-06-09 16:16:29 -0400 < Zipheir> The Seasoned Schemer covers similar stuff, though the Little Book style is not for everyone.
2023-06-09 16:19:24 -0400 < Zipheir> I would still like to add a lot of practical "standard catalog" info to the Scheme Wikibook.
2023-06-09 17:22:57 -0400 < mirai> acdw, Zipheir: thanks!
2023-06-09 17:27:35 -0400 < mwnaylor> General to specfic; are r[576]rs specs good for Racket as well?
2023-06-09 17:39:16 -0400 < Zipheir> mwnaylor: It depends, since Racket is a language factory. Certainly R6RS is a good reference for #!r6rs. But the reports won't cover #lang racket.
2023-06-09 17:39:18 -0400 < acdw> I think Racket is more 6 but I'm not sure
2023-06-09 17:39:55 -0400 < Zipheir> #lang racket is its own thing now.
2023-06-09 17:40:20 -0400 < Zipheir> They broke with Scheme in ditching mutable pairs, among other things.
2023-06-09 17:40:50 -0400 < acdw> ahh
2023-06-09 17:43:33 -0400 < Zipheir> Keyword syntax, too (which would be a nice thing to have in Scheme).
2023-06-09 18:11:36 -0400 < aeth> tbf, what Racket did to Scheme is similar to what Scheme did to Lisp at some point
2023-06-09 18:11:43 -0400 < aeth> idk when, maybe R3RS or so... everything got renamed
2023-06-09 18:12:02 -0400 < aeth> Mostly worked for the better, but sometimes not, e.g. because map is specific to lists, map can't be used for a generic name, unlike in CL, which kept the ugly mapcar but now has a generic map
2023-06-09 18:12:21 -0400 < aeth> on the other hand, SET in CL only exists for historical reasons and yet it still has it
2023-06-09 18:20:16 -0400 < Zipheir> I don't know enough about it, but Racket seems to be going in a non-imperative direction, while Scheme still supports imperative programming when you want it.
2023-06-09 18:43:06 -0400 < aeth> that's actually a newbie trap in Lisp/Scheme, to think that it can't be imperative
2023-06-09 18:44:02 -0400 < Zipheir> That's also a newbie trap in Haskell!
2023-06-09 18:44:14 -0400 < aeth> so easy to assume that your function/procedure bodies can't work in the same way as C or Python or whatever. It's not immediately obvious that you can just put side effects everywhere if you want, especially since it doesn't work in IF without wrapping your procedural stuff (although it does in COND)
2023-06-09 18:44:37 -0400 < aeth> and pretty much all of programming's going to have if/thens
2023-06-09 18:46:47 -0400 < Zipheir> It's more like docta ignorantia, since most programming newbies know imperative idioms if they know anything.
2023-06-09 19:17:15 -0400 < acdw> I have been really enjoying scheme's mix of functional with imperative
2023-06-09 20:25:13 -0400 < Zipheir> Sussman and Steele, in their wisdom, saw that computation is too young to be tied to a single paradigm.
2023-06-09 20:28:44 -0400 < cow_2001> twos complement are 2-adic numbers!
2023-06-09 20:29:29 -0400 < cow_2001> scheme really has all the paradigms
2023-06-09 20:31:28 -0400 < cow_2001> except for compiler driven development(is that how you call a super duper strict compiler telling you that you are wrong all the time?) like in haskell and rustlang
2023-06-09 20:57:15 -0400 < Zipheir> I'd prefer to say it lacks "a compiler which can prove a lot of useful things about your program".
2023-06-09 20:57:34 -0400 < Zipheir> Typed Racket provides some of that.
--- Day changed Sat Jun 10 2023
2023-06-10 01:32:26 -0400 < mdhughes> A compiler which makes you solve one of those logic grid puzzles: If <Collection> is an <Identifier> but an <OrderedSet> cannot contain <Identifier> unless it's also <Codable>…
2023-06-10 01:32:51 -0400 < mdhughes> Suduko Compilers
2023-06-10 01:35:54 -0400 < mdhughes> A compiler which makes you solve the Myst railcart puzzle to compile.
2023-06-10 02:00:08 -0400 < Zipheir> The downside is that you have to understand the properties to be proved. This gets really hard with stacks of types, like the nested monads in most Haskell GUI programs.
2023-06-10 02:01:39 -0400 < Zipheir> Sometimes you understand the computation but not its type.
2023-06-10 02:02:47 -0400 < Zipheir> (Or perhaps you just think you understand it.)
2023-06-10 02:03:33 -0400 < Zipheir> Anyway, good night / morning / etc.
2023-06-10 02:23:59 -0400  * mdhughes waves
2023-06-10 03:49:49 -0400  * amirouche waves
2023-06-10 03:54:11 -0400 < amirouche> great article: "How the strengths of Lisp-family languages facilitate building complex and flexible bioinformatics applications"
2023-06-10 03:54:15 -0400 < amirouche> https://academic.oup.com/bib/article/19/3/537/2769437
2023-06-10 03:55:24 -0400 < amirouche> What is odd is that authors lean toward CL, even if coming from Python, et al. it is easier to learn Scheme
2023-06-10 03:56:28 -0400 < amirouche> readily available libraries are irrelevant when considering foundations for a field of science
2023-06-10 04:37:11 -0400 < mdhughes> Scientists are lazy, and like prepackaged solutions where possible. Which has made half-assed Python libraries very popular.
2023-06-10 04:38:27 -0400 < mdhughes> Julia is trying hard to be the next-gen Python-that-doesnt-suck, but it's so sluggish at start, I dunno if they'll ever overcome bad design decisions.
2023-06-10 04:39:34 -0400 < mdhughes> And Scheme's so fragmented, it's hard to pick one impl for your science projects. Racket, I suppose.
2023-06-10 04:42:06 -0400 < mdhughes> What a scientist needs from a language: Read CSV files, run formulas, generate graphs. I dunno if CL or Racket have CSV, but they can do the other two. Even Chez doesn't have a good graphing solution (install Thunderchez, use Cairo, is not really an answer)
2023-06-10 04:45:34 -0400 < mdhughes> CHICKEN has all the tools, but the compile time is a buzzkill, csi isn't really usable for number-crunching.
2023-06-10 05:52:52 -0400 < Ren[m]> It also has to have documenation, massive propaganda and professors teaching that to students.
2023-06-10 05:54:23 -0400 < aeth> and the generate-your-program-for-you AI needs to support the language
2023-06-10 05:55:13 -0400 < Ren[m]> >install Thunderchez, use Cairo, is not really an answer
2023-06-10 05:55:13 -0400 < Ren[m]> An answer would be something that can be called relatively easy, i.e. a very high level interface and maybe easy to embed into documents, like web or PDFs.
2023-06-10 05:55:52 -0400 < Ren[m]> aeth: That's a different story, since in Lisp that AI is mostly you.
2023-06-10 06:13:40 -0400 < ecraven> chez isn't much use for general floating-point code, as it doesn't have unboxed floats, unless you take care to only use chez-specific floating-point vectors. I believe the racket fork of chez improves upon this, but this change hasn't found its way back into chez proper, as far as I know
2023-06-10 06:14:08 -0400 < ecraven> I'm hoping for SomeOne™ to make a nan-boxed Scheme implementation, to see how that would compare :D
2023-06-10 06:47:39 -0400 -!- Andrew is now known as Andrew_
2023-06-10 06:51:37 -0400  * amirouche bip... bip...sarcasm spotted...
2023-06-10 06:52:23 -0400 < amirouche> Anyway, let's model that problem in terms of Persistent Concurrent Process Theory
2023-06-10 06:55:34 -0400 < amirouche> That is a joke!!
2023-06-10 06:55:42 -0400 < amirouche> erf!!
2023-06-10 07:12:58 -0400 < shawnw> Racket supports unboxing of flonum computations in some circumstances. See https://docs.racket-lang.org/guide/performance.html#%28part._fixnums%2Bflonums%29
2023-06-10 07:13:44 -0400 < shawnw> (Though if you want serious number crunching performance in a scheme, someone needs to brush the dust off of Stalin and maybe add SIMD support to it)
2023-06-10 08:56:09 -0400 < cow_2001> hmm… are you all also familiar with CL?
2023-06-10 09:20:17 -0400 < cow_2001> google has an official lisp teaching repository https://github.com/google/lisp-koans
2023-06-10 09:20:26 -0400 < cow_2001> B€
2023-06-10 10:02:13 -0400 -!- justache- is now known as justache
2023-06-10 10:22:44 -0400 < cow_2001> merge sort is so clever
2023-06-10 10:30:25 -0400 < acdw> I thought those were going to be stories but they're all code 😭
2023-06-10 10:36:36 -0400 < cow_2001> ah there are a bunch of koans by esr, i think, in his bazaar and cathedral or something like that
2023-06-10 10:39:51 -0400 < cow_2001> acdw: https://catb.org/~esr/writings/unix-koans/
2023-06-10 10:43:31 -0400 < cow_2001> acdw: you know real koans are designed to make your brain explode
2023-06-10 10:46:07 -0400 < cow_2001> https://web.archive.org/web/20230608142553/https://catb.org/~esr/writings/unix-koans/ if you want an https that does not make firefox srart the alarm
2023-06-10 10:55:29 -0400 < sham1> The alarm exists for a reason
2023-06-10 10:56:23 -0400 < Zipheir> I'm amazed ESR even has TLS.
2023-06-10 11:24:17 -0400 < Zipheir> I looked through a "scientific Python" textbook my chemist father-in-law got and noticed that (a) scientific, number-crunching Python is flabby and rather verbose, and (b) the numeric/scientific libraries are extensive and very easy to use. It's clearly the last thing that makes Python so popular with scientists.
2023-06-10 11:25:09 -0400 < wasamasa> could the same argument be applied to scheme number crunching?
2023-06-10 11:26:32 -0400 < wasamasa> here's a scheme library for the task: https://gramian.github.io/numerical-schemer.xyz/2022/05/02/matrico.html
2023-06-10 11:30:56 -0400 < Zipheir> Yes, that's a good one. There's also Siskind's linear algebra library, which I can't find. (What happened to CHICKEN's wiki search?)
2023-06-10 11:32:10 -0400 < Zipheir> It's the front-end stuff (graphing etc.) that Scheme usually lacks. I mean, I'd say "emit gnuplot source", but that's too much work for busy scientists.
2023-06-10 11:32:46 -0400 < wasamasa> it was yeeted due to the underlying search engine not cooperating with the SVN-backed wiki repository
2023-06-10 11:33:02 -0400 < wasamasa> which regularly prevented the core contributors from committing new content to that repo
2023-06-10 11:33:05 -0400 < Zipheir> I guess that's not surprising.
2023-06-10 11:33:18 -0400 < wasamasa> it does not help that hyperestraier is unmaintained software
2023-06-10 11:35:40 -0400 < wasamasa> most use of the search engine is for looking up procedures, which is already offered with api.call-cc.org
2023-06-10 11:52:53 -0400 < acdw> cow_2001: lol yep! I was just telling my wife about the ones and I was hoping these were lisp specific
2023-06-10 11:53:15 -0400 < mdhughes> Chez doesn't need to be the fastest math possible, it just needs to be faster than Python.
2023-06-10 11:55:08 -0400 < Zipheir> More expressive than Python it already is.
2023-06-10 11:57:01 -0400 < mdhughes> Graphing with Cairo isn't actually hard, but it really needs a (gnu|julia) plot-equivalent library on top.
2023-06-10 12:08:39 -0400 < cow_2001> acdw: i am at about 190/4487 in cormen4
2023-06-10 12:20:26 -0400 < cow_2001> oh! #+something you see in orgmode is a lisp thing!
2023-06-10 12:26:58 -0400 < acdw> not exactly
2023-06-10 12:27:09 -0400 < acdw> I mean it is but I don't think org is doing it as a lisp thing
2023-06-10 13:32:55 -0400 < cow_2001> acdw: oh.
2023-06-10 13:33:12 -0400 < cow_2001> common lisp looks like a lot of syntax
2023-06-10 13:36:55 -0400 < Zipheir> And Scheme doesn't?
2023-06-10 13:40:31 -0400 < acdw> none of it is really that much syntax I think
2023-06-10 13:41:57 -0400 < Zipheir> Or, if you're an operational semanticist, it's all syntax. :)
2023-06-10 13:42:40 -0400 < acdw> lumper or splitter?
2023-06-10 13:42:51 -0400 < acdw> if youre a Marxist it's all economics!
2023-06-10 16:46:57 -0400 < cow_2001> aaaaa!!! https://spritely.institute/news/scheme-to-wasm-lambdas-recursion.html
2023-06-10 17:27:47 -0400 < acdw> oh yeah ! I want to try this out
--- Log closed Sat Jun 10 20:00:04 2023
--- Log opened Sat Jun 10 20:00:18 2023
2023-06-10 20:00:18 -0400 -!- Irssi: #scheme: Total of 188 nicks [0 ops, 0 halfops, 0 voices, 188 normal]
2023-06-10 20:00:19 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-06-10 21:42:40 -0400 -!- Andrew- is now known as andrewyu
2023-06-10 22:55:28 -0400 -!- Netsplit *.net <-> *.split quits: gabot, bsima
2023-06-10 22:56:03 -0400 -!- Netsplit over, joins: gabot
--- Day changed Sun Jun 11 2023
2023-06-11 08:29:48 -0400 -!- andrewyu is now known as Andrew
2023-06-11 08:29:58 -0400 -!- Andrew is now known as Guest3666
2023-06-11 16:57:20 -0400 < sam-d[m]> just discoverd index.scheme.org a procedure index for the different standards and including SRFIs. In fact it is linked from the SRFI page but I had not noticed before.
2023-06-11 16:58:29 -0400 < sam-d[m]> Does anybody know of an emacs package that builds on this? Seems it has an API designed fot editor usr and the docs provide an example for vim
2023-06-11 21:05:15 -0400 < festerdam> Writers of scheme, how often do you use «values»? Since my childhood I've been taught that a function is something that receives some values, does some calculations and returns a single result. «values» goes against this definition. Is there any reason not to use «values» when convenient?
2023-06-11 21:10:13 -0400 < aeth> from a certain point of view, it's still "one result", just one broken down into multiple return values instead of a data structure
2023-06-11 21:10:27 -0400 < aeth> often with the secondary results being of optional importance
2023-06-11 21:11:13 -0400 < aeth> it's not like something in mathematics that violates the function property where the answer can be a or b or c or d or e or ...
2023-06-11 21:12:17 -0400 < aeth> it's an and
2023-06-11 21:12:55 -0400 < aeth> which is more like in math when the answer is (a, b, c, d, e, ...)
2023-06-11 21:22:10 -0400 -!- AndrewYu is now known as Andrew
2023-06-11 21:36:28 -0400 < festerdam> aeth: Thanks!
2023-06-11 22:00:22 -0400 < mdhughes> I don't use a lot of values, but occasionally div-and-mod is more convenient. (let-values [((a b) (div-and-mod 69 10))] …)
2023-06-11 22:00:35 -0400 < mdhughes> And several file types return values.
--- Day changed Mon Jun 12 2023
2023-06-12 00:18:27 -0400 < jcowan> festerdam: Now you know why Schemers say "procedures" instead of "functions".  A procedure takes several values, does something, and then invokes its continuation (= everything left to do in the program) with *its* values, and so on until you come to a situation where the continuation just exits back to the REPL or the shell or whoever started the program.
2023-06-12 00:19:20 -0400 < jcowan> So we support multiple returns *because* we support multiple arguments.  In ML and Haskell there is only one return value, but then there is only one argument allowed too.
2023-06-12 00:20:11 -0400 < acdw> til!
2023-06-12 00:20:29 -0400 < jcowan> arrgj
2023-06-12 00:20:54 -0400 < acdw> yarrr
2023-06-12 04:30:18 -0400 < lockywolf> wasamasa: have you tried https://elv.sh/ ?
2023-06-12 04:30:27 -0400 < lockywolf> I am tempted by the name
2023-06-12 04:31:18 -0400 < wasamasa> nope
2023-06-12 04:36:06 -0400 < lockywolf> I thought the Scheme use of "procedures" is due to being influenced by Fortran.
2023-06-12 04:37:27 -0400 < lockywolf> Also, wouldn't it be more correct to say that only those procedures which modify neither the environment, nor the arguments are really functions?
2023-06-12 04:38:42 -0400 < lockywolf> (sin x) seems to be a function call, (set! x 1) maybe not so much
2023-06-12 04:40:02 -0400 < lockywolf> I think, in Fortran that is even the definition of a function. procedures can modify their arguments and do not have, strictly speaking, return values, whereas functions cannot modify arguments, but can return a value
2023-06-12 10:26:50 -0400 < amirouche> I like elv.sh website a lot.
2023-06-12 10:28:43 -0400 < amirouche> On an unrelated note, I have put the hand into a bag of dangerous monsters
2023-06-12 10:30:00 -0400 < amirouche> cloning and improving wikibase / wikidata was a piece of cake
2023-06-12 10:34:21 -0400 < amirouche> at last a worthy challenge
2023-06-12 10:34:32 -0400 < amirouche> 😼
2023-06-12 10:35:03 -0400 < acdw> mrow
2023-06-12 10:43:19 -0400 < amirouche> it is related to letloop.cloud
2023-06-12 10:44:53 -0400 < amirouche> a lead explained to me how they use a nocode serverless cloud (sic) to power their [secret] analysis
2023-06-12 10:45:39 -0400 < amirouche> It is a programming environment with a nocode layer on top
2023-06-12 10:57:26 -0400 < mdhughes> Any number of arguments & returns are a function, because an ordered set can be a single item.
2023-06-12 11:01:39 -0400 < mdhughes> Mutability of parameters can't be the discriminator, because Pascal (via Algol) has VAR parameters on FUNCTION as well as PROCEDURE. And Scheme's an Algol.
2023-06-12 11:31:40 -0400 < jcowan> lockywolf: In Fortran the term is "subroutine", and of course all parameters in Fortran are by reference (and no, passing a constant by reference and having the constant modified out from under you was a *bug* in one Fortran compiler, not a consequence of the definition).
2023-06-12 12:37:02 -0400 < lockywolf> "It is permissible to write functions that change the values of their arguments, modify values in modules, rely on local data saved (Section 8.10) from a previous invocation, or perform input/output operations. However, these are known as side-effects and conflict with good programming practice. Where they are needed, a subroutine should be used."
2023-06-12 22:31:54 -0400 -!- Netsplit *.net <-> *.split quits: dan_berg_pub, fluffyballoon, johnjaye, listentolist, sm2n, rudybot, weinholt, ifreund, pinoaffe, jakzale,  (+16 more, use /NETSPLIT to show all of them)
2023-06-12 22:32:13 -0400 -!- Netsplit over, joins: abcdw, pinoaffe, evhan, ifreund
2023-06-12 22:32:16 -0400 -!- Netsplit over, joins: kws, whereiseveryone
2023-06-12 22:32:42 -0400 -!- Netsplit over, joins: fgudin
2023-06-12 22:33:09 -0400 -!- Netsplit over, joins: johnjaye
2023-06-12 22:33:21 -0400 -!- Netsplit over, joins: hexology
2023-06-12 22:33:38 -0400 -!- Netsplit over, joins: cpli, immutable, csepp, dan_berg_pub
2023-06-12 22:33:53 -0400 -!- Netsplit over, joins: fluffyballoon, akarle, sm2n, rudybot
2023-06-12 22:34:07 -0400 -!- Netsplit over, joins: jakzale, casaca, wklew
--- Day changed Tue Jun 13 2023
2023-06-13 10:12:11 -0400 < lockywolf> Is SWIG a good way to generate Guile bindings?
2023-06-13 16:24:52 -0400 < wasamasa> assuming the SWIG support didn't bitrot, certainly worth a try
2023-06-13 16:24:59 -0400 < wasamasa> that happened with CHICKEN
2023-06-13 16:27:50 -0400 < wasamasa> https://swig.org/Doc4.1/SWIGDocumentation.html#Guile_nn1
2023-06-13 21:20:25 -0400 -!- cognemo_ is now known as 042AAA23V
2023-06-13 21:45:26 -0400 -!- daviid`` is now known as daviid
2023-06-13 22:09:15 -0400 -!- m5zs7k_ is now known as m5zs7k
--- Day changed Wed Jun 14 2023
2023-06-14 00:09:45 -0400 -!- sham1_ is now known as sham1
2023-06-14 01:54:04 -0400 < amirouche> a thread about racket at https://emacs.ch/@louis/110536340538491051
2023-06-14 02:11:30 -0400 -!- ecraven- is now known as ecraven
2023-06-14 02:32:17 -0400 -!- buffet1 is now known as buffet
2023-06-14 03:24:29 -0400 < rgherdt> amirouche: thx
2023-06-14 03:37:47 -0400 < lockywolf> Is "Dragon book" a good book for learning parsing? I haven't found a mention of the "pumping lemma" in it, which surprised me.
2023-06-14 03:54:13 -0400 < gascown> Hi, new schemer here, I'm interested in learning the language and becoming a better programmer in general
2023-06-14 04:00:40 -0400 < rgherdt> gascown: hi, welcome
2023-06-14 04:01:59 -0400 < gascown> I just finished watching "The Most Beautiful Program Ever Written" by William Byrd. It made me think how little I actually know
2023-06-14 05:38:14 -0400 < gascown> Why do schemers and lispers in general poke fun at haskellers? I've seen it quite a lot in lectures and such
2023-06-14 05:58:00 -0400 < cow_2001> how do i find stuff in an sxml data structure? hmm
2023-06-14 06:37:18 -0400 < jcowan> gascown: I don't know, do we actually?  https://www.reddit.com/r/lisp/comments/1fj0qf/lisp_vs_haskell/ is "I'm a Haskeller, is Lisp worthwhile?" and the answers are genuinely fair and balanced.
2023-06-14 06:44:00 -0400 < gascown> I don't mean to say they do so maliciously, I was just curious about the existence of some kind of "friendly rivarly" or something
2023-06-14 06:44:25 -0400 < gascown> I'm interested in learning more about CS and programming in general, so my goal is to learn both
2023-06-14 06:45:14 -0400 < mdhughes> Jocks beat up C nerds, C nerds shove Scheme nerds in lockers, Scheme nerds shove Haskel nerds in very tiny lockers.
2023-06-14 06:53:30 -0400 < cow_2001> how do you save s-exps?
2023-06-14 06:54:27 -0400 < rgherdt> cow_2001: write?
2023-06-14 06:54:49 -0400 < cow_2001> write!
2023-06-14 06:54:52 -0400 < cow_2001> thank you!
2023-06-14 06:54:56 -0400 < cow_2001> now, how do i read?
2023-06-14 06:55:17 -0400 < cow_2001> without running arbitrary code
2023-06-14 06:55:52 -0400 < cow_2001> oh, read?
2023-06-14 06:55:57 -0400 < rgherdt> exactly :)
2023-06-14 06:56:31 -0400 < cow_2001> <_<
2023-06-14 06:56:37 -0400 < cow_2001> i feel dumb for even asking this question
2023-06-14 06:59:17 -0400 < cow_2001> gascown: i'm reading this right now https://en.wikipedia.org/wiki/Introduction_to_Algorithms
2023-06-14 06:59:21 -0400 < cow_2001> gascown: slowly
2023-06-14 06:59:32 -0400 < cow_2001> also, too many other books
2023-06-14 06:59:38 -0400 < cow_2001> (slowly)
2023-06-14 06:59:51 -0400 < cow_2001> gascown: https://sr.ht/~kakafarm/learnings/
2023-06-14 07:00:18 -0400 < cow_2001> zipheir recommends Essentials of Programming Languages
2023-06-14 07:00:51 -0400 < cow_2001> a cs phd friend of mine recommended me Introduction to Algorithms
2023-06-14 07:05:28 -0400 < rgherdt> cow_2001: it's not a dumb question. At least in Common Lisp using 'read' to parse user input is a known security issue: https://stackoverflow.com/questions/34813891/how-do-you-securely-parse-untrusted-input-in-common-lisp/34814203#34814203
2023-06-14 07:05:29 -0400 < rudybot> https://teensy.info/wLCqpEI59A
2023-06-14 07:05:43 -0400 < rgherdt> because of read macros
2023-06-14 07:07:38 -0400 < cow_2001> oh!
2023-06-14 07:08:12 -0400 < cow_2001> rgherdt thank you!
2023-06-14 07:15:07 -0400 < acdw> what might be the equivalent in scheme?
2023-06-14 07:15:33 -0400 < acdw> I guess it depends on the implementation..
2023-06-14 07:18:10 -0400 < rgherdt> some Scheme implementations like Guile have reader macros. But in Guile's case, read-eval defaults to #f:
2023-06-14 07:18:20 -0400 < rgherdt> https://paste.debian.net/1282949/
2023-06-14 07:18:38 -0400 < rgherdt> I'm not sure there is a Scheme affected by this like CL
2023-06-14 07:19:44 -0400 < cow_2001> i don't know what read macros are
2023-06-14 07:22:52 -0400 < gascown> cow_2001: I'm going through that same book, got in on paper
2023-06-14 07:23:14 -0400 < cow_2001> wow
2023-06-14 07:23:25 -0400 < cow_2001> i only have epubs
2023-06-14 07:25:19 -0400 < gascown> I like having a full library, next will be compilers and dragons, automata, computability and complexity, and crafting interpreters
2023-06-14 07:25:26 -0400 < gascown> Not in that order
2023-06-14 07:26:57 -0400 < rgherdt> cow_2001: I'm also not really familiar with them. They allow you executing transformations during read time. Since they are more a thing in the CL world where they are standardized, you can read more about it in their literature, for example: https://lisper.in/reader-macros
2023-06-14 07:27:29 -0400 < rgherdt> CHICKEN supports this kind of stuff, but I've never used this feature myself: https://wiki.call-cc.org/man/5/Module%20(chicken%20read-syntax)
2023-06-14 07:28:19 -0400 < gascown> Btw I'm learning Chez Scheme, is it a good enough implementation?
2023-06-14 07:29:09 -0400 < ecraven> it's fine
2023-06-14 07:29:28 -0400 < gascown> dunno why, but I read a "but..."
2023-06-14 07:32:21 -0400 < cow_2001> guile manual: Sometimes you would like to evaluate code that comes from an untrusted party.  The safest way to do this is to buy a new computer, evaluate the code on that computer, then throw the machine away.
2023-06-14 07:35:12 -0400 < gascown> lol
2023-06-14 07:37:29 -0400 < dpk> while ensuring that said computer is also never connected to any other computer
2023-06-14 07:38:55 -0400 < cow_2001> put it in a matriyoshka of faraday cages with its own power generator
2023-06-14 07:39:11 -0400 < cow_2001> reminds me of Fire Upon The Deep
2023-06-14 07:39:17 -0400 < gascown> Which will then be destroyed after the fact
2023-06-14 07:40:10 -0400 < cow_2001> i've seen scientists share their machine learning neural networks using python pickles………
2023-06-14 07:40:46 -0400 < cow_2001> the files are part of a doi publication
2023-06-14 07:42:03 -0400 < cow_2001> (python pickles are a file format that can store arbitrary software, not just inert data structures)
2023-06-14 07:42:48 -0400 < gascown> sounds unsafe af
2023-06-14 07:42:52 -0400 < cow_2001> yes
2023-06-14 07:43:29 -0400 < gascown> Btw why is Lisp so damn addictive?
2023-06-14 07:43:49 -0400 < gascown> I just started and already love it to bits
2023-06-14 07:45:34 -0400 < gascown> exit
2023-06-14 07:46:26 -0400 < cow_2001> o-o
2023-06-14 08:33:19 -0400 -!- ced1 is now known as cedb
2023-06-14 09:07:31 -0400 < cow_2001> aaaaa! (sxml->html (html->sxml html)) is not.. uh.. identity!
2023-06-14 09:54:48 -0400 < sham1> Well it probably constructs a new string and doesn't have useless whitespace and all that
2023-06-14 09:56:54 -0400 < acdw> yeah
2023-06-14 09:57:00 -0400 < acdw> gascown: foreal
2023-06-14 10:39:06 -0400 < Zipheir> cow_2001: I recommend EoPL with some reservations. It's very fun, IMO, but I think it misses the forest for the trees in the end.
2023-06-14 10:40:16 -0400 < Zipheir> In the later parts, I kept thinking of the name of a chapter from The Little Schemer: "What Is the Value of All This?"
2023-06-14 10:43:12 -0400 < Zipheir> EoPL is long on examples and short on unifying insights.
2023-06-14 12:26:45 -0400 -!- 073AAK9LE is now known as oac
2023-06-14 13:25:40 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-14 17:46:29 -0400 < Zipheir> I decided to start a Scheme community on Lemmy, since that fedi-reddit seems to be getting a little bit of traction after the Reddit API debacle. There's nothing there yet. https://lemmy.ca/c/scheme
2023-06-14 17:46:58 -0400 < wasamasa> well, that's cool
2023-06-14 17:47:13 -0400 < wasamasa> any particular reason you picked a maple leaf community?
2023-06-14 17:47:21 -0400 < wasamasa> s/community/instance/
2023-06-14 17:47:22 -0400 < acdw> eyyo
2023-06-14 17:47:22 -0400 < Zipheir> I'm happy enough with the software. It seems to be faster than modern Reddit, and it's easy to search the federated communities.
2023-06-14 17:47:50 -0400 < wasamasa> yeah, I remember looking at lemmy many years ago and it definitely being slower than reddit then
2023-06-14 17:47:56 -0400 < Zipheir> wasamasa: Not really. It had good uptime numbers and a large number of active users.
2023-06-14 17:48:05 -0400 < wasamasa> ok then
2023-06-14 17:48:17 -0400 < wasamasa> since the meme is that Canadians are overly polite, you should be fine
2023-06-14 17:49:06 -0400 < wasamasa> ah yes, my comment was a mere 2 years ago: https://old.reddit.com/r/emacs/comments/hhbqgf/please_give_some_love_to_the_emacs_portal_on/
2023-06-14 17:49:18 -0400 < Zipheir> One wonders how duplicate communities are going to be handled.
2023-06-14 17:49:37 -0400 < wasamasa> I've seen 3 emacs ones so far
2023-06-14 17:49:55 -0400 < acdw> hm i can follow it with lemmy.ca/c/scheme but not !scheme@lemmy.ca, which is what they say to search for
2023-06-14 17:50:48 -0400 < Zipheir> wasamasa: Amusingly, that post might have been blocked as spam if it were made this week.
2023-06-14 17:51:10 -0400 < Zipheir> Reddit seems to have temporarily gone full Elon (or full Andrew Lee) on Lemmy mentions.
2023-06-14 17:51:24 -0400 < Zipheir> acdw: Hmm...
2023-06-14 17:51:39 -0400 < acdw> i followed the former from my masto account tho!
2023-06-14 17:51:49 -0400 < Zipheir> Well it's cool that that works.
2023-06-14 17:51:56 -0400 < acdw> i tried to @ the thing but it didn't post i dont think
2023-06-14 17:54:55 -0400 < Zipheir> acdw: It seems that communities aren't propagated until at least one person (other than the founder, I guess) subscribes. https://lemmy.ca/comment/286299
2023-06-14 17:55:03 -0400 < acdw> oh huh
2023-06-14 17:55:10 -0400 < acdw> oh like on the instance
2023-06-14 17:55:10 -0400 < wasamasa> yeah, that smells a lot like mastodon and friends
2023-06-14 17:55:35 -0400 < acdw> oh that's federation yeah
2023-06-14 17:55:46 -0400 < acdw> maybe i'll try again in 1/2 hour
2023-06-14 17:56:16 -0400 < acdw> it's also possible that glitch.soc (fork i'm actually using) doesn't uhm, search .. rght... or seomthing
2023-06-14 17:57:30 -0400 < acdw> oh now i have a /follow request/ in to @scheme@lemmy.ca
2023-06-14 17:59:27 -0400 < Zipheir> Odd. Well, it's a new beast.
2023-06-14 17:59:48 -0400 < acdw> yeah
2023-06-14 18:21:51 -0400 -!- ced1 is now known as cedb
2023-06-14 18:22:03 -0400 < cedb> i just googled for a while and couldnt find like
2023-06-14 18:22:19 -0400 < cedb> any kind of research on theory for interactive documents
2023-06-14 18:22:39 -0400 < cedb> sure theres FP and some type systems for frontend dev
2023-06-14 18:23:11 -0400 < cedb> but im wondering if theres any  formal systems for describing a UX at a level of abstraction that makes sense
2023-06-14 18:24:34 -0400 < cedb> cause like react components? i dont see how those semantics can be made sensible
2023-06-14 18:25:41 -0400 < wasamasa> have you looked at elm? FRP? CLIM?
2023-06-14 18:26:49 -0400 < cedb> elm just skimmed the docs, FRP yes big rabbithole
2023-06-14 18:26:52 -0400 < cedb> CLIM never heard of
2023-06-14 18:27:11 -0400 < wasamasa> presentational GUI basically
2023-06-14 18:27:25 -0400 < cedb> oh CL
2023-06-14 18:27:53 -0400 < cedb> this is gonna be some retrofuture stuff heh
2023-06-14 18:28:20 -0400 < wasamasa> if you're tired of the formalisms, the ezd paper is fun: https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-91-6.html
2023-06-14 18:28:35 -0400 < wasamasa> or if you want more abstract nonsense: https://dspace.mit.edu/handle/1721.1/44215
2023-06-14 18:29:39 -0400 < wasamasa> I'm not sure formalism is really helpful for this topic
2023-06-14 18:30:01 -0400 < wasamasa> for starters, I'd want something working decently before turning it into a marvel of software engineering
2023-06-14 18:30:12 -0400 < cedb> yay this hp paper look fun
2023-06-14 18:30:35 -0400 < cedb> i inherited an immensely duplicated react codebase
2023-06-14 18:30:44 -0400 < wasamasa> here's a port of the old code to a slightly less old scheme: https://www.upyum.com/cgit.cgi/ezd/tree/
2023-06-14 18:31:13 -0400 < cedb> like meme level, but
2023-06-14 18:32:02 -0400 < cedb> as im reasoning about it, im not sure how to conceptualize for myself the thing cause datatypes in ML stuff is one thing, but document structure + event handlers?
2023-06-14 18:32:32 -0400 < cedb> its hard to think of anything orthogonal enough besides like network calls
2023-06-14 18:33:52 -0400 < wasamasa> in CLIM, the big idea is that you do not think in terms of widgets, but in terms of a document presented and a rendered responsible for drawing it
2023-06-14 18:33:56 -0400 < wasamasa> *renderer
2023-06-14 18:34:27 -0400 < cedb> right the actual "meaningful" processing is decoupled
2023-06-14 18:35:01 -0400 < wasamasa> https://mcclim.common-lisp.dev/ is a FLOSS implementation of it
2023-06-14 18:41:03 -0400 < cedb> is CL streams
2023-06-14 18:41:11 -0400 < cedb> can you do incremental computation with that?
2023-06-14 18:42:04 -0400 < cedb> cause FRP intuitively looks like the "right" model but at a very low level
2023-06-14 18:42:11 -0400 < Zipheir> cedb: It's an interesting topic. Functional reactive programming seems like the right way to think about it, to me.
2023-06-14 18:42:36 -0400 < cedb> Zipheir: its just immensely complex, which ironically is why some "backend" devs think its simple and theyre above it
2023-06-14 18:42:39 -0400 < Zipheir> Provided it's the "real" FRP with continuous time that Conal Elliott described.
2023-06-14 18:43:31 -0400 < Zipheir> Yes, it's hard.
2023-06-14 18:44:51 -0400 < cedb> continuous time might be a bit much but yeah conal elliott im not
2023-06-14 18:45:03 -0400 < cedb> gonna sit here and pretend i know what this guy means when he talks
2023-06-14 18:45:38 -0400 < Zipheir> Elliott went so far as to say that continuous time was *the* idea in functional reactive programming, as he saw it. But I think it was the first thing that most implementations threw out.
2023-06-14 18:45:55 -0400 < cedb> "we just need that little ghc extension"
2023-06-14 18:46:02 -0400 < cedb> and now look its simple
2023-06-14 18:46:39 -0400 < Zipheir> He discussed the whole thing in 2015. He's a good speaker and there's very little functional jargon. https://www.youtube.com/watch?v=j3Q32brCUAI&pp=ygURZWxsaW90dCBsYW1iZGFqYW0%3D
2023-06-14 18:46:45 -0400 < cedb> i mean for continuous time he seems to really wanna make a full categorical ontology of programming
2023-06-14 18:46:55 -0400 < cedb> in general
2023-06-14 18:47:14 -0400 < cedb> Zipheir: the absence of jargon is the trap though lol
2023-06-14 18:47:57 -0400 < Zipheir> I don't think so, but I'm not sure what you mean. Usually the jargon is the trap. ("the smatterer in science thinks that by using hard words he shows that he understands hard things")
2023-06-14 18:48:05 -0400 < cedb> right in the talk he mentions differentiation thats what i had in mind
2023-06-14 18:48:34 -0400 < cedb> the trap in the sense you read/listen, think you understand and then you try to actually explain it to yourself and you realize
2023-06-14 18:48:37 -0400 < Zipheir> He did a similar discussion of functional graphics, and there, too, (spatial) continuity was crucial.
2023-06-14 18:49:06 -0400 < cedb> cause he did : compiling to categories for hardware design, differentiable programming, FRP
2023-06-14 18:49:36 -0400 < cedb> so clearly theres sort of general trend he has thats pretty wildly ambitious
2023-06-14 18:50:01 -0400 < Zipheir> He's one of my computational heroes. I sent him some questions about "denotational design" a while back, but I never heard anything back.
2023-06-14 18:50:18 -0400 < cedb> in the sense being able to do   all those things fluently would be like
2023-06-14 18:50:32 -0400 < cedb> superr futuristic to me
2023-06-14 18:50:57 -0400 < Zipheir> He applies category theory and semantics to make things *easier* to understand. :)
2023-06-14 18:51:05 -0400 < cedb> Zipheir: hes literally asking for people to come play with him lol https://github.com/conal/Collaboration
2023-06-14 18:51:09 -0400 < cedb> if you wanna chat
2023-06-14 18:51:14 -0400 < Zipheir> Oh, cool.
2023-06-14 18:52:04 -0400 < cedb> im just imagining a differentiable FPGA that can optimize itself with gradient descednt
2023-06-14 18:53:40 -0400 < cedb> tbh i just wanna gradient descent all programs, its silly that deep learning is so mature and were not out here doing load testing on web servers and tweaking/tuning parameters
2023-06-14 18:53:55 -0400 < cedb> s/were not/were/
2023-06-14 18:55:38 -0400 < wasamasa> what does load testing have to do with that?
2023-06-14 18:59:25 -0400 < cedb> well its pretty well defined with clear metrics to tune something like that
2023-06-14 18:59:32 -0400 < cedb> compared to e.g. UI
2023-06-14 19:00:04 -0400 < wasamasa> I still don't get it
2023-06-14 19:00:32 -0400 < wasamasa> with load testing I associate testing whether a web server is unsuited to withstand real-world traffic or not
2023-06-14 19:01:12 -0400 < cedb> the link is that tuning parameters is something a dumb gradient descent can do
2023-06-14 19:01:30 -0400 < cedb> if you have a way to generate data and clear metrics
2023-06-14 19:01:31 -0400 < wasamasa> is that something confined to papers or an actual thing?
2023-06-14 19:01:50 -0400 < cedb> my personal take on what AI should be
2023-06-14 20:55:40 -0400 -!- aeth_ is now known as aeth
2023-06-14 22:06:09 -0400 < mdhughes> Zipheir: OK, I'm cross-subbed to !scheme@lemmy.ca from lemmy.ml, not seeing any posts yet?
2023-06-14 22:10:04 -0400 < mdhughes> Oh, nvm, hitting home & back in shows a few posts now.
2023-06-14 23:13:01 -0400 < mdhughes> Correction: I was seeing https://lemmy.ml/c/scheme which does have posts. Lemmy's UI for where a sub comes from is not great.
2023-06-14 23:14:46 -0400 < Zipheir> Oh, I guess there's already a Scheme community on lemmy.ml which has posts...
2023-06-14 23:18:01 -0400 < Zipheir> Yeah, I wonder how they're going to handle this duplicate-sublemmy (?) problem.
2023-06-14 23:19:38 -0400 < Zipheir> And it seems I can't cross-sub to !scheme@lemmy.ml  Hmm.
2023-06-14 23:21:36 -0400 < Zipheir> lemmy.ml, being FOSS-themed, does seem like a good place for the Scheme community.
2023-06-14 23:22:52 -0400 < mdhughes> You can search & sub across servers, but it's so weird.
2023-06-14 23:23:12 -0400 < Zipheir> Yeah, I'm figuring that out, now.
2023-06-14 23:23:50 -0400 < mdhughes> What I *want* is USENET-over-activitypub, but it's not that.
2023-06-14 23:25:53 -0400 < Zipheir> Indeed. I don't need all this flashy dynamic-JS-over-Rust stuff.
2023-06-14 23:26:30 -0400 < Zipheir> OK, I finally managed to sub to the lemmy.ml Scheme sublemmy.
2023-06-14 23:26:49 -0400 < mdhughes> And discovery is basically impossible? I've had my lemmy.ml for a year+, but no idea how I'd just browse subs on other servers to join.
2023-06-14 23:27:16 -0400 < mdhughes> I say that, and immediately find: https://lemmyverse.net
2023-06-14 23:27:35 -0400 < mdhughes> Which is a hell of spinning cursors.
2023-06-14 23:28:28 -0400 < Zipheir> I imagine it'll see a lot of changes in the near future with all this attention.
2023-06-14 23:28:35 -0400 < mdhughes> Searching "scheme" finds Shadowrun, crytpocurrency, !scheme@lemmy.ml…
2023-06-14 23:28:38 -0400 < Zipheir> It's a little weird, to be sure.
2023-06-14 23:44:35 -0400 < flatwhatson> scheme hackers mining crypto from their space-cadet tuned cyberdecks
2023-06-14 23:56:38 -0400  * Zipheir looks up tutorials on getting Chez to run on an Ono-Sendai Cyberspace 7
2023-06-14 23:57:02 -0400 < aeth> lemmy's Ui in general is not great
2023-06-14 23:57:09 -0400 < aeth> we have Old Reddit, why not just copy one of the better custom CSSes for it
2023-06-14 23:57:26 -0400 < aeth> there were some good designs, not this half-way-to-New-Reddit stuff
2023-06-14 23:57:53 -0400 < acdw> honestly yeah
2023-06-14 23:58:13 -0400 < acdw> let's make forumug.ly
2023-06-14 23:58:18 -0400 < Zipheir> It would be nice if it were a protocol and you could pick your own UI.
2023-06-14 23:58:56 -0400 < Zipheir> Ditto all of the fediverse stuff, which is too tied to slick JS frontends for my taste.
2023-06-14 23:59:04 -0400 < aeth> well, lemmy's devs are authoritarian so it's surprising they even made it federated instead of just having one instance that will ban you for your right-of-Stalin (or left-of-Stalin) politics
2023-06-14 23:59:51 -0400 < Zipheir> Well, at least we know we can talk about Stalin there.
2023-06-14 23:59:53 -0400 < mdhughes> If you don't want so much JS & UI in your fediverse, there's https://brutaldon.org/about
--- Day changed Thu Jun 15 2023
2023-06-15 00:00:31 -0400 < mdhughes> I haven't looked at Lemmy's API, but ActivityPub's easy enough to build any client you want for.
2023-06-15 00:00:50 -0400 < aeth> ActivityPub looks oriented to Twitter clones so it's kind of impressive they made a Reddit clone out of it
2023-06-15 00:01:02 -0400 < mdhughes> So presumably you can just make your own client and talk to all Lemmy/Kbin/Behaw/etc.
2023-06-15 00:01:06 -0400 < Zipheir> mdhughes: Interesting.
2023-06-15 00:01:17 -0400 < Zipheir> Yeah, I should read the docs and stop kvetching.
2023-06-15 00:01:19 -0400 < aeth> but the fediverse seems doomed to have its content be lost forever, almost as bad as Discord... they're e.g. usually opposed to indexing
2023-06-15 00:01:37 -0400 < mdhughes> AP's not *that* twitter-like. It's mostly just notes-passing, so it could be USENET, or live chat, or an updating whiteboard, or whatever.
2023-06-15 00:01:59 -0400 < aeth> eww, ActivityPub JSON-style chat
2023-06-15 00:02:05 -0400 < mdhughes> Sure, fedi is for conversation, and people mostly don't want their conversations archived.
2023-06-15 00:02:23 -0400 < aeth> maybe as a r/all replacement because nobody cares about those memes, but for programming stuff, having an archive seems nice
2023-06-15 00:02:32 -0400 < mdhughes> I do hashtag & bookmark & link all my perma-content, but really that should go on my blog.
2023-06-15 00:02:47 -0400 < aeth> and Reddit's whole redesign optimized for trash r/all memes over stuff like r/programming and r/lisp and r/scheme, which 5 years later are mostly dead now
2023-06-15 00:03:46 -0400 < aeth> The Reddit clone that imo has the most potential is https://tildes.net/ but they probably will be too slow to have arbitrary groups so not everyone will move over
2023-06-15 00:04:10 -0400 < Zipheir> In the ten years I spent between leaving Twitter and trying Mastodon, hashtags seem to have been mostly abandoned.
2023-06-15 00:04:12 -0400 < aeth> heh, already the quality is way worse than a few days ago. post #1 UFOs, post #2 Trump, ...
2023-06-15 00:04:36 -0400 < mdhughes> I'm no longer willing to engage in siloed content.
2023-06-15 00:05:07 -0400 < mdhughes> If it's not an open network, it's dead to me. So Lemmy & fediverse have potential, blogs are personal content only.
2023-06-15 00:05:49 -0400 < mdhughes> Also there's tilde.town and other "real tildes", which are very different from this "tildes"; they're shared Unix servers.
2023-06-15 00:06:05 -0400 < aeth> well, the fediverse reminds me of Minecraft servers back in the early 2010s... if you build cool stuff on it it'll just get lost to time as servers go down so the only way to do anything is to host a server yourself
2023-06-15 00:06:19 -0400 < aeth> but, yes, the branding is bad for tildes because I have several different tilde websites in my history
2023-06-15 00:06:31 -0400 < aeth> you need to make up a word like reddit
2023-06-15 00:06:40 -0400 < Zipheir> Part of the way to get rid of siloing is moving back to protocols. See, e.g. https://knightcolumbia.org/content/protocols-not-platforms-a-technological-approach-to-free-speech
2023-06-15 00:07:19 -0400 < Zipheir> aeth: "the only way to do anything is to host a server yourself"  Which will probably also get lost to time.
2023-06-15 00:07:27 -0400 < aeth> absolutely
2023-06-15 00:07:39 -0400 < mdhughes> Some of it gets on archive.org
2023-06-15 00:07:45 -0400 < Zipheir> "Hosting things on random people's servers is part of the Curse of Lisp." --jcowan
2023-06-15 00:07:45 -0400 < aeth> I agree with you that it should be more about protocols than federation
2023-06-15 00:07:59 -0400 < aeth> idc if some random web forum is federated or not (you can just have "log in with <whatever>" anyway if that's what you want)
2023-06-15 00:08:12 -0400 < aeth> Firefox makes it easy to generate random passwords for accounts these days
2023-06-15 00:08:23 -0400 < mdhughes> Maybe not every byte that spills from my keyboard is holy writ to be saved for eternity until Roko's Basilisk can do nothing but stand in awe of me.
2023-06-15 00:08:25 -0400 < aeth> Reddit (at least in the old days) doesn't even require an email, so easy to sign up
2023-06-15 00:08:39 -0400 < aeth> mdhughes: nah, alternate approach would be to make sure archive.org crawls every post
2023-06-15 00:08:52 -0400 < aeth> save everything for eternity
2023-06-15 00:09:14 -0400 < aeth> I'd much rather use an archived centralized site so the content stays around even after the site dies
2023-06-15 00:09:33 -0400 < Zipheir> aeth: Yeah. I think federation is fine, provided power doesn't go to people's heads.
2023-06-15 00:09:55 -0400 < aeth> idk
2023-06-15 00:10:17 -0400 < aeth> I'm absolutely going to create an aethism forum on my Reddit clone (federated or not) and let power get to my head
2023-06-15 00:10:39 -0400 < Zipheir> "Be the God of your own r/atheism"
2023-06-15 00:11:09 -0400 < aeth> r/atheism for the past few months was basically just complaining about "He Gets Us" adds in the Reddit app so maybe I should just make the f/aethism slogan "Aeth Understands You"
2023-06-15 00:12:19 -0400 < mdhughes> Hilariously, I never saw those ads.
2023-06-15 00:12:51 -0400 < mdhughes> At some point reddit quit advertising to me, probably because I blocked & reported every slightly off-topic advertiser.
2023-06-15 00:12:51 -0400 < aeth> well, yeah, me neither, because I use old.reddit.com on desktop and mobile. with adblocking
2023-06-15 00:13:07 -0400 < aeth> although old reddit is probably dead next
2023-06-15 00:13:18 -0400 < aeth> as for blocking advertisers, apparently that doesn't work anymore
2023-06-15 00:13:27 -0400 < aeth> so... you did it early enough for it to work
2023-06-15 00:14:20 -0400 < mdhughes> There is an https://lemmy.ml/c/atheism
2023-06-15 00:14:59 -0400 < aeth> of course there is, because the main lemmy instance is run by capital-C Communists of the edgy teenage tankie kind.
2023-06-15 00:15:19 -0400 < aeth> apparently if you criticize the government of China there, they'll ban you for racism
2023-06-15 00:15:46 -0400 < Zipheir> Reddit is clearly going down Cory Doctorow's spiral.
2023-06-15 00:16:48 -0400 < aeth> well, the political stuff on Reddit has been very bad for a while now
2023-06-15 00:17:56 -0400 < Zipheir> You mean the political content or the corporate vs community politics?
2023-06-15 00:18:04 -0400 < mdhughes> I don't see how any of those are related, but also haven't seen any evidence of them being tankies. They refused to delete some conversation.
2023-06-15 00:19:12 -0400 < mdhughes> But I have negative interest in r/politics circlejerks. Off somewhere else with that.
2023-06-15 00:19:18 -0400 < aeth> e.g. https://news.ycombinator.com/item?id=36241849
2023-06-15 00:19:33 -0400 < mdhughes> I don't read "h4xx0r n00z", which is neither.
2023-06-15 00:19:47 -0400 < aeth> I can't find the HN comment that specifically linked to lemmy.ml where they basically responded to "where is criticism of China against the rules?" with "it's there on the rules under 'no racism'", though
2023-06-15 00:20:25 -0400 < aeth> maybe it's referring to this thread: https://lemmy.ml/post/1167199
2023-06-15 00:20:54 -0400 < Zipheir> Well, anyway.
2023-06-15 00:21:14 -0400 < Zipheir> We'll have to see if Lemmy, etc. go anywhere.
2023-06-15 00:21:26 -0400 < aeth> just a random sample of that page
2023-06-15 00:21:26 -0400 < aeth> >> Most of the people coming to lemmy.ml don’t recognize that calling PRC an genocidal authoritarian dictatorship is wrong.
2023-06-15 00:21:29 -0400 < aeth> > Yeah of course. Most xenophobes and racists think their xenophobia and racism is actually very good. And like you’ve mentioned, they often rationalize it in such a shallow way that they don’t actively label it as xenophobia or racism.
2023-06-15 00:22:27 -0400 < aeth> Reddit's definitely not going to get along with that community considering the general pro-Ukraine/pro-HongKong stance of Reddit
2023-06-15 00:24:09 -0400 < mdhughes> So go start your own right-wing server if you like.
2023-06-15 00:24:14 -0400 < aeth> I'm not right wing.
2023-06-15 00:24:25 -0400 < mdhughes> Again, don't care about r/politics circlejerks.
2023-06-15 00:24:43 -0400 < aeth> I just don't want to associate with people cheering Ukrainian deaths like some of the more edgier tankies (e.g. r/GenZedong before it got quarantined... idk if lemmy is that bad yet, but all internet communities tend to get more extreme over time)
2023-06-15 00:27:31 -0400 < aeth> well, looks like GenZedong moved to lemmygrad.ml instead of lemmy.ml
2023-06-15 00:27:52 -0400 < cedb> maoists are weird
2023-06-15 00:28:27 -0400 < aeth> western pro-PRC Maoists are weirder, considering that China isn't really Maoist anymore and they supress them like any other political movement
2023-06-15 00:28:51 -0400 < cedb> yeah i had in mind western maoists but didnt know context
2023-06-15 00:29:23 -0400 < cedb> its a weird stance to take cause the praxis it entails is so... intense?
2023-06-15 00:29:47 -0400 < cedb> its like being guevarist and living in nyc
2023-06-15 00:30:57 -0400 < cedb> i mean its 2023 just be an anarchist like a normal  person and move on
2023-06-15 00:31:37 -0400 < aeth> I'm just glad they found their own community websites for now, though. One of the things that made Reddit so toxic is the whole "post somewhere, get banned elsewhere" thing that happens when there's a lot of hostile ideologies all hosting subreddits in one site with one shared post history
2023-06-15 00:32:22 -0400 < aeth> the_donald can move to the .win reddit clone and the tankies (mostly Maoists, I guess?) can move to lemmygrad etc. and maybe we can just have programming talk on a completely unrelated site to all of that politics stuff
2023-06-15 00:32:36 -0400 < jcowan> I don't think c.l.s has become more extreme over time, on the contrary.
2023-06-15 00:32:55 -0400 < cedb> i dont see how reddit can be sane, it seems like a tiny weird percentage does the most posting and all the rest are just looking up something
2023-06-15 00:33:22 -0400 < jcowan>  and r/scheme feels to me like an extension of c.l.s
2023-06-15 00:33:41 -0400 < aeth> I don't think r/scheme was large enough or active enough to get extreme and polarized
2023-06-15 00:33:45 -0400 < aeth> or form an upvote/downvote hivemind
2023-06-15 00:34:02 -0400 < aeth> the Reddit format definitely had some major downsides
2023-06-15 00:34:13 -0400 < aeth> the failure mode of usenet was different... seemed to be spam
2023-06-15 00:34:28 -0400 < cedb> i mean r/scheme also had a lot of kids googling FP or something
2023-06-15 00:34:31 -0400 < aeth> Reddit, in trying not to be usenet, handed power to a subreddit's upvote/downvote hivemind and to the moderators
2023-06-15 00:34:47 -0400 < cedb> did they actively design like that
2023-06-15 00:34:51 -0400 < cedb> or was it just another superblog?
2023-06-15 00:35:38 -0400 < cedb> i have this feeling any "social platform" that doesnt have a lot of regular chat but mostly comments is gonna get weird
2023-06-15 00:35:46 -0400 < aeth> reddit kind of seemed like it went for the minimum viable product of a forum site, but then never went in and filled in the forum features, in complete denial of what it was (and New Reddit doubled down on the r/all image memes)
2023-06-15 00:35:59 -0400 < aeth> e.g. no subforums
2023-06-15 00:36:24 -0400 < cedb> wasnt the imgur thing 12 years ago the biggest growth they had
2023-06-15 00:37:06 -0400 < aeth> reddit's algorithm let threads scale more than traditional paginated/linear forum threads (although they decaded quickly unless pinned since you couldn't bump them), but then they stopped there and never really added any features that the old php forums (vbulletin, invision, smf, phpBB) had
2023-06-15 00:37:15 -0400 < aeth> although I guess they eventually added avatars (to sell them as NFTs)
2023-06-15 00:37:32 -0400 < aeth> s/decaded/decayed/
2023-06-15 00:37:53 -0400 < cedb> F
2023-06-15 00:38:05 -0400 < aeth> They probably could've gotten something very Discord-like if they went more into the whole "you are hosting a forum community" thing
2023-06-15 00:38:09 -0400 < cedb> im only a little sad for aaron swartz
2023-06-15 00:38:14 -0400 < aeth> where people could donate to the forum and stuff
2023-06-15 00:38:27 -0400 < cedb> discord is soo shitty though
2023-06-15 00:38:42 -0400 < aeth> yeah, but Discord at least tries to lean into its strengths
2023-06-15 00:38:50 -0400 < aeth> Reddit was in denial the whole time that they were forums instead of social media
2023-06-15 00:39:08 -0400 < cedb> i get irc is not for everyone but do i have to feel like im launching a AAA game when i just want to pop in a chat
2023-06-15 00:39:36 -0400 < aeth> I gave up with Discord a few years back because the whole thing is just optimized for people who live 24/7 on Discord and is awful if you just lurk, unlike Reddit
2023-06-15 00:39:53 -0400 < aeth> And now with no Discord and no Reddit, I guess all I have left is YouTube for keeping up with gaming?
2023-06-15 00:40:13 -0400 < cedb> id say the only sane option is to not keep up with gaming
2023-06-15 00:40:36 -0400 < cedb> i have nothing against it but its the source of an /enormous/ level of toxic crap
2023-06-15 00:40:51 -0400 < aeth> that's why I mostly play single player these days
2023-06-15 00:41:12 -0400 < cedb> games peeked at crash bandicoot anyways
2023-06-15 00:41:28 -0400 < aeth> I also play really old MP games where community servers still exist, instead of throwing everyone in one big matchmaking community where nobody will see anyone else ever again, which I think feeds into the toxicity
2023-06-15 00:41:48 -0400 < cedb> match making is a funny problem
2023-06-15 00:42:01 -0400 < aeth> if only one server has this map in the rotation or runs that mod, then you're not going to be toxic because you can't risk getting banned by the server that's practically 50% moderators
2023-06-15 00:42:26 -0400 < aeth> matchmaking simply can't compete with the moderation of nearly everyone with clan tags potentially having mod/admin powers
2023-06-15 00:42:31 -0400 < cedb> cause the curve is /always/ exponential so if you sell too fast you know noone is gonna be able to play a fun game after 6 months
2023-06-15 00:42:41 -0400 < aeth> in a sense, Reddit's the only thing in the modern internet that relied on community moderating
2023-06-15 00:42:45 -0400 < aeth> maybe Discord
2023-06-15 00:43:00 -0400 < flatwhatson> slashdot is still around
2023-06-15 00:43:31 -0400 < cedb> the internet has mostly been colonized, im not seeing anything "community" like spring up
2023-06-15 00:44:04 -0400 < aeth> I've mostly been reading Hacker News over Reddit in recent years. Wasn't a major change to just remove Reddit entirely a few days ago. HN is basically like Reddit 10 years ago (but only like a few of the more tech related subreddits) while nothing is like HN 10 years ago (but it's against the rules to say this on HN)
2023-06-15 00:44:08 -0400 < cedb> for friends obv it works but i know noone thats not in aprogramming rabbit hole that "knows" people from teh internet
2023-06-15 00:44:30 -0400 < cedb> HN has nuggets
2023-06-15 00:45:20 -0400 < cedb> it can get all buzzwordy fast with nonsense and then an actual contributor to a major RDMS just rolls their sleeves up and just humble a couple of 29 year olds
2023-06-15 00:45:29 -0400 < aeth> I think HN has gotten a little better in quality now that the whole crypto/web3 bubble has mostly passed (the prices still haven't returned to early 2020 prices) because all VCs (including YC) sold their soul to the short term crypto gains
2023-06-15 00:45:41 -0400 < aeth> Although probably a little worse now that Reddit has fallen apart
2023-06-15 00:45:51 -0400 < cedb> YC a soul?
2023-06-15 00:45:59 -0400 < cedb> paul graham is an absolute turd
2023-06-15 00:46:25 -0400 < aeth> the problem is that the Lisp (let alone Scheme) content has decreased dramatically over time on HN, so it's not really a r/lisp, r/scheme, etc. replacement
2023-06-15 00:46:57 -0400 < cedb> scheme is too basic/fundamental to like, fade out
2023-06-15 00:47:01 -0400 < cedb> CL ... idk idk
2023-06-15 00:47:42 -0400 < cedb> its almost funny cause graham et all were touting all them features that CL had that other languages had
2023-06-15 00:47:53 -0400 < cedb> and people instead of joining just...created a lot of new languages lol
2023-06-15 00:48:10 -0400 < aeth> pg oversold CL and sold the wrong parts of CL
2023-06-15 00:48:27 -0400 < aeth> I guess because he went from school to CL startup to effective retirement
2023-06-15 00:48:53 -0400 < cedb> ya thats a comfortable position to be in to give mage advice
2023-06-15 00:49:28 -0400 < cedb> i can say sbcl is an amazing piece of tech, CL can be very fast yes and has an extremely large feature set and still
2023-06-15 00:49:34 -0400 < cedb> i cant see why id use it
2023-06-15 00:50:12 -0400 < mdhughes> There's also https://lobste.rs which is like actual CS nerds forum. It's a little dull for my taste, but I trawl it for links.
2023-06-15 00:50:26 -0400 < mdhughes> And hey, slashdot is still up.
2023-06-15 00:50:48 -0400 < aeth> the problem with lobste.rs is that nobody goes to a link aggregator for the links (especially since they all have the same links as every other one)
2023-06-15 00:51:03 -0400 < aeth> they go for the comments and lobste.rs is strict with the invites
2023-06-15 00:51:06 -0400 < aeth> so there are almost none
2023-06-15 00:51:39 -0400 < cedb> how much content can a lisp community even generate
2023-06-15 00:51:46 -0400 < aeth> depends on if you use AI or not
2023-06-15 00:51:53 -0400 < aeth> rudybot: how much content can you generate?
2023-06-15 00:51:54 -0400 < rudybot> aeth: how much content can a lisp community even generate
2023-06-15 00:51:58 -0400 < aeth> boo
2023-06-15 00:52:02 -0400 < aeth> rudybot: how much content do you have?
2023-06-15 00:52:02 -0400 < rudybot> aeth: put into perspective how much content that is: In 2017, Pornhub transmitted more than the entire contents of the New York Public Library’s 50 million books combined. - https://qz.com/1407235/porn-sites-collect-more-user-data-than-netflix-or-hulu-this-is-what-they-do-with-it/
2023-06-15 00:52:09 -0400 < mdhughes> I have an account, I just don't use it, because boringest nerds in nerddom.
2023-06-15 00:52:59 -0400 < aeth> sounds like scheme.org needs a forum
2023-06-15 00:53:55 -0400 < mdhughes> I have a lobsters account that is. I don't seem to have my slashdot account anymore?
2023-06-15 00:54:09 -0400 < cedb> maybe you can expand it to: programming theory is useful. com
2023-06-15 00:54:20 -0400 < aeth> cedb: btw, #lispgames (it has an IRC channel among other things) is probably where you'd want to use CL more than any other niche... although I don't think it's a majority of Lisp Game Jam submissions
2023-06-15 00:54:35 -0400 < aeth> CL tends to be fairly low level compared to most Lisps
2023-06-15 00:54:39 -0400 < cedb> oh cool i might go lurk
2023-06-15 00:54:43 -0400 < aeth> which helps when you want to e.g. talk to the GPU
2023-06-15 00:55:08 -0400 < cedb> i meant mostly like its pretty big time sink in terms of toolchain
2023-06-15 00:55:14 -0400 < aeth> (it's a good thing #commonlisp is Common Lisp on this network and #lisp is Lisps-in-general. Less confusing than on Freenode that #lispgames isn't specific to CL)
2023-06-15 00:55:46 -0400 < cedb> everytime i try to figure out how to do something in CL i end up understanding and even agreeing
2023-06-15 00:55:53 -0400 < cedb> but damn the road was weirdly long
2023-06-15 00:55:54 -0400 < aeth> mdhughes: hmm, I genuinely don't know if I have a /. account or not. If I did I would've almost certainly forgotten about it and not touched it since 2006
2023-06-15 00:56:00 -0400 < aeth> same wiht just about any other pre-Reddit "social media"
2023-06-15 00:56:12 -0400 < aeth> although I can guarantee that I don't have Something Awful because that one cost money
2023-06-15 00:56:35 -0400 < aeth> cedb: yeah, CL has a lot of historical baggage
2023-06-15 00:56:50 -0400 < cedb> like bloody asdf
2023-06-15 00:56:57 -0400 < aeth> oh, asdf is... weird.
2023-06-15 00:57:05 -0400 < aeth> try to read the source, just try
2023-06-15 00:57:20 -0400 < aeth> It literally uses its own paradigm
2023-06-15 00:57:26 -0400 < cedb> i dont even know how to build a random package tbh
2023-06-15 00:57:41 -0400 < cedb> and thats pretty much my first test of usability
2023-06-15 00:58:01 -0400 < cedb> if i cant build a bunch of things, big red flag
2023-06-15 00:58:12 -0400 < aeth> tbf, in any language the build system stuff is basically mandatory boilerplate and you can only just shift where that boilerplate goes
2023-06-15 00:58:22 -0400 < aeth> you do it once and then copy and paste your one working project as a skeleton forever
2023-06-15 00:58:31 -0400 < cedb> idk man maven?
2023-06-15 00:58:40 -0400 < cedb> where transitive deps dont get resolved?
2023-06-15 00:59:40 -0400 < cedb> i literally inherited a codebase i couldnt build because it was a big pile of jenkins and maven that relied on a self hosted maven server for artifacts
2023-06-15 00:59:48 -0400 < cedb> and couldnt find out how to bootstrap without that server
2023-06-15 01:00:21 -0400 < aeth> wow, that somehow beats C++
2023-06-15 01:00:33 -0400 < aeth> what I "love" about C++ is every project gets built in its own unique way
2023-06-15 01:00:43 -0400 < cedb> exactly like how can you be worse than cmake nonsense
2023-06-15 01:00:50 -0400 < aeth> top of the hall of shame right now for C++ ime is https://zdoom.org/wiki/Compile_GZDoom_on_Linux
2023-06-15 01:01:17 -0400 < aeth> you have to build an only-for-GZDoom library called ZMusic and then you have to copy and paste this line in: https://zdoom.org/wiki/Compile_GZDoom_on_Linux#Compiling
2023-06-15 01:01:30 -0400 < cedb> omg wtf is this thing
2023-06-15 01:01:49 -0400 < aeth> and if you don't want to `make install` the only-for-GZDoom library called ZMusic (I didn't) and you don't want to build in ~/gzdoom_build/, then you have to actually modify that
2023-06-15 01:02:02 -0400 < aeth> not good enough to just copy and paste
2023-06-15 01:02:17 -0400 < cedb> what i dont get is that it writes stuff like "copy paste" in a very like
2023-06-15 01:02:26 -0400 < aeth> why not just make it a shell script
2023-06-15 01:02:35 -0400 < cedb> it seems worded for someone superr newbie
2023-06-15 01:02:40 -0400 < aeth> shell scripts are awful but when you have a one liner you want to constantly enter, then that's the perfect use case
2023-06-15 01:02:48 -0400 < cedb> but then those people would be fucking exchausted reading that
2023-06-15 01:03:23 -0400 < cedb> jfc it has literal commit hashes they tell you to check out
2023-06-15 01:03:32 -0400 < aeth> yes, it's amazing
2023-06-15 01:04:00 -0400 < aeth> I wonder how much of it the Arch build system definition uses or if they just write their own better way from scratch, because I built GZDoom on Arch once and ofc it's just one simple line like anything else in Arch
2023-06-15 01:04:23 -0400 < aeth> I had to build this on Fedora recently to play MyHouse.WAD, the viral Doom map, though.
2023-06-15 01:04:59 -0400 < aeth> Probably took about as long as it took to play the map
2023-06-15 01:05:07 -0400 < aeth> Worth it, though
2023-06-15 01:05:45 -0400 < cedb> arch is the most pragmatic distro
2023-06-15 01:06:03 -0400 < cedb> like writing a pkgbuild is trivial compared to a fucking
2023-06-15 01:06:09 -0400 < cedb> rpm or god help us deb
2023-06-15 01:06:14 -0400 < aeth> Arch is great if you want to compile lots of C and C++ projects (since they otherwise have their own unique ways to build them, as I said)
2023-06-15 01:06:30 -0400 < aeth> but I like being one version behind on Fedora. A good compromise between stability-vs-instability and freshness-vs-staleness
2023-06-15 01:06:47 -0400 < cedb> what kind of C, i almost never have to build from source
2023-06-15 01:06:56 -0400 < cedb> just the dkms but like wtv its safer
2023-06-15 01:07:27 -0400 < aeth> hmm... I think the last C project I built was Chibi Scheme
2023-06-15 01:07:33 -0400 < aeth> most stuff are C++ these days if they are that low level
2023-06-15 01:08:34 -0400 < cedb> right chibi has no binary, but most implementations do
2023-06-15 01:09:01 -0400 < cedb> and lua is very popular for small embedded
2023-06-15 01:09:11 -0400 < cedb> which makes me a little sad but wtv
2023-06-15 01:09:39 -0400 < aeth> well, Fedora has chibi-scheme now so I haven't built it recently. I think it's the one that used hg instead of git the first time I built it.
2023-06-15 01:09:48 -0400 < cedb> im just asking cause one of the main reasons i use arch is because i /dont/ have to build stuff
2023-06-15 01:10:06 -0400 < cedb> in debian i always had to, but maybe rolling fedora gets you somehwere nice
2023-06-15 01:10:26 -0400 < cedb> cause when /dont/ you want upstream?
2023-06-15 01:10:27 -0400 < aeth> hmm, I had to remove chibi-scheme in the distro upgrade (I forget why it broke) so this is a good reminder to reinstall it (no dependencies, either, idk why it was one of the randomly broken packages this time)
2023-06-15 01:10:53 -0400 < aeth> not broken on Fedora, it's just a Fedora thing that sometimes you have to remove a handful of stuff before upgrading for who knows why
2023-06-15 01:11:01 -0400 < cedb> hmmm
2023-06-15 01:11:03 -0400 < cedb> lol thats not great
2023-06-15 01:11:07 -0400 < aeth> dnf is bad
2023-06-15 01:11:21 -0400 < cedb> tbh they all suck
2023-06-15 01:11:26 -0400 < cedb> thats how we got docker basically
2023-06-15 01:11:46 -0400 < aeth> memory leaks on my pi so I'm going to have to do a clean install (it's on an old version of Fedora that I can't system upgrade because of this memory leak)... perhaps just an ARM thing, or a 1 GB of RAM thing
2023-06-15 01:11:54 -0400 < cedb> with the kind of stuff i see being deployed noone is gonna convince me containers are for "security"
2023-06-15 01:12:40 -0400 < aeth> (the bug is almost certainly fixed but I can't fix it because, you know, memory leak)
2023-06-15 01:13:19 -0400 < aeth> the only thing I have to build on Fedora (other than GZDoom, I guess?) is SBCL
2023-06-15 01:13:33 -0400 < dave0> is there a rust port?
2023-06-15 01:14:00 -0400 < jcowan> I build from C all the time because I want to build HEAD versions of things I am interested in as such.  If I am using them just instrumentally then I don't. (I wouldn't build cat(1) from C, e.g.)
2023-06-15 01:14:22 -0400 < aeth> for whatever reason, the SBCL version on Fedora is extremely stale in a very noticeable way... literally just never getting updated anymore for whatever reason.
2023-06-15 01:14:35 -0400 < aeth> 2.0.1-8... and it's .fc36 even in Fedora 38 so they haven't even rebuilt it?
2023-06-15 01:14:43 -0400 < aeth> 2.3.5 is much newer
2023-06-15 01:15:00 -0400 < jcowan> Same issue with Chicken on Cygwin which is 4.x
2023-06-15 01:15:09 -0400 < jcowan> I mean, that's ridiculous.
2023-06-15 01:15:11 -0400 < aeth> 2.0.1 is from January 2020, apparently. http://www.sbcl.org/all-news.html#2.0.1
2023-06-15 01:15:27 -0400 < aeth> the timing is, actually not good. I hope the old maintainer is OK and lived through COVID
2023-06-15 01:16:24 -0400 < aeth> lots of bugs got fixed so you might not even be able to run all new libraries if you use the SBCL that Fedora ships with
2023-06-15 01:18:12 -0400 < aeth> oh, I forgot to link to my source that Fedora ships an old SBCL. https://packages.fedoraproject.org/pkgs/sbcl/sbcl/
2023-06-15 01:18:22 -0400 < aeth> RHEL (EPEL) gets a worse one: 1.4.0
2023-06-15 01:20:11 -0400 < mdhughes> This is even more religious, but you know there's other OS's than extremely stale Linux distros?
2023-06-15 01:20:24 -0400 < mdhughes> MacPorts has sbcl@2.3.4
2023-06-15 01:20:32 -0400 < mdhughes> Maybe later, I haven't updated in months.
2023-06-15 01:20:53 -0400 < aeth> I usually take 6-12 months to recompile it, and SBCL seems to update monthly
2023-06-15 01:21:13 -0400 < aeth> For Schemes, I haven't run into broken-library issues like can happen if you use an old, un-bugfixed SBCL
2023-06-15 01:21:19 -0400 < aeth> but maybe those exist
2023-06-15 01:22:52 -0400 < Irvise_> Chiming in: one could try updating it by submitting a patch. But otherwise there are tools such as Nix/Guix that allow the installation of packages on other Linix distros. As an extra there is distrobox too. I personally use Guix and Distrobox :)
2023-06-15 02:23:55 -0400 < Ren[m]> <mdhughes> "This is even more religious, but..." <- sure, Hurd needs drivers written in Guile and there's still none!
2023-06-15 02:25:00 -0400 < aeth> write the whole OS in Scheme
2023-06-15 02:25:44 -0400 < aeth> call it Massively Advanced OS (MAO), written in Stalin
2023-06-15 02:26:31 -0400 < Ren[m]> aeth: at least any Scheme could have use a GUI toolkit of its' own
2023-06-15 02:34:12 -0400 < edgar-rft> Largely Massively Advanced OS = LMAO
2023-06-15 02:39:42 -0400 < mdhughes> There's already things like https://github.com/jart/sectorlisp
2023-06-15 02:44:30 -0400 < amirouche> And loko
2023-06-15 03:25:42 -0400 < aeth> well then maybe one day we can have a reddit clone running on a web browser running on sectorlisp or something similar
2023-06-15 03:26:22 -0400 < mdhughes> GUIs are also irrelevant. You just need a framebuffer and text generator, draw your own UI.
2023-06-15 03:26:59 -0400 < lockywolf> I'd say, that rather than a framebuffer "you just need an xhtml consumer". :D
2023-06-15 03:27:06 -0400 < mdhughes> NO.
2023-06-15 03:27:14 -0400 < aeth> GUIs aren't irrelevant, they're a separate layer that shouldn't be tied to the underlying backend (which is one reason why Discord is bad, and why Reddit effectively dropping its API is also bad now, too)
2023-06-15 03:27:34 -0400 < lockywolf> APIs are a stupid idea in the first place
2023-06-15 03:27:43 -0400 < aeth> heck, in old reddit you can just add .rss or whatever at the end to get rss
2023-06-15 03:27:43 -0400 < lockywolf> everything should be in the xhtml
2023-06-15 03:27:51 -0400 < aeth> and similar other things
2023-06-15 03:27:53 -0400 < lockywolf> rss is also an anti-pattern :)
2023-06-15 03:27:55 -0400 < aeth> I think .json too
2023-06-15 03:28:12 -0400 < lockywolf> everything "separate" has a tendency to diverge from the origin
2023-06-15 03:28:25 -0400 < lockywolf> h-entry lets you annotate "streams of posts" within an html page
2023-06-15 03:28:34 -0400 < lockywolf> so the html page is at the same time a feed
2023-06-15 03:28:54 -0400 < lockywolf> but it is also render-able by an html enginer
2023-06-15 03:29:04 -0400 < lockywolf> (cons 'h-entry 'h-feed)
2023-06-15 03:32:23 -0400 < aeth> is that what your reddit clone is going to use?
2023-06-15 03:33:20 -0400 < mdhughes> I've been around hentai too long, I read H-entry and H-feed very differently than maybe you meant them.
2023-06-15 03:34:41 -0400 < aeth> well good news because guess what half of the content on reddit is
2023-06-15 03:34:47 -0400 < aeth> and thus any good reddit clone
2023-06-15 03:40:21 -0400 < aeth> lockywolf: what is it? It's not in https://en.wikipedia.org/wiki/List_of_content_syndication_markup_languages
2023-06-15 03:41:35 -0400 < lockywolf> aeth: https://indieweb.org/h-entry
2023-06-15 03:41:44 -0400 < lockywolf> aeth: https://microformats.org/wiki/h-entry
2023-06-15 03:42:36 -0400 < aeth> refreshing to see an old style website
2023-06-15 03:46:41 -0400 < lockywolf> Web 1.0
2023-06-15 04:16:56 -0400 < aeth> more like 1.9
2023-06-15 04:16:58 -0400 < aeth> it's Wordpress
2023-06-15 04:19:16 -0400 < aeth> Wordpress+Mediawiki, anyway. The second site
2023-06-15 04:20:17 -0400 < aeth> lockywolf: this is actually incredibly useful information
2023-06-15 04:21:31 -0400 < aeth> https://developer.mozilla.org/en-US/docs/Web/HTML/microformats
2023-06-15 04:22:17 -0400 < aeth> one of these small little details where if you inspect element on a major site you'll see like a million extra tags and these are just some of them
2023-06-15 04:30:07 -0400 < lockywolf> aeth: yep
2023-06-15 04:30:20 -0400 < lockywolf> It has many more of them.
2023-06-15 05:03:15 -0400 < cow_2001> when f(g(x)) = identity(x), f and g are………?
2023-06-15 05:03:49 -0400 < cow_2001> f: A->B, g: B->A
2023-06-15 05:04:18 -0400 < cow_2001> identity_{A->A}, i guess
2023-06-15 05:04:28 -0400 < cow_2001> or whatever you call it
2023-06-15 05:45:37 -0400 < lockywolf> cow_2001: bijections?
2023-06-15 05:48:36 -0400 < cow_2001> och
2023-06-15 05:48:42 -0400 < cow_2001> lockywolf: thank you
2023-06-15 05:49:12 -0400 < cow_2001> now, what do they call it in software?
2023-06-15 06:03:59 -0400 < cow_2001> this guy has some interesting stuff https://www.youtube.com/playlist?list=PLfYUBJiXbdtRUvTUYpLdfHHp9a58nWVXP
2023-06-15 06:04:05 -0400 < cow_2001> offtopic, but it's nice.
2023-06-15 06:48:13 -0400 < jcowan> You could transplant the HTML vocabulary to MicroXML syntax
2023-06-15 06:48:30 -0400 < jcowan> or just use Gemini+something
2023-06-15 09:32:58 -0400 < cow_2001> :D http://0x0.st/HTiv.txt
2023-06-15 09:53:09 -0400 < lockywolf> Has anyone seen Scheme bindings for RRDtool?
2023-06-15 10:01:58 -0400 < wasamasa> and here I thought it's supposed to be used via CLI, lol
2023-06-15 10:07:05 -0400 < lockywolf> wasamasa: it was
2023-06-15 10:12:07 -0400 < lockywolf> it can be used with (chibi shell), or something like that
2023-06-15 12:39:13 -0400 < Zipheir> cow_2001: Programmers don't think about bijections. They glaze over when you say "associative". :-)
2023-06-15 12:49:29 -0400 < mdhughes> If (f (g x)) => x, then f & g should be optimized out, they did nothing.
2023-06-15 12:49:41 -0400 < mdhughes> Or are you using… SIDE EFFECTS?!
2023-06-15 12:56:29 -0400 < Zipheir> That's silly. No one's going to be writing identity that way.
2023-06-15 12:57:39 -0400 < Zipheir> You may want to know, though, that your translator foo-lang->bar-lang is one side of an isomorphism.
2023-06-15 12:59:08 -0400 < Zipheir> Of course, yes, if you know that f ∘ g = id, then you can optimize away compositions.
2023-06-15 12:59:55 -0400 < Zipheir> Sorry, I didn't think hard enough. Those kinds of reductions are used all the time in theorem provers.
2023-06-15 13:01:20 -0400 < mdhughes> I'm more of a unit tester than theorem type.
2023-06-15 13:02:25 -0400 < Zipheir> Both are good.
2023-06-15 15:26:16 -0400 < tomhg> somiaj: As a user I currently could draw the line between a recommended and suggested packages as well. If some threshold as a vote for a pacakge to be a recommended one could be gathered, okay. But that is some elaborated - under experiences tagged - mathematics I suppose. Again thanks to you guys. I got rid of any warning when booting and my temperature is lowered after the '12 update :)
2023-06-15 15:26:25 -0400 < tomhg> fc
2023-06-15 15:27:14 -0400  * tomhg has started to code its own lr(1) parser generator from scratch in order to learn macros.
2023-06-15 17:07:36 -0400 -!- mirai_ is now known as mirai
2023-06-15 17:19:52 -0400 -!- greaser|q is now known as GreaseMonkey
2023-06-15 17:31:34 -0400 < Zipheir> tomhg: lr(1) confuses me slightly because I once wrote a UNIX-style lr ("log rotater") tool. As a standalone command, it was, of course, lr(1).
2023-06-15 17:38:51 -0400 < amirouche> hey people of the parenthetical thesis
2023-06-15 17:39:28 -0400 < amirouche> Any SDL bindings that work with Chez?
2023-06-15 17:48:32 -0400 < Zipheir> amirouche: I haven't tried it. https://github.com/ovenpasta/thunderchez/tree/trunk/sdl2
2023-06-15 17:48:58 -0400 < Zipheir> mdhughes rabbits on about thunderchez enough, so maybe ask him. :)
2023-06-15 17:50:12 -0400 < amirouche> I thought I saw that already.
2023-06-15 17:50:56 -0400 < amirouche> Ultimatly there is many chez libs, and many chez users, not at the same place, and the same time :)
2023-06-15 17:51:29 -0400 < Zipheir> amirouche: You might have mentioned that you'd already seen some.
2023-06-15 17:59:04 -0400 < tomhg> Zipheir: Oh man, I am stinking. I don't get it. Why would a 1 be of concern when reversing? :)
2023-06-15 18:10:08 -0400 < Zipheir> tomhg: The traditional UNIX organization puts standalone programs in the first section of the manual. This is why grep is often written "grep(1)" in UNIX contexts.
2023-06-15 18:11:26 -0400 < Zipheir> I guess it's more helpful when talking about names that refer to commands or library procedures, like printf. There's printf(1) and printf(3), the latter being the C routine.
2023-06-15 20:02:02 -0400 < mdhughes> Yep, thunderchez works fine. It is getting older without maintenance, but nothing's broken.
2023-06-15 20:03:31 -0400 < mdhughes> Make sure to set CHEZSCHEMELIBDIRS=$HOME/whatever/thunderchez:
2023-06-15 20:04:55 -0400 < mdhughes> And do (load-shared-object "somelibdir/libSDL2-2.0.0.dylib") and bob's your uncle.
--- Day changed Fri Jun 16 2023
2023-06-16 02:55:01 -0400 < cow_2001> i don't know how to find invariants
2023-06-16 04:36:46 -0400 -!- AndrewYu is now known as Andrew
2023-06-16 04:43:29 -0400 < cow_2001> it's funny how easy it is to write scheme imperatively
2023-06-16 05:15:27 -0400 < lockywolf> cow_2001: you can also write C in functional style
2023-06-16 05:15:53 -0400 < lockywolf> cow_2001: you can re-implement a lot of C++ in C macros
2023-06-16 05:15:55 -0400 < cow_2001> lockywolf: :|
2023-06-16 05:16:21 -0400 < cow_2001> my sleep is bad as it is. i don't need nightmares
2023-06-16 05:16:56 -0400 < cow_2001> how do you write c in functional style?
2023-06-16 05:17:19 -0400 < lockywolf> I don't
2023-06-16 05:18:23 -0400 < cow_2001> the colloquial "you"
2023-06-16 05:21:07 -0400 < lockywolf> I didn't truly think about it, but you basically define a data type like a struct sexp{}; , and use it to pass data everywhere
2023-06-16 05:21:40 -0400 < mdhughes> Scheme is literally Algol, so yes. But it's usually more efficient to write functional where possible.
2023-06-16 05:23:48 -0400 < lockywolf> in scheme you can't do int* a = 0xbabacadd; *a = 0b100110101010; or can you?
2023-06-16 05:23:58 -0400 < mdhughes> You can if you use FFI types.
2023-06-16 05:24:06 -0400 < lockywolf> well...
2023-06-16 05:24:22 -0400 < mdhughes> And somewhere down at the bottom, the Scheme has to be able to do that itself, or the impl language does.
2023-06-16 05:24:24 -0400 < lockywolf> let's have a standard FFI for Scheme
2023-06-16 05:24:32 -0400 < cow_2001> algol looks suspiciously like pascal (in the youtube thumbnails i just found)
2023-06-16 05:24:44 -0400 < lockywolf> perhaps the other way round?
2023-06-16 05:24:53 -0400 < mdhughes> Other way around, Pascal is Algol simplified and cleaned up for a teaching language.
2023-06-16 05:25:51 -0400 < lockywolf> Pascal was developed on the pattern of the ALGOL 60 language. Wirth was involved in the process to improve the language as part of the ALGOL X efforts and proposed a version named ALGOL W. This was not accepted, and the ALGOL X process bogged down. In 1968, Wirth decided to abandon the ALGOL X process and further improve ALGOL W, releasing this as Pascal in 1970.
2023-06-16 05:26:00 -0400 < lockywolf> Quote from Wiki.
2023-06-16 05:26:25 -0400 < lockywolf> mdhughes: teaching languages were not invented by PLT!
2023-06-16 05:30:22 -0400 < cow_2001> LOGO was a sort of Lisp and it was invented ages ago
2023-06-16 05:30:39 -0400 < cow_2001> in the olden days
2023-06-16 05:31:14 -0400 < cow_2001> i need to figure out this loop invariant thing or i am going to miss half the fun
2023-06-16 06:09:51 -0400 < sam-d[m]> does anybody know of an r6rs threading macro similar to rackets threading-lib or guile-pipe?
2023-06-16 08:00:04 -0400 < acdw> what does plt stand for?
2023-06-16 08:01:31 -0400 < edgar-rft> -> https://www.acronymfinder.com/PLT.html
2023-06-16 08:02:09 -0400 < cow_2001> starting to get invariants. need to get more stuff
2023-06-16 08:05:07 -0400 < acdw> edgar-rft: thanks
2023-06-16 08:06:51 -0400 < cow_2001> acdw: did it work?
2023-06-16 08:07:01 -0400 < cow_2001> acdw: is it programming language theory?
2023-06-16 08:07:36 -0400 < cow_2001> or paletelets?
2023-06-16 08:28:08 -0400 < acdw> could be either!
2023-06-16 08:47:36 -0400 < edgar-rft> acdw: I still don't know what PLT (in context of PLT Scheme) means exactly but the best link with explanations I could find so far is -> https://www2.ccs.neu.edu/racket/
2023-06-16 08:48:41 -0400 < acdw> maybe it's Perry Le plaTypus
2023-06-16 08:48:45 -0400 < edgar-rft> I meanwhile have the suspicion that PLT means something super-trivial like "Programming Language Team" or similar
2023-06-16 08:55:43 -0400 < shawnw> Programming Language Theory?
2023-06-16 09:00:26 -0400 < edgar-rft> that was my first thought but there was a company named "PLT Inc." and I doubt that you can legally declare "Programming Language Theory" to be a company name
2023-06-16 09:38:45 -0400 < acdw> Pickle Lobbing Theory
2023-06-16 09:39:11 -0400 < edgar-rft> Public Library Toilet
2023-06-16 09:41:17 -0400 < acdw> wait i have a script for this
2023-06-16 09:41:38 -0400 < acdw> for letter in p l t; do words ^$letter; done
2023-06-16 09:41:57 -0400 < acdw> shit i forgot the | shuf -n1
2023-06-16 09:42:33 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-16 09:42:37 -0400 < acdw> pithiest legged tympanist
2023-06-16 09:48:39 -0400 < lockywolf> damn, each time I am trying to write something in Scheme, I end up writing it in bash ... 🤦‍♂️
2023-06-16 09:49:20 -0400 < edgar-rft> at least you can say that Scheme has made you learn Bash :-)
2023-06-16 09:51:08 -0400 < acdw> lolol
2023-06-16 09:51:17 -0400 < acdw> lockywolf: i reach for bash so much, it's just easy
2023-06-16 09:52:07 -0400 < lockywolf> I should write a #lang bash for I don't know... Racket?
2023-06-16 09:52:25 -0400 < acdw> oh god yeah
2023-06-16 09:59:08 -0400 < lockywolf> but bash has this weird word splitting ...
2023-06-16 09:59:21 -0400 < lockywolf> so whitespace is not to be trusted
2023-06-16 10:05:29 -0400 < wasamasa> rc doesn't have weird word splitting
2023-06-16 10:06:38 -0400 < acdw> but it's rc
2023-06-16 10:07:29 -0400 < wasamasa> yeah
2023-06-16 10:07:33 -0400 < acdw> lol
2023-06-16 10:07:39 -0400 < wasamasa> I fear I'll forget it because I rarely use it
2023-06-16 10:08:04 -0400 < wasamasa> I pretty much stick to sh for programs other people are meant to execute
2023-06-16 10:12:59 -0400 < acdw> sh is fine, who needs arrays?
2023-06-16 10:42:08 -0400 < amirouche> Racket's PLT is Programming Languages Teacher
2023-06-16 11:26:57 -0400 < acdw> oh huh
2023-06-16 11:42:33 -0400 < mdhughes> Yeah, please don't use bash, it's dangerous. zsh & ksh are both safer.
2023-06-16 11:42:54 -0400 < mdhughes> https://en.wikipedia.org/wiki/Shellshock_(software_bug)
2023-06-16 11:43:11 -0400 < mdhughes> But after that hit, I did a bit of code review of bash. I immediately switched my shell to zsh.
2023-06-16 11:43:29 -0400 < mdhughes> (which I also code-reviewed, and it's fine. Boring, even.)
2023-06-16 11:43:34 -0400 < gwatt> I've found some pretty weird corner cases in ksh, though it is generally better for scripting
2023-06-16 11:44:06 -0400 < mdhughes> ksh still does space-based parsing, so you can hurt yourself if you're not careful to use "$foo"
2023-06-16 11:44:24 -0400 < mdhughes> If you say $foo in zsh, it means one argument.
2023-06-16 11:45:16 -0400 < mdhughes> And looping back around, scsh is the correct choice (but not so great for interactive)
2023-06-16 11:45:25 -0400 < gwatt> what if I want multiple arguments? Do I have to use an array and explicitly explode it?
2023-06-16 11:45:45 -0400 < mdhughes> Yeah. I find I *almost* never need to do that.
2023-06-16 11:45:59 -0400 < gwatt> Also, ksh's explicit goal was to be bug-for-bug compatible with sh, so you get all that fun behavior
2023-06-16 12:06:38 -0400 < Zipheir> I'm skeptical that any of the Bourne languages are remotely "safe".
2023-06-16 12:07:43 -0400 < Zipheir> Rich Felker has a memorable page on the vagaries of POSIX-compliant sh issues. https://www.etalabs.net/sh_tricks.html
2023-06-16 12:08:17 -0400 < Zipheir> It's still very convenient for little string-five-commands-together utilities.
2023-06-16 12:09:29 -0400 < Zipheir> Shellshock, also, is very old news.
2023-06-16 12:11:10 -0400 < mdhughes> It's old but the kind of shitty programming that let it happen, is all thru bash's codebase.
2023-06-16 12:11:20 -0400 < mdhughes> "
2023-06-16 12:11:52 -0400 < mdhughes> "Why bother upgrading my Model T to a Lexus, it's still a gas-burner."
2023-06-16 12:12:10 -0400 < Zipheir> Yes, bash is a mess. Even Larry Well thinks bash is a mess.
2023-06-16 12:12:14 -0400 < Zipheir> *Wall
2023-06-16 12:12:17 -0400 < gwatt> Honestly, I bet for collectors a Model T is more valuable than a lexus
2023-06-16 12:12:41 -0400 < mdhughes> But would you drive it on the highway?
2023-06-16 12:13:02 -0400 < Zipheir> I think extending Bourne to a "real" programming language is fraught.
2023-06-16 12:13:22 -0400 < gwatt> No, you put it in a trailer and take it to horseless carriage conventions and drive it in parades and the like
2023-06-16 12:13:59 -0400 < mdhughes> David Korn thinks (just checked, he's 79 and alive AFAICT) otherwise.
2023-06-16 12:14:37 -0400 < Zipheir> Well, fine.
2023-06-16 12:14:40 -0400 < mdhughes> zsh (and fish? I didn't like the subshell behavior so I haven't investigated further) are based on the idea that shell programming might be useful.
2023-06-16 12:15:11 -0400 < gwatt> ksh definitely tried to extend the capabilities pretty far. Like, you can define composite data types, with type constraints on the members (!!)
2023-06-16 12:15:20 -0400 < Zipheir> IMO, rc fixed the central problem with Bourne--the "everything is a string" type philosophy.
2023-06-16 12:15:36 -0400 < gwatt> and ksh can provide documentation for those types.
2023-06-16 12:16:16 -0400 < mdhughes> Way back on my Atari ST, ksh got to be my main not-compiled-C language, because it was something like 2/3 the size of bash, and as useful as awk or any other large language.
2023-06-16 12:16:54 -0400 < Zipheir> I don't know if zsh changed this (ksh certainly didn't), but Bourne takes the approach that a command line is always a flat string. That string has to be expanded and re-expanded until everything is flattened out. Many, many bugs come from this approach: Bourne is essentially a macro processor.
2023-06-16 12:17:28 -0400 < mdhughes> That's what zsh does differently. It's a "real language", not an expander.
2023-06-16 12:18:06 -0400 < mdhughes> So it has an array type. foos=(1 2 3 4); args $foos  (where `args` prints each arg in a line) produces 4 lines.
2023-06-16 12:18:42 -0400 < mdhughes> foo="1 2 3 4"; args $foo  produces 1 line.
2023-06-16 12:18:58 -0400 < Zipheir> That's similar to what rc does. Well, good.
2023-06-16 12:19:32 -0400 < Zipheir> Is there a language guide to zsh? All of the junk I find is about theming your prompt and fancy completion tricks.
2023-06-16 12:20:19 -0400 < mdhughes> I just use the zsh manual, but I think there's a PragPub or Manning for it.
2023-06-16 12:20:57 -0400 < Zipheir> I would like a BNF :)
2023-06-16 12:22:29 -0400 < Zipheir> That absolutely may not exist. Most shells aren't built from grammars. The POSIX sh grammar is very much a ret-con.
2023-06-16 12:23:18 -0400 < mdhughes> Maybe on the https://www.zsh.org
2023-06-16 12:23:20 -0400 < Zipheir> (Say what you will about raku, but it was the first Perl to use a formal grammar.)
2023-06-16 12:24:03 -0400 < Zipheir> mdhughes: Thanks for the references. The man pages have a lot of detail, too.
2023-06-16 12:25:40 -0400 < gnomon> mdhughes, agreed that ksh93 is a very good choice for shell scripting.
2023-06-16 12:25:48 -0400 < gnomon> ksh88, ehhhh...
2023-06-16 12:27:00 -0400 < Zipheir> How about mksh?
2023-06-16 12:27:16 -0400 < gnomon> I appreciate it but I don't lean on it too heavily.
2023-06-16 12:27:29 -0400 < Zipheir> Of course, Theo will consider you a traitor for using it...
2023-06-16 12:27:41 -0400 < gnomon> Theo would hate me for any number of heresies.
2023-06-16 12:27:50 -0400 < gnomon> Perhaps -1s/would/does/
2023-06-16 12:28:28 -0400 < gwatt> I like raku. It's too bad it caused a fracture
2023-06-16 12:29:56 -0400 < mdhughes> You know when you're a drunk college student, and you're hungry, so you start throwing everything in the hot pot, and pretty soon it's this toxic goulash you can't eat, but you hate-eat because you're drunk? Raku!
2023-06-16 12:31:28 -0400 < Zipheir> To complete the analogy, let it stew in the dorm broom closet for 20 years before serving.
2023-06-16 12:31:34 -0400 < gwatt> I actually don't have that experience. I'll take your word for it.
2023-06-16 12:32:25 -0400 < Zipheir> It's a bit on the Hunter S. Thompson side, but I thought it was funny.
2023-06-16 12:32:56 -0400 < mdhughes> Bad times the day after.
2023-06-16 12:33:02 -0400 < gwatt> oh it was a good joke, but drunk college me was apparently a better cook than some
2023-06-16 12:34:38 -0400 < gwatt> I think raku does some good stuff. It's got a built-in grammar library so you can define your own grammars prety easily. The CLI creation is I think best-in-show. kebab-case is always welcome.
2023-06-16 12:35:44 -0400 < gwatt> though it did double-down on sigils and has even more
2023-06-16 12:36:42 -0400 < Zipheir> It's the next stage in Larry Wall's "natural language of programming" project.
2023-06-16 12:37:34 -0400 < Zipheir> It's hard to think of a language less like Scheme, by the way. The design philosophies are almost completely opposite.
2023-06-16 12:38:03 -0400 < gwatt> I wrote scheme-scribe and the logger api in perl.
2023-06-16 12:39:11 -0400 < acdw> perl is the "but what if we /did/ pile feature on top of feature"
2023-06-16 12:39:22 -0400 < acdw> i think?
2023-06-16 12:40:21 -0400 < Zipheir> I think there's a method to the madness. Again, Larry Wall is very driven by the "features" of natural languages.
2023-06-16 12:40:38 -0400 < Zipheir> So there are many different ways to say things.
2023-06-16 12:41:36 -0400 < dadinn[m]> Hi all
2023-06-16 12:41:37 -0400 < Zipheir> From my Scheme-skewed perspective, I'd rather have a fixed, simple, low-sugar syntax and leave the idioms to macro programming.
2023-06-16 12:41:46 -0400 < Zipheir> dadinn[m]: Hello.
2023-06-16 12:42:00 -0400 < acdw> yeah, programming is not quite the same as natural language
2023-06-16 12:44:11 -0400 < gwatt> I think perl provides a good way to "upgrade" your script in a way that fails well if that's not possible. You can use "use feature signature" and suddenly functions can have signatures! If the perl version doesn't support that, it fails with a message to that effect, rather than a cryptic parser error.
2023-06-16 12:45:00 -0400 < gwatt> Contrast that with python's "from __future__ import feature" which is a decree from on high that at some point your code will stop working if you don't do that
2023-06-16 12:45:01 -0400 < dadinn[m]> I am trying to understand the difference between export and #:export-syntax in the define-module macr.
2023-06-16 12:45:01 -0400 < dadinn[m]> I can see that #:export-syntax is for macros, but when I use plain #:export for my macros it works fine too... so what's the difference between the two?
2023-06-16 12:45:12 -0400 < Zipheir> gwatt: Good point.
2023-06-16 12:45:41 -0400 < gwatt> dadinn[m]: what scheme? guile? That's not standard syntax
2023-06-16 12:45:43 -0400 < Zipheir> dadinn[m]: There really should only be one 'export', from an RnRS perspective.
2023-06-16 12:45:50 -0400 < dadinn[m]> I am doing this in GNU Guile. Not sure if this is specific to Guile.
2023-06-16 12:46:12 -0400 < dadinn[m]> Zipheir: Hmm, I see.
2023-06-16 12:46:22 -0400 < Zipheir> Are you using R6RS libraries to export things?
2023-06-16 12:46:53 -0400 < Zipheir> I can't find #:export-syntax in the Guile pages.
2023-06-16 12:47:51 -0400 < dadinn[m]> I've ben trying to ask on the Guile channel for ages, nobody responds
2023-06-16 12:47:52 -0400 < dadinn[m]> s/ben/been/
2023-06-16 12:48:25 -0400 < Zipheir> I only see export and export! in the guile modules page. https://www.gnu.org/software/guile/manual/html_node/Creating-Guile-Modules.html
2023-06-16 12:49:27 -0400 < Zipheir> If possible, just avoid the whole issue and use the standard R6 library form. https://www.gnu.org/software/guile/manual/html_node/R6RS-Libraries.html
2023-06-16 12:50:53 -0400 < Zipheir> (My guess is that #:export-syntax is deprecated, since it's not mentioned on that define-module page.)
2023-06-16 12:53:02 -0400 < dadinn[m]> Hmm, you've got me there! 😧
2023-06-16 12:53:45 -0400  * dadinn[m] uploaded an image: (9KiB) < https://libera.ems.host/_matrix/media/v3/download/matrix.org/lRRtAidrgYBctzziICXvuwaT/image.png >
2023-06-16 12:53:52 -0400 < Zipheir> I'm sorry to hear that #guile has nothing better to offer.
2023-06-16 12:53:56 -0400 < dadinn[m]> I think I found it because geiser autocompletes to it
2023-06-16 12:54:34 -0400 < Zipheir> So it does.
2023-06-16 12:55:39 -0400 < Zipheir> It reminds me that CHICKEN has separate *im*port forms for syntax. The standards have dumped all of that. One import, one export.
2023-06-16 12:57:14 -0400 < dadinn[m]> So import/export are standard? I should stick to those instead.
2023-06-16 12:57:58 -0400 < Zipheir> Yes.
2023-06-16 12:58:33 -0400 < Zipheir> Well, it's the (library ...) and (define-library ...) forms--or perhaps sublanguages--that are standard.
2023-06-16 12:59:47 -0400 < dadinn[m]> Also this #:export-syntax clause happens to break my code on the site of usage... so not sure what's its intended purpose
2023-06-16 13:02:05 -0400 < Zipheir> There seems to be a question about it on the Guile ml--21 years ago. https://lists.gnu.org/archive/html/guile-devel/2001-04/msg00439.html
2023-06-16 13:02:51 -0400 < Zipheir> Unanswered, of course, which reminds me of https://xkcd.com/979/
2023-06-16 13:04:31 -0400 < dadinn[m]> 😆
2023-06-16 13:05:06 -0400 < dadinn[m]> I've found that thread too
2023-06-16 13:07:10 -0400 < dadinn[m]> Zipheir:  thanks for helping with arriving to the conclusion that I should stick with export... whatever this export-syntax was intended for
2023-06-16 13:12:48 -0400 < Zipheir> dadinn[m]: You're welcome. I hope it works out.
2023-06-16 15:51:16 -0400 < DeeEff> this discussion kind of reminds me of #[macro_use] in Rust - it is always odd to treat syntax separate from other language constructs
2023-06-16 15:53:04 -0400 < Zipheir> Yes. I don't know how R6 does it, but I wonder if you need a certain phasing model to make "unified" imports work.
2023-06-16 15:53:33 -0400 < DeeEff> I think it's probably whether you can resolve exports in a delayed manner or not
2023-06-16 15:53:53 -0400 < DeeEff> depends on whether your exports are resolved at import time or at definition time I suppose
2023-06-16 15:54:06 -0400 < DeeEff> otherwise it's just a binding, right?
2023-06-16 15:54:21 -0400 < DeeEff> shouldn't be that different to deal with a symbol that points to a lambda vs one that points to syntax
2023-06-16 15:55:37 -0400 < Zipheir> Hmm, yes.
2023-06-16 16:03:45 -0400 < gwatt> I'd imagine R6RS determines the import phase by determining which identifiers are used inside of `define` vs `define-syntax`.
2023-06-16 16:05:24 -0400 < jcowan> You want a bug-resistant shell, rc is your friend
2023-06-16 16:11:55 -0400 -!- ced1 is now known as cedb
2023-06-16 16:13:44 -0400 < acdw> maybe I should learn rc
2023-06-16 16:14:09 -0400 < jcowan> It's incredibly simple.
2023-06-16 16:14:30 -0400 < acdw> rc+scheme eh
2023-06-16 16:14:40 -0400 < acdw> well I was going to learn eshell more better
2023-06-16 16:14:48 -0400 < jcowan> Too much!
2023-06-16 16:15:14 -0400 < acdw> psh
2023-06-16 16:15:15 -0400 < jcowan> I designed a hybrid between rc and Lua called plwsh, but never got around to implementing it
2023-06-16 16:15:24 -0400 < acdw> now that sounds neat
2023-06-16 16:15:32 -0400 < acdw> scsh still a thing?
2023-06-16 16:15:37 -0400 < jcowan> Yes
2023-06-16 16:15:55 -0400 < jcowan> But it's useless as an interactive shell.
2023-06-16 16:16:17 -0400 < jcowan> (pronounced "ploosh")
2023-06-16 16:16:19 -0400 < acdw> aw
2023-06-16 16:16:42 -0400 < gwatt> I think there's a fundamental problem that interactive shells and programming languages have different needs.
2023-06-16 16:17:21 -0400 < acdw> yeah
2023-06-16 16:18:11 -0400 < acdw> but there could be a pair that like... interop better? maybe? or something idk
2023-06-16 16:19:25 -0400 < ecraven> these days I think that eshell does the right thing, very good integration with my "lisp machine"..
2023-06-16 16:23:59 -0400 < acdw> I just wish it'd also run outside of emacs (I know, I know)
2023-06-16 16:28:16 -0400 < jcowan> I had confused eshell and es
2023-06-16 16:32:16 -0400 < jcowan> es is an extension of rc, but it's much more complex
2023-06-16 16:37:58 -0400 < jcowan> it's also somewhat schemish
2023-06-16 16:38:06 -0400 < jcowan> https://wryun.github.io/es-shell/paper.html
2023-06-16 16:47:31 -0400 < Zipheir> acdw: Here's a paste of Tom Duff's original rc tutorial if you want to read it. http://ix.io/4yr9
2023-06-16 16:48:05 -0400 < Zipheir> The weirdest language feature of rc is that damn 'if not'. :)
2023-06-16 16:48:26 -0400 < jcowan> Yes
2023-06-16 16:49:29 -0400 < jcowan> It could have been spelled "else"
2023-06-16 16:49:40 -0400 < jcowan> but it would be a bit surprising to do so
2023-06-16 16:49:50 -0400 < Zipheir> acdw: You don't have to install plan9port to use it, either. There's a minimal plan9 userspace here https://git.suckless.org/9base/
2023-06-16 16:50:59 -0400 < Zipheir> It also lacks 'break', at least originally.
2023-06-16 16:54:16 -0400 < jcowan> In plwsh, most of the keywords are interpreted as Lua's
2023-06-16 16:56:33 -0400 < acdw> Zipheir: oooo thanks
2023-06-16 16:58:26 -0400 < acdw> es looks really neat
2023-06-16 17:00:27 -0400 < Zipheir> That is quite interesting. I don't know of any other shells with higher-order functions.
2023-06-16 17:01:08 -0400 < Zipheir> Although Shivers's point still stands: if you want those, why not extend an existing general language with shell constructs?
2023-06-16 17:01:11 -0400 < acdw> there's cursed eval stuff lol
2023-06-16 17:01:22 -0400 < acdw> yeah true honestly --- i think that's what i'd want
2023-06-16 17:01:37 -0400 < Zipheir> That's scsh.
2023-06-16 17:01:57 -0400 < acdw> Lua has a library i think about a lot where it modifies _G to look up binaries if a function of the name doesn't exist
2023-06-16 17:01:59 -0400 < acdw> ohh
2023-06-16 17:02:43 -0400 < Zipheir> Check out the scsh 'run' forms if you haven't yet. https://wiki.call-cc.org/eggref/5/scsh-process#basic-process-macros
2023-06-16 17:03:50 -0400 < acdw> i need to look at this scsh thing
2023-06-16 17:05:14 -0400 < Zipheir> 98% of scsh's usefulness comes down to making UNIX file descriptor programming somewhat Schemelike.
2023-06-16 17:05:32 -0400 < Zipheir> The fit is not perfect.
2023-06-16 17:06:06 -0400 < acdw> ahhh
2023-06-16 17:06:15 -0400 < acdw> i mean unix file descriptor programming is pretty arcane
2023-06-16 17:07:11 -0400 < Zipheir> Not at all. Everybody knows what 'head foo.txt | grep bar' does.
2023-06-16 17:07:41 -0400 < jcowan> Well, two answers: having an interactive syntax, which scsh lacks, and being based on a general purpose language that doesn't alienate 99% of all programmers
2023-06-16 17:08:18 -0400 < Zipheir> Yes.
2023-06-16 17:08:55 -0400 < jcowan> As the paper points out, the sh-style syntax of rc is not extensible.
2023-06-16 17:08:57 -0400 < Zipheir> But you can happily make pysh if parentheses scare you.
2023-06-16 17:08:57 -0400 < acdw> Zipheir: oh i meant like, the arcane stuff lol. exec >&3; cat < file >&3; etc
2023-06-16 17:09:00 -0400 < jcowan> s/rc/es
2023-06-16 17:09:43 -0400 < Zipheir> acdw: Oh yes, that's certainly arcane.
2023-06-16 17:09:55 -0400 < jcowan> The rc version is less so
2023-06-16 17:10:05 -0400 < Zipheir> The sh syntax for redirections doesn't help.
2023-06-16 17:10:15 -0400 < acdw> yeah
2023-06-16 17:10:25 -0400 < acdw> i don't even know what that does really lmao. it might not do anything
2023-06-16 17:11:35 -0400 < jcowan> command >[2] file and command >[2=1] file
2023-06-16 17:11:52 -0400 < Zipheir> As to interactive use, I'm not sure if the full power of Scheme (or <general-language>) is much use for it. Anecdotally, I rarely write anything more complicated than a 'for' loop at the shell REPL.
2023-06-16 17:12:12 -0400 < Zipheir> jcowan: Yes, it's much nicer.
2023-06-16 17:13:08 -0400 < jcowan> I don't normally wrote top-level if, but I do embed if inside for fairly often
2023-06-16 17:13:13 -0400 < Zipheir> Interactive syntax is dominated by the programmer's desire to type 'firefox^M" and run the damn program.
2023-06-16 17:13:21 -0400 < jcowan> Yes
2023-06-16 17:14:14 -0400 < acdw> sh would be a lot better in my opinion if it didn't have the god awful algol-style fi, esac, etc
2023-06-16 17:14:26 -0400 < acdw> lua did a good job there --- everything just ends with 'end'
2023-06-16 17:14:35 -0400 < Zipheir> What are you talking about? That's great syntax.
2023-06-16 17:14:46 -0400  * jcowan grew up on fi, esac, od, and tnemmoc
2023-06-16 17:14:55 -0400 < acdw> agh
2023-06-16 17:15:02 -0400 < acdw> tnemmoc, truly cursed
2023-06-16 17:15:04 -0400 < jcowan> (not the last, actually)
2023-06-16 17:15:07 -0400 < Zipheir> You know precisely what terminates what.
2023-06-16 17:15:08 -0400 < acdw> sorry, desruc
2023-06-16 17:15:09 -0400 < acdw> oh lolol
2023-06-16 17:15:24 -0400 < acdw> and yet you're in #scheme, where everything is terminated with )
2023-06-16 17:15:41 -0400 < Zipheir> True :)
2023-06-16 17:16:07 -0400 < jcowan> A68's comment terminator is the same as the initiator, which can be co or ȼ
2023-06-16 17:16:16 -0400 < jcowan> (or comment)
2023-06-16 17:16:18 -0400 < Zipheir> acdw: If you give your S-expressions named terminators, you get XML. :)
2023-06-16 17:16:24 -0400 < wasamasa> a68 is so cursed
2023-06-16 17:16:47 -0400 < jcowan> Naah.
2023-06-16 17:17:47 -0400 < wasamasa> I have no idea how I've coerced a68g to accept my definition of s-expressions
2023-06-16 17:17:56 -0400  * jcowan chuckles
2023-06-16 17:18:15 -0400 < wasamasa> spaces inside identifiers are definitely cursed
2023-06-16 17:18:30 -0400 < wasamasa> the empty string being """" is just weird
2023-06-16 17:18:34 -0400 < jcowan> yeah, I wouldn't take advantage of that
2023-06-16 17:18:48 -0400 < wasamasa> what on earth is abend supposed to be
2023-06-16 17:18:54 -0400 < wasamasa> abnormal end?
2023-06-16 17:18:54 -0400 < jcowan> ABnormal enD
2023-06-16 17:18:56 -0400 < jcowan> yes
2023-06-16 17:18:59 -0400 < jcowan> IBM-ese
2023-06-16 17:19:06 -0400 < wasamasa> it's the German word for evening
2023-06-16 17:19:10 -0400 < jcowan> Sur
2023-06-16 17:19:15 -0400 < jcowan> e
2023-06-16 17:20:14 -0400 < jcowan> "The ABEND macro is used to initiate error processing for a task. ABEND can request a full or tailored dump of virtual storage areas and control blocks."
2023-06-16 17:20:21 -0400 < wasamasa> then there's the writing style in the documentation
2023-06-16 17:20:35 -0400 < wasamasa> who thought a meek context is supposed to make sense
2023-06-16 17:21:10 -0400 < jcowan> That's the formalism.  "A68 with fewer tears" is what you want to read.
2023-06-16 17:21:35 -0400 < wasamasa> I ended up reading Programming Algol 68 Made Easy
2023-06-16 17:21:56 -0400 < jcowan> What is weird is the terminology, but that's because the now-standard terms didn't exist in 1968
2023-06-16 17:22:26 -0400 < jcowan> That's a good book, yes
2023-06-16 17:23:04 -0400 < wasamasa> I'm not sure how to feel about semicolons not being terminators
2023-06-16 17:23:25 -0400 < jcowan> Inherited from A60, whereas C inherits semicolons from PL/I
2023-06-16 17:23:28 -0400 < wasamasa> like, in the other algol derivatives, the period is used to separate statements, but semicolon does more than that
2023-06-16 17:23:36 -0400 < acdw> Zipheir: true re xml
2023-06-16 17:24:32 -0400 < acdw> i like a period separating statements
2023-06-16 17:24:46 -0400 < wasamasa> it's neat, but makes codegen difficult
2023-06-16 17:24:48 -0400 < acdw> hmmm scheme syntax like wisp except sentence style
2023-06-16 17:25:06 -0400 < acdw> (display "foo bar") (newline) => Display "foo bar".  Newline.
2023-06-16 17:25:08 -0400 < wasamasa> kinda like forbidding trailing commas
2023-06-16 17:26:12 -0400 < jcowan> I don't know any period separators.  Cobol and Prolog use period terminators.
2023-06-16 17:26:28 -0400 < acdw> If null foo?  Display bar.  Display (+ 1 2).
2023-06-16 17:26:30 -0400 < acdw> or something
2023-06-16 17:27:25 -0400 < jcowan> LISP 2 (not to be confused with 2-LISP or LISP-2) used semicolon separators, I think
2023-06-16 17:27:37 -0400 < wasamasa> I've checked, modula-3 has semicolon separators
2023-06-16 17:27:46 -0400 < jcowan> That makes sense
2023-06-16 17:27:52 -0400 < jcowan> goes with Pascal
2023-06-16 17:27:59 -0400 < acdw> how about a separator like, "SO IT IS WRITTEN"
2023-06-16 17:28:02 -0400 < jcowan> But what are these period separators of which you speak?
2023-06-16 17:28:06 -0400 < jcowan> or just STOP
2023-06-16 17:28:07 -0400 < acdw> 1 + 2 SO IT IS WRITTEN
2023-06-16 17:28:26 -0400 < wasamasa> I must be misremembering those
2023-06-16 17:28:35 -0400 < acdw> if a = 3, then print "hi", or else print "sup" SO IT IS WRITTEN
2023-06-16 17:30:24 -0400 < wasamasa> yeah, oberon also does semicolon separators
2023-06-16 17:31:07 -0400 < jcowan> if x == y then foo() SO IT IS WRITTEN bar() SO IT IS DONE
2023-06-16 17:31:18 -0400 < acdw> jcowan: perfect
2023-06-16 17:31:24 -0400 < acdw> you get me
2023-06-16 17:31:33 -0400 < acdw> also, get rid of == . just "is"
2023-06-16 17:31:41 -0400 < acdw> need more specificity? "is really"
2023-06-16 17:31:52 -0400 < jcowan> that's different, "is" is "eq?"
2023-06-16 17:31:57 -0400 < jcowan> or "eqv?"
2023-06-16 17:31:59 -0400 < acdw> javascript's === turns into "is really without a doubt"
2023-06-16 17:32:07 -0400 < acdw> hm
2023-06-16 17:32:15 -0400 < acdw> this is why i'm not a programming language designer
2023-06-16 17:32:19 -0400 < jcowan> === is eqv? whereas == is "is stupidly equal to"
2023-06-16 17:32:25 -0400 < acdw> lol
2023-06-16 17:32:50 -0400 < acdw> also there should be something like and overloading, so you could say "if a and b are equal" or "if a and b are different"
2023-06-16 17:33:01 -0400 < acdw> and also "if a is 6 and b is 9"
2023-06-16 17:33:15 -0400 < acdw> the compiler will just be ChatGPT
2023-06-16 17:33:20 -0400 < jcowan> Starting to sound like Cobol
2023-06-16 17:33:33 -0400 < acdw> some say the old ways are best
2023-06-16 17:33:41 -0400 < jcowan> Up to a point, Minister
2023-06-16 17:34:13 -0400 < wasamasa> I'm kinda surprised fortran does not need line terminators
2023-06-16 17:34:30 -0400 < jcowan> Well, that's because EOL is the line terminator
2023-06-16 17:34:36 -0400 < jcowan> s/line/statement
2023-06-16 17:34:41 -0400 < wasamasa> pytran
2023-06-16 17:34:57 -0400 < acdw> emoji terminators
2023-06-16 17:35:14 -0400 < jcowan> The problem is always the keyboard
2023-06-16 17:35:19 -0400 < acdw> honestly it's all just syntax right? relaly the imprtant thing is semantics
2023-06-16 17:35:21 -0400 < acdw> allegedly
2023-06-16 17:35:26 -0400 < wasamasa> I dunno
2023-06-16 17:35:28 -0400 < jcowan> unless you have a Chinese-typewriter keyboard with 800 keys
2023-06-16 17:35:36 -0400 < wasamasa> fortran also has the weird thing where boolean operators are surrounded with periods
2023-06-16 17:35:49 -0400 < acdw> in the perfect language there would be no digits. only spelled-out numbers
2023-06-16 17:36:12 -0400 < wasamasa> and a very ugly format function
2023-06-16 17:36:14 -0400 < jcowan> That's because < and > did not exist on the 026 keypunch, and spaces are meaningless in Fortran
2023-06-16 17:36:38 -0400 < jcowan> Ugly!  Ugly bags of FORMAT statements!
2023-06-16 17:36:50 -0400 < wasamasa> who'd have guessed printing text without arbitrary restrictions would require a new fortran standard
2023-06-16 17:37:39 -0400 < wasamasa> anyway, I guess we're completely derailing the channel
2023-06-16 17:37:43 -0400 < wasamasa> what even brought up this topic
2023-06-16 17:38:45 -0400 < jcowan> hence the difference between "DO 10 I = 1, 26" (where 10 is the label for the end statement) and "DO 10 I = 1. 26", which is an assignment statement
2023-06-16 17:39:08 -0400 < jcowan> i.e. "DO10I = 1.26"
2023-06-16 17:39:12 -0400 < acdw> ,scheme-related fortran
2023-06-16 17:39:13 -0400 < acdw> wait
2023-06-16 17:39:46 -0400  * jcowan waits
2023-06-16 17:39:55 -0400  * acdw forgets what he was talking about
2023-06-16 17:40:38 -0400 < jcowan> That's all right, you are not paid to know.
2023-06-16 17:42:59 -0400 < acdw> heh
2023-06-16 19:42:49 -0400 < edgar-rft> rudybot: Scheme causes caries
2023-06-16 19:42:50 -0400 < rudybot> edgar-rft: Don't use macros. They cause caries.
2023-06-16 19:44:12 -0400 < edgar-rft> rudybot: why do you think that only macros are causing caries?
2023-06-16 19:44:13 -0400 < rudybot> edgar-rft: not to mention causing dental caries and diabetes
2023-06-16 19:44:26 -0400 < edgar-rft> OMG - diabetes, too?
2023-06-16 20:07:50 -0400 < mdhughes> I love how goofy fi, esac, etc. are in shell. do/end sucks, I wish they'd chosen while/wend. A bunch of structured BASICs have that, but always go for boring endif, etc.
2023-06-16 20:11:08 -0400 < mdhughes> LOGO makes nice readable syntax out of LISP, but you have to know the arity of all functions or wrap everything in [] and then you're back to nested parens.
2023-06-16 20:30:24 -0400 < acdw> apparently they couldn't use od because it was already a command
2023-06-16 20:30:36 -0400 < acdw> while/elihw
2023-06-16 20:30:41 -0400 < acdw> why is do even a thing
2023-06-16 20:30:55 -0400 < acdw> while test; ..... elihw
2023-06-16 20:31:08 -0400 < acdw> for thing in thing; ... rof
2023-06-16 20:33:03 -0400 < edgar-rft> strangely there is no odd command: /which odd -> file or directory not found :-)
2023-06-16 20:49:55 -0400 < gwatt> acdw: do / then exist to allow multiple statements ase part of the condition
2023-06-16 20:54:51 -0400 < mdhughes> You can assume multiple statements just like if then ... else ... fi
2023-06-16 20:55:40 -0400 < acdw> oh right I forgot about that
2023-06-16 20:56:01 -0400 < acdw> could've been if/do or while/then
2023-06-16 23:55:18 -0400 < lockywolf> amirouche: I think it is actually  Programming Language Theory
--- Day changed Sat Jun 17 2023
2023-06-17 00:07:35 -0400 < mdhughes> They actually thought it up at lunch. It's a Prosciutto Lettuce Tomato sandwich.
2023-06-17 00:15:25 -0400 < acdw> when the prosciutto is nice and lean
2023-06-17 00:17:34 -0400 < lockywolf> unrelated to scheme, but can anyone recommend a 15-minute set of exercises to combat programming-related body mis-morphisms?
2023-06-17 00:18:01 -0400 < lockywolf> beside the obvious squats and pull-ups on a horisontal bar
2023-06-17 00:19:05 -0400 < acdw> https://rash-lang.org/ speak of the shell
2023-06-17 04:24:03 -0400 < amirouche> lockywolf: I just go the gym and do back musucle exercices, and cardio
2023-06-17 04:25:10 -0400 < mdhughes> I do the opposite. After a few hours of sitting with perfect posture, I either slouch & throw my leg over the chair, or go lay down in the comfy chair and nap.
2023-06-17 04:25:37 -0400 < amirouche> my current streak is gym every two days, my goal is twice a day
2023-06-17 04:26:28 -0400 < mdhughes> I do get exercise, walk miles a few times a week, but slacking off works just as well for not being deformed by the office.
2023-06-17 05:47:20 -0400 < rudybot> la la la
2023-06-17 07:48:09 -0400 < rudybot> la la la
2023-06-17 08:52:53 -0400 < jcowan> rudybot is quite indifferent to human needs for exercise
2023-06-17 10:49:15 -0400 -!- mdhughes_ is now known as mdhughes
2023-06-17 14:18:11 -0400 < sham1> It has no time for such things
2023-06-17 15:28:25 -0400 < edgar-rft> humans need exercise?
2023-06-17 15:32:26 -0400 < edgar-rft> (define exercise? (lambda (argh) #f))
2023-06-17 16:59:11 -0400 < tomhg> Hey #scheme. I don't _really_ grasp induction. When thinking about it on my own I get lost in my mind. I have read it in multiple literature and sometimes It is so obvious that I could skip the entire section. But I am unable to do an induction on my own. Could anyone recommend a ELI5-reference? And; I am unable to make an example. So per induction I should be able to prove I am unable to use induction.
2023-06-17 17:01:16 -0400 < leah2> do you mean for proofs?
2023-06-17 17:01:30 -0400 < tomhg> Yes; But is there another induction?
2023-06-17 17:01:49 -0400 < leah2> in physics /hj
2023-06-17 17:02:07 -0400 < tomhg> HEhe. Was thinking about stoves. The former only.
2023-06-17 17:02:58 -0400 < leah2> perhaps try reading this? http://web.stanford.edu/class/archive/cs/cs103/cs103.1164/handouts/240%20Guide%20to%20Induction.pdf
2023-06-17 17:03:19 -0400 < leah2> doing some proofs in coq e.g. could also help
2023-06-17 17:03:55 -0400 < leah2> e.g. the second chapter of https://softwarefoundations.cis.upenn.edu/lf-current/toc.html
2023-06-17 17:04:57 -0400  * tomhg dives. Thank you so much. I will take these on.
2023-06-17 17:04:59 -0400 < leah2> the "skill" there is to fiddle with the n+1 case until if have the n case as a subexpression usually
2023-06-17 17:05:08 -0400 < leah2> s/if/you
2023-06-17 17:07:30 -0400 < leah2> https://users.metu.edu.tr/serge/courses/111-2011/textbook-math111.pdf chapter 6 also has more examples
2023-06-17 17:15:30 -0400 < tomhg> That last link suggests that it may be indeed my understanding of mathematical logic which is lacking. I take all of those on. Thanks, leah2. *waves*
2023-06-17 17:16:23 -0400 < leah2> perhaps it also helps to think of a recursive program
2023-06-17 19:38:33 -0400 < mdhughes> Exercises are the problem sets in SICP.
2023-06-17 19:40:56 -0400 < mdhughes> Back in my day, we had to do theorem proving & induction in Geometry class. I think that was removed from most schools because it taught people to think.
2023-06-17 20:33:13 -0400 < jcowan> Naah.  I did those problems.  All they taught was formal manipulation of symbols.  You could (and people did) write programs to find proofs.
2023-06-17 20:35:19 -0400 < mdhughes> You've solved program generation of programs?
2023-06-17 20:37:34 -0400 < dpk> > never was a wolf in sheep’s clothing as insidious, nor a false friend as treacherous, as High School Geometry. It is precisely because it is school’s attempt to introduce students to the art of argument that makes it so very dangerous.
2023-06-17 20:37:45 -0400 < dpk> https://usercontent.irccloud-cdn.com/file/k5wGulTq/Screenshot%202023-06-18%20at%2002.37.10.png
2023-06-17 20:40:21 -0400 < jcowan> (One such program found a very clever proof that the base angles of an isoceles triangle are equal without bisecting the third angle: given a triangle ABC and its counterpart CBA, the triangles are congruent SAS, ergo angle BAC = angle BCA.)
2023-06-17 20:42:09 -0400 < leah2> dpk: working in a formal system is probably the most valuable part of teaching this...
2023-06-17 22:50:18 -0400 -!- Andrew is now known as Guest4791
--- Day changed Sun Jun 18 2023
2023-06-18 06:00:40 -0400 -!- AndrewYu is now known as Andrew
2023-06-18 11:47:57 -0400 < Zipheir> dpk: It wouldn't be so bad if you weren't taught to "argue" in an incredibly rigid and artificial format.
2023-06-18 11:49:01 -0400 < Zipheir> I also recall never proving anything outside of geometry in "high school". (I was homeschooled, so YMMV!)
2023-06-18 11:49:08 -0400 < dpk> i think that’s more or less the essence of Lockhart’s argument
2023-06-18 11:49:17 -0400 < Zipheir> Yes. That's a terrific essay.
2023-06-18 12:12:01 -0400 < leah2> is it pro or contra proofs i forgot :p
2023-06-18 12:14:08 -0400 < Zipheir> Pro.
2023-06-18 12:14:12 -0400 < leah2> good
2023-06-18 12:15:09 -0400 < leah2> first step is make math teachers that can do proofs :p
2023-06-18 12:15:23 -0400 < Zipheir> Sadly, true.
2023-06-18 12:16:01 -0400 < Zipheir> It's a lot harder to teach creative argumentation than it is to teach a few algorithms.
2023-06-18 12:19:36 -0400 < Zipheir> Which gets to another neglected part of the curriculum: programming, or, at least, programming as creative argumentation.
2023-06-18 12:20:30 -0400 < leah2> in the future we just need monkeys feeding gpt4
2023-06-18 12:23:01 -0400 < Zipheir> Maybe another way to put is is that you'll have to play "monkey feeds GPTk" in order to get things done.
2023-06-18 12:23:54 -0400 < Zipheir> I'm guessing that the next Windows is going to have an AI-assist layer for a lot of things.
2023-06-18 13:36:50 -0400 < cow_2001> did a few stuff today with this https://git.sr.ht/~kakafarm/guile-clipboard-speaker/log
2023-06-18 14:10:42 -0400 < sham1> Has there been any kind of an R7-Large proposal for some sort of port introspection. For example to see if a port was opened on an actual file and if it was, to get its filename
2023-06-18 14:10:57 -0400 < sham1> Because I reckon that it might be useful for some things
2023-06-18 15:08:10 -0400 < jcowan> sham1: There has not.  But it would be a Good Thing, so start writing a spec, if you like.
2023-06-18 15:53:14 -0400 < ecraven> position too ;)
2023-06-18 15:53:26 -0400 < Zipheir> sham1: That seems like the tip of an iceberg: port properties.
2023-06-18 15:53:29 -0400 < ecraven> as in bytes read / written since the start
2023-06-18 15:53:44 -0400 < sham1> We already have port position tho
2023-06-18 15:54:15 -0400 < ecraven> hm.. sorry, the point where I've met the need for port position is r6rs custom ports, not sure whether they made it into r7rs-large already?
2023-06-18 15:54:32 -0400 < sham1> Oh, I was just thinking in terms of the SRFI
2023-06-18 15:54:42 -0400 < sham1> I would *assume* that being in R7-Large
2023-06-18 15:54:53 -0400 < sham1> I don't know where I'd check that tho
2023-06-18 15:55:18 -0400 < sham1> These things aren't listed in codeberg, I don't believe anyway
2023-06-18 15:59:06 -0400 < Zipheir> sham1: It could use something like SRFI 35 condition property accessors. e.g. if you want the filename property, you might use (port-property-ref <port> 'filename).
2023-06-18 16:00:11 -0400 < Zipheir> (I thought of SRFI 35 rather than R6 conditions because they avoid the record type inheritance issue.)
2023-06-18 16:00:25 -0400 < Zipheir> (But you might *want* inheritance among port types...)
2023-06-18 16:04:17 -0400 < sham1> I'm just thinking about how that kind of thing would be integrated into custom ports
2023-06-18 16:06:54 -0400 < Zipheir> Looking at SRFI 181, I wonder if custom ports are even ports in the sense of the standard predicates. (input-port?, etc.) The SRFI doesn't require anything.
2023-06-18 16:08:45 -0400 < sham1> Well with names such as "make-custom-binary-input-port" and such, I'd expect that any implementation that *didn't* have them satisfy those predicated would be quite annoying to work with, especially since an implementation could use custom ports to implement "standard" ports
2023-06-18 16:09:13 -0400 < sham1> After all, why duplicate the effort in making ports and then custom ports when all ports could be "custom" which then just wrap whatever underlying OS capability or whatever
2023-06-18 16:09:56 -0400 < Zipheir> Yeah. It's just surprising that "port-ness" isn't in the spec.
2023-06-18 16:10:01 -0400 < sham1> Of course SRFI 181 doesn't specify char-ready? and u8-ready? states, which can complicate matters, but nothing an implementation couldn't specify for itself
2023-06-18 16:11:19 -0400 < sham1> Of course I'd personally extend the custom binary and textual input ports with a ready? predicate that would by default probably have to return #t in lieu of a better value
2023-06-18 16:12:15 -0400 < sham1> After all, these things already take optional predicates like close, get-position/set-position! and such, so I don't think it'd be that controversial as an extra optional argument thing
2023-06-18 16:16:16 -0400 < Zipheir> Pedantically speaking, port-property-ref or port-filename or whatever could fail if applied to a custom port if it didn't satisfy port?.
2023-06-18 16:16:58 -0400 < sham1> Yeah, so I'd say that it should really require that. Errata or fixing for R7-large, I dunno
2023-06-18 16:17:04 -0400 < Zipheir> So any specification of custom port properties is going to be a little bit unportable until that's fixed.
2023-06-18 16:20:23 -0400 < Zipheir> jcowan: Would that be a reasonable erratum to 181?
2023-06-18 16:22:10 -0400 < Zipheir> I think it's already heavily implied that custom textual and binary ports satisfy the appropriate predicates, but I think the Specification should say that all custom ports satisfy port?.
2023-06-18 16:22:28 -0400 < Zipheir> Well, maybe I'm reading too pedantically.
2023-06-18 16:25:10 -0400 < Zipheir> Yes, on second thought, I am. All of the constructors say they return ports, and that's good enough.
2023-06-18 16:25:16 -0400 < Zipheir> jcowan: Sorry, disregard.
2023-06-18 16:56:18 -0400 < dpk> it's probably deliberate that SRFI 181 ports are unclear, because at that time there was still the idea that R7RS Large would be 99% something you could implement on top of any R7RS small
2023-06-18 17:03:02 -0400 < jcowan> dpk: Naah, it was just carelessness on my part.
--- Day changed Mon Jun 19 2023
2023-06-19 05:27:20 -0400 < sham1> So if I was to start specifying the port filename/properties thing, would I have to go with an SRFI or something else?
2023-06-19 11:58:22 -0400 < jcowan> sham1: Write it down first; you or someone else can then edit it into SRFI format.
2023-06-19 12:01:45 -0400 < ecraven> hm.. is this some general pattern? I want to create a nested structure (sxml describing html) and need to put values in some places that I don't know yet when I create the structure. I want to fill them in later. what's a good way to do this? lenses?
2023-06-19 12:04:10 -0400 < gwatt> If you've got them, lenses work.
2023-06-19 12:05:41 -0400 < gwatt> I guess if you don't otherwise need to access the data until you've filled it in, returning a closure that completes the construction
2023-06-19 12:06:28 -0400 < gwatt> could also work
2023-06-19 12:39:49 -0400 < Zipheir> sham1: I can help.
2023-06-19 12:40:03 -0400 < sham1> That'd ne moce
2023-06-19 12:40:07 -0400 < sham1> That'd be nice*
2023-06-19 12:41:52 -0400 < amirouche> moar srfi
2023-06-19 12:41:54 -0400 < amirouche> :)
2023-06-19 12:47:26 -0400 < Zipheir> If you do write a SRFI, someone has to prepare you for Marc's inevitable critique. :)
2023-06-19 13:11:06 -0400 < jcowan> Yes.  But you don't have to satisfy him if you think he's being unreasonable.
2023-06-19 13:11:38 -0400 < jcowan> Provided you meet the formal requirements, it's totally up to the author when and how a SRFI becomes final.
2023-06-19 13:19:04 -0400 < amirouche> beware you can not undo it ;)
2023-06-19 13:25:34 -0400 < sham1> Well for something as uncontroversial like this, it shouldn't be too bad. The biggest problem I could see is the whole problem with filenames as laid out in codeberg but for now it could be specified to do things in a best-effort basis
2023-06-19 13:29:13 -0400 < amirouche> Nobody told me why generators (or a variation) can not replace ports
2023-06-19 13:29:19 -0400 < amirouche> ?
2023-06-19 13:30:00 -0400 < sham1> But ports are generators, just older and more general
2023-06-19 13:30:06 -0400 < sham1> Err, less general
2023-06-19 13:30:43 -0400 < sham1> I mean, IIRC that's a part of the reason why the sentinel for generators is EOF since it means that ports just work automagickally
2023-06-19 13:31:51 -0400 < amirouche> yes, that is also why I prefer a generator with a dedicated EOF object
2023-06-19 13:33:22 -0400 < amirouche> ports do not blend nicely, it is a special case, with subcases; even more special than numbers, the latter being well understood by a majority users
2023-06-19 13:34:27 -0400 < sham1> One could have specified a separate way to signal the end of the generator, but then you'd need an adapter from ports to that abstraction and then it'd be more annoying for implementations to have to introduce a new type and either reserve a new immediate value or allocate something that trivial on the heap
2023-06-19 13:34:49 -0400 < gwatt> I think they're maybe slightly incompatible, since EOF doesn't actually mean you can't get more from the port
2023-06-19 13:34:52 -0400 < sham1> And then you'd get the same issue as with a generator of EOF, but with this end token instead
2023-06-19 13:35:59 -0400 < amirouche> what are immediate values? how is that related to "allocating something that is trivial on the heap"?
2023-06-19 13:36:12 -0400 < sham1> Think fixnums
2023-06-19 13:36:14 -0400 < amirouche> immediate values = tagged pointers?
2023-06-19 13:36:17 -0400 < sham1> Or booleans
2023-06-19 13:36:24 -0400 < sham1> That's one way of doing it, yes
2023-06-19 13:36:43 -0400 < gwatt> probably "a value that needs no allocation"
2023-06-19 13:37:00 -0400 < sham1> Yeah, that's a nice way of putting it
2023-06-19 13:37:03 -0400 < amirouche> ty
2023-06-19 13:37:20 -0400 < sham1> One *could* signal a condition for the end of the generator, like Python, but please no
2023-06-19 13:38:08 -0400 < amirouche> anyway, I am just discussing another point of view, as usual I do not have the perfect answer...; Tho, I understand why I like something like generators: from a pedagogical perspective they are easier to teach
2023-06-19 13:38:12 -0400 < sham1> Or maybe ask if the generator has been exhausted
2023-06-19 13:39:28 -0400 < amirouche> My brain is hard wired to "one type = one set of procedure", if you need more than that set of procedure, I need to "promote the object to another type" something like that
2023-06-19 13:42:32 -0400 < amirouche> In a perfect world, we need to do a review how they are used: files, sockets (tcp, udp), including those that support tls, and async, files, possibly stuff like zeromq / zmq
2023-06-19 13:43:02 -0400 < sham1> Meanwhile I come from OO and the like where this kind of polymorphism is expected
2023-06-19 13:44:05 -0400 < sham1> As far as I am personally concerned, ports essentially exhibit interference inheritance and mixins
2023-06-19 13:44:14 -0400 < sham1> Interface inheritance*
2023-06-19 13:44:33 -0400 < amirouche> good luck sham1
2023-06-19 13:44:39 -0400 < amirouche> I will read that SRFI with great interest
2023-06-19 13:45:54 -0400 < sham1> And of course, ports differ from each other in many fundamental ways. Some deal with binary numbers, some with text. Some are generators of those things, some are sinks because they output. And some abstract the idea of reading from or writing to either a bytevector or string as it may be
2023-06-19 13:45:55 -0400 < Zipheir> amirouche: You mean could generators replace *output* ports, and accumulators, input?
2023-06-19 13:46:04 -0400 < Zipheir> amirouche: A generator cannot be both.
2023-06-19 13:46:07 -0400 < amirouche> Zipheir: yes
2023-06-19 13:46:31 -0400 < Zipheir> Well, I can see output ports being generators, but not the latter.
2023-06-19 13:46:34 -0400 < sham1> A generator would have to replace input ports because it's a source, not a sink
2023-06-19 13:47:02 -0400 < Zipheir> You mean "output" ports, right?
2023-06-19 13:47:19 -0400 < amirouche> yes generator for output, and accumulator for input
2023-06-19 13:48:21 -0400 < amirouche> I could propose my network library for SRFI, but I have at least two or three other SRFI to debug..
2023-06-19 13:48:37 -0400 < Zipheir> Argh, I'm getting dyslexic about the in and out directions.
2023-06-19 13:48:59 -0400 < Zipheir> Generators are like input ports.
2023-06-19 13:48:59 -0400 < amirouche> it looks very much like the existing network SRFI, except for some cosmetic name change, and... generator, and accumulators here, and there
2023-06-19 13:49:14 -0400 < sham1> An input port is what you read from
2023-06-19 13:49:19 -0400 < sham1> And output port is what you write to
2023-06-19 13:49:28 -0400 < Zipheir> Yes, sorry.
2023-06-19 13:50:43 -0400 < amirouche> generator will produce what was send from the remote, it outputs the message in the host. Whereas the accumualtor will send a message from the host, to the remote, hence it input a message from local host, and... "output" (read: send it) it to the remote
2023-06-19 13:51:07 -0400 < Zipheir> I guess the main difference between generators and input ports is that generators are not (and probably never will be) a unique type.
2023-06-19 13:51:18 -0400 < amirouche> that is another question I have
2023-06-19 13:51:20 -0400 < sham1> Generators are an interface
2023-06-19 13:51:34 -0400 < amirouche> why generators will never be a unique type?
2023-06-19 13:51:37 -0400 < sham1> Or a typeclass if one is so inclined
2023-06-19 13:52:13 -0400 < Zipheir> They've already been specified to be vanilla procedures in several SRFIs (one of which, 158, is in R7RS-large, FWIW).
2023-06-19 13:52:24 -0400 < amirouche> true true
2023-06-19 13:52:49 -0400 < Zipheir> Accumulators can't be output ports. You use accumulators to get a final result, not for side effects.
2023-06-19 13:53:08 -0400 < amirouche> oh
2023-06-19 13:53:12 -0400 < sham1> Could accumulate up to #f maybe?
2023-06-19 13:53:18 -0400 < sham1> Like have the result just be #f
2023-06-19 13:53:20 -0400 < sham1> Or (values)
2023-06-19 13:53:43 -0400 < Zipheir> Right. You could think of an output port as an accumulator with a meaningless value.
2023-06-19 13:54:04 -0400 < Zipheir> But it's not the most beautiful idea, IMHO.
2023-06-19 13:54:39 -0400 < Zipheir> You'll never actually pass it (eof-object), so you'll never get the (meaningless) value.
2023-06-19 13:59:32 -0400 < Zipheir> Generators are also, arguably, a kludge, since they treat EOF as an in-band signal object. The RnRS authors did a pretty good job on ports.
2023-06-19 14:01:01 -0400 < sham1> Well as I theorised, it was probably made the in-band signal object in order to make input ports into generators as-is
2023-06-19 14:02:18 -0400 < jcowan> sham1: Just so.
2023-06-19 14:03:17 -0400 < sham1> Oh nice
2023-06-19 14:04:17 -0400 < Zipheir> The connection between output ports and accumulators is more complicated.
2023-06-19 14:06:09 -0400 < sham1> Like having a generator be its own special disjoint type like a comparator with a bunch of procedures would also work, and you could make the "I'm empty" signaling out-of-band, but thinking about it, I'm not sure how useful that might actually be
2023-06-19 14:28:47 -0400 < gwatt> Really, they're all just specializations of a double-ended queue.
2023-06-19 14:33:03 -0400 < jcowan> Only in the sense that the stack is.
2023-06-19 14:41:52 -0400 < Zipheir> Only in the sense that the world is.
2023-06-19 15:29:50 -0400 < amirouche> re ports: interesting convo +1
2023-06-19 15:29:53 -0400 < amirouche> ty
2023-06-19 15:55:39 -0400 < shawnw> A lot of SRFIs could stand to be rewritten in terms of 189 (Maybe and Either types).
2023-06-19 15:56:47 -0400 < Zipheir> SRFI 189 is very controversial, for something so simple.
2023-06-19 15:59:16 -0400 < gwatt> It's easy to have knee-jerk opinions about simple things.
2023-06-19 15:59:46 -0400 < Zipheir> It hasn't been used much by SRFI authors since it came out. I originally designed the SRFI 224 library to use Maybe/Either, but MNW eventually persuaded me that it was better to use CPS instead.
2023-06-19 16:00:02 -0400 < acdw> Maybe!
2023-06-19 16:00:58 -0400 < Zipheir> gwatt: True, it's something like a bikeshed problem. It's like CLers getting passionate about nil.
2023-06-19 16:01:43 -0400 < sham1> I don't actually think that they're all that useful. Usually one can just rewrite the things in terms of either CPS or value-or-#f
2023-06-19 16:01:54 -0400 < gwatt> But I think a problem with the SRFIs is that 1) They're not nearly as authoritative as JEPs or PEPs. 2) They have ambiguous scope. 3) They can become "finalized" even if no one really cares about them.
2023-06-19 16:01:56 -0400 < amirouche> +1 gwatt
2023-06-19 16:02:06 -0400 < Zipheir> sham1: You can *always* use CPS instead.
2023-06-19 16:02:24 -0400 < sham1> Well yeah, but you know what I mean
2023-06-19 16:02:29 -0400 < amirouche> still, SRFI-189 is very interesting, ty.
2023-06-19 16:02:53 -0400 < amirouche> interesting, and important.
2023-06-19 16:02:54 -0400 < acdw> https://ntietz.com/blog/introducing-hurl/ i read this this morning, is it at all related to CPS (like a similar idea)?
2023-06-19 16:03:00 -0400 < Zipheir> sham1: There are ugly CPS patterns that can be avoided by using Maybe/Either, though.
2023-06-19 16:03:06 -0400 < acdw> or maybe not (I know ver little bout all this lol)
2023-06-19 16:03:31 -0400 < sham1> Honestly, I'd rather see more use of the happy path being just a value being returned and then if there is an error, then you'd have an error raised
2023-06-19 16:03:36 -0400 < Zipheir> gwatt: They can always be superseded when people *do* start to care about them.
2023-06-19 16:03:55 -0400 < sham1> In some way Scheme seems to be devoid of throwing exceptions even though we do have the ability to do it
2023-06-19 16:04:22 -0400 < sham1> Like in the wider ecosystem. Now, I suppose a part of it is that an exception system hasn't really existed officially before R6 and R7, but still
2023-06-19 16:04:35 -0400 < Zipheir> Partially because of the confusion surrounding conditions outside of R6.
2023-06-19 16:04:52 -0400 < Zipheir> sham1: You mean "values", I assume.
2023-06-19 16:06:29 -0400 < gwatt> Zipheir: that's true, but if people don't in general care about the SRFI, why was it finalized? There's no real obligation to support a given SRFI anyway, but cluttering up the list with ignored ones seems less than ideal.
2023-06-19 16:06:30 -0400 < Zipheir> "failure values" are completely intuitive. hashtable-ref probably shouldn't raise an exception if a key doesn't exist.
2023-06-19 16:07:26 -0400 < Zipheir> gwatt: I don't think anyone wants a popularity (number of ml messages?) requirement for SRFI finalization.
2023-06-19 16:08:16 -0400 < Zipheir> gwatt: 95% of the issues with the SRFI process come down to participation.
2023-06-19 16:08:49 -0400 < sham1> Zipheir: well yeah, multiple values if it's appropriate
2023-06-19 16:09:32 -0400 < Zipheir> sham1: Let's say you have hashtables with multiple values. Then hashtable-ref returns multiple values or fails. This is a perfect use for Maybe, which is either (just v1 v2 ...) or (nothing).
2023-06-19 16:10:07 -0400 < Zipheir> The alternative would be success and failure continuations, or just success and a default value.
2023-06-19 16:10:35 -0400 < sham1> In other languages you usually do get some kind of an error if you're looking up a key that doesn't exist in a map
2023-06-19 16:10:40 -0400 < Zipheir> Actually, default values are awkward with MV procedures. Anyway, you can see the niche that Maybe and Either might have.
2023-06-19 16:11:34 -0400 < sham1> Sure, I get the uses for Maybe and Either. I don't think that they're exactly as nice as in something like Haskell tho. Maybe that's just me not being used to them
2023-06-19 16:12:23 -0400 < gwatt> I'm not trying to suggest that message volume be a determinant, just saying that I think the "finalized" status conveys very little information about its desirability or benefit.
2023-06-19 16:12:24 -0400 < Zipheir> They're certainly a lot more important in a statically-typed language.
2023-06-19 16:13:25 -0400 < Zipheir> gwatt: OK. I don't think it does convey much more than "final".
2023-06-19 16:13:52 -0400 < gwatt> and I guess I'm also saying that I wish the status would convey more than that. :-/
2023-06-19 16:14:19 -0400 < Zipheir> Maybe the status should include emoji. :)
2023-06-19 16:14:24 -0400 < acdw> yes
2023-06-19 16:16:12 -0400 < Zipheir> sham1: Another slightly interesting thing is how Scheme library designers have been dancing around Maybe/Either. John made a "protocol conversion" section of SRFI 189 for converting all of the ways procedures can succeed/fail to Maybe or Either.
2023-06-19 16:18:08 -0400 < Zipheir> These protocols include "list" (list of values or ()), "truth" (value-or-false), "list-truth" (list-or-false), "generation" (value-or-EOF), etc.
2023-06-19 16:18:22 -0400 < sham1> two-values
2023-06-19 16:18:27 -0400 < Zipheir> Yeah, there are more.
2023-06-19 16:27:47 -0400 < tomhg> Hey #scheme. Here's some love for you to pick up.
2023-06-19 16:31:23 -0400  * jcowan scoops up the love and wraps it in a Just.
2023-06-19 16:38:01 -0400 < tomhg> Always teaching. We had one course concerned with Boolean Algebra, Proofs and Induction. Written supplementary material introduced induction in haskell. Some lectures ended with the Prof saying that he errored and our writings are be obsolete. Just 20% succeed in the class. I succeeded with 19/90 points at my second attempt. Learned every exercise I could get hands on. I would need to read through the
2023-06-19 16:38:07 -0400 < tomhg> excellent book linked earlier. But it just got put into my reading list for now..
2023-06-19 16:38:23 -0400 < tomhg> -be
2023-06-19 19:01:05 -0400 < Ren[m]> even if all the functional patterns will eventually get a SRFI number, there's still more: we have several SXML normal forms and there's at least two C (or some asm) renditions in s-expressions though half abandoned
2023-06-19 19:38:00 -0400 < Zipheir> tomhg: Still, IIUC it's impressive that you used Haskell in a math course.
2023-06-19 23:05:25 -0400 -!- greaser|q is now known as GreaseMonkey
--- Day changed Tue Jun 20 2023
2023-06-20 02:36:38 -0400 -!- mirai_ is now known as mirai
2023-06-20 13:42:06 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-20 14:33:17 -0400 < cedb> are there any libraries for total programming in scheme?
2023-06-20 14:33:48 -0400 < gwatt> what is "total programming"
2023-06-20 14:34:04 -0400 < cedb> i mean, that might be much but just a constraint language to make reactive proramming more "optimizable"
2023-06-20 14:34:09 -0400 < cedb> gwatt: non turing complete
2023-06-20 15:15:16 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-20 16:08:26 -0400 < Zipheir> cedb: It might help if you gave an example of such a thing from another language.
2023-06-20 20:10:05 -0400 < jcowan> cedb: If you mean Total Functional Programming, then no, there's no library for that that I know of.
2023-06-20 20:10:37 -0400 < jcowan> Zipheir: https://en.wikipedia.org/wiki/Total_functional_programming#:~:text=Total%20functional%20programming%20(also%20known,those%20that%20are%20provably%20terminating.
2023-06-20 20:11:58 -0400 < jcowan> https://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
2023-06-20 20:26:41 -0400 < Zipheir> Yes, that's what I thought cedb was talking about before the mention of "reactive".
2023-06-20 20:29:27 -0400 < edgar-rft> let's start using Scheme for buzzword-oriented programming
--- Log closed Tue Jun 20 20:30:59 2023
--- Log opened Tue Jun 20 20:31:12 2023
2023-06-20 20:31:12 -0400 -!- Irssi: #scheme: Total of 208 nicks [0 ops, 0 halfops, 0 voices, 208 normal]
2023-06-20 20:31:12 -0400 -!- Irssi: Join to #scheme was synced in 6 secs
2023-06-20 21:19:05 -0400 < cow_2001> https://0x0.st/HTgB.txt
2023-06-20 21:19:22 -0400 < cow_2001> https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo
2023-06-20 21:19:25 -0400 < cow_2001> sorry
2023-06-20 21:46:27 -0400 < acdw> buffalo!
--- Day changed Wed Jun 21 2023
2023-06-21 02:34:36 -0400 -!- gahr_ is now known as gahr
2023-06-21 03:10:16 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-21 05:10:17 -0400 < wasamasa> cedb: the nice thing about scheme (or rather, lisp languages in general) is that you can implement a lot of programming concepts yourself
2023-06-21 05:11:00 -0400 < wasamasa> cedb: SICP for example has exercises for implementing scheme evaluators with very different semantics than usual
2023-06-21 05:11:10 -0400 < cedb> yeah i just have a computational graph where the fucntions are defined in scheme
2023-06-21 05:11:29 -0400 < cedb> and id like some constraints on that to be able to optimize the number of recomputations
2023-06-21 05:11:45 -0400 < cedb> instead of just arbitrary scheme code
2023-06-21 05:13:03 -0400 < wasamasa> scheme is surprisingly nice for implementing type systems, interpreters, compilers, ...
2023-06-21 05:13:32 -0400 < wasamasa> I'm currently working on a very dumb XCB code generator :D
2023-06-21 05:13:46 -0400 < cedb> not surprinslgy to me
2023-06-21 05:14:04 -0400 < wasamasa> so is SML I guess
2023-06-21 05:14:08 -0400 < cedb> what im wondering is just what kind of restrictions do people put on those kind of computations
2023-06-21 05:14:22 -0400 < cedb> MLs main reason to be are compilers in general i guess
2023-06-21 05:14:24 -0400 < wasamasa> I dunno, the closest I've encountered to this is sandboxed evaluators
2023-06-21 05:14:41 -0400 < cedb> i mean i can tweak the interpreter
2023-06-21 05:14:43 -0400 < wasamasa> which are very close to a normal scheme eval, but add some extra features like the concept of "fuel"
2023-06-21 05:15:13 -0400 < cedb> hmm never heard of those
2023-06-21 05:15:27 -0400 < wasamasa> http://wiki.call-cc.org/eggref/5/sandbox
2023-06-21 05:15:48 -0400 < wasamasa> > Runaway evaluation (for example by executing endless loops) and excessive allocation can be caught by specifying appropriate limits on execution time and storage.
2023-06-21 05:16:09 -0400 < cedb> right hmm thats a bit different, incremental computation is not defensive
2023-06-21 05:16:18 -0400 < wasamasa> no, it just limits the blast radius
2023-06-21 05:16:22 -0400 < cedb> its just about giving the right primitives
2023-06-21 05:16:30 -0400 < wasamasa> what you want is probably more like the BPF prover
2023-06-21 05:16:47 -0400 < wasamasa> which takes a look at the code and only accepts it if it looks like it will terminate
2023-06-21 05:17:03 -0400 < wasamasa> s/prover/verifier/
2023-06-21 05:17:12 -0400 < cedb> ok so the total programming thing might have been mis phrased
2023-06-21 05:18:03 -0400 < cedb> its not about making sure it terminates, its just in general the less powerful the language the easier it is to optimize some things
2023-06-21 05:18:15 -0400 < sham1> SWL
2023-06-21 05:18:17 -0400 < sham1> SQL
2023-06-21 05:18:40 -0400 < cedb> lol like use the query engine to optimize for me?
2023-06-21 05:18:45 -0400 < wasamasa> the BPF verifier is of course not perfect, but shows some useful concepts
2023-06-21 05:19:05 -0400 < cedb> ya but its not about proving its about making faster
2023-06-21 05:19:09 -0400 < sham1> No, more like SQL is a good example of how a non-Turing complete language can be useful
2023-06-21 05:19:18 -0400 < cedb> oh right
2023-06-21 05:19:28 -0400 < sham1> The fact that I can be sure that an SQL query always halts is useful
2023-06-21 05:19:41 -0400 < wasamasa> https://www2.ccs.neu.edu/racket/pubs/oopsla12-stf.pdf
2023-06-21 05:19:43 -0400 < cedb> i mean yeah like pacman complete
2023-06-21 05:20:05 -0400 < cedb> what i want is something like this https://blog.janestreet.com/introducing-incremental/
2023-06-21 05:20:44 -0400 < cedb> theres a link between frp and incremental computin but its not a trivial identity
2023-06-21 05:21:42 -0400 < wasamasa> uhhh
2023-06-21 05:22:13 -0400 < wasamasa> I dunno, this smells like a problem/solution arising from use of FP
2023-06-21 05:22:23 -0400 < cedb> no its not
2023-06-21 05:22:50 -0400 < cedb> if you have any DAG of computations you have that setup
2023-06-21 05:23:03 -0400 < wasamasa> but why would you have that?
2023-06-21 05:23:13 -0400 < wasamasa> I mean, look at real-world GUIs, lol
2023-06-21 05:23:37 -0400 < wasamasa> react has a very generic algorithm for figuring out the changes to apply and dev tools to debug performance issues
2023-06-21 05:23:39 -0400 < cedb> why would you have a dag??
2023-06-21 05:24:11 -0400 < wasamasa> seemingly everything else does keep state in widgets
2023-06-21 05:24:43 -0400 < wasamasa> immediate mode GUIs have some very stupid heuristics for performance improvements
2023-06-21 05:24:52 -0400 < cedb> im not talking about guis here though
2023-06-21 05:25:02 -0400 < wasamasa> the assertion that FRP is a natural GUI paradigm feels like a very ML-centric view
2023-06-21 05:25:22 -0400 < cedb> as opposed to
2023-06-21 05:25:29 -0400 < wasamasa> the three examples I mentioned, lol
2023-06-21 05:25:39 -0400 < cedb> '"guis with widgets" ?
2023-06-21 05:25:41 -0400 < wasamasa> yes
2023-06-21 05:25:44 -0400 < wasamasa> very prevalent
2023-06-21 05:25:53 -0400 < wasamasa> you may in fact be using these right now
2023-06-21 05:25:54 -0400 < cedb> yes thats not very meaningful
2023-06-21 05:26:20 -0400 < wasamasa> stateful GUIs with widgets
2023-06-21 05:26:45 -0400 < cedb> yeah i mean thats not a theory
2023-06-21 05:26:59 -0400 < cedb> i guess message passing or something, but those are usually pretty adhoc
2023-06-21 05:27:31 -0400 < wasamasa> yeah, the elm architecture comes to mind
2023-06-21 05:35:36 -0400 < cedb> eh i wanna read up on elm but im stuck in react land for the moment
2023-06-21 05:47:03 -0400 -!- stultulo is now known as f8l
2023-06-21 07:22:45 -0400 < jcowan> Peggy the Prover is not Victor the Verifier (from the crypto zoo)
2023-06-21 07:27:26 -0400 -!- najlphk is now known as useuc
2023-06-21 10:07:26 -0400 < cow_2001> need ideas for stuff to write using guile
2023-06-21 11:01:26 -0400 < amirouche> happy birthday mdhughes!
2023-06-21 11:01:38 -0400 < mdhughes> OH NO how do people know?
2023-06-21 11:02:09 -0400 < mdhughes> Yes, it's… the best of times, as Kirk said.
2023-06-21 11:16:44 -0400 < gwatt> sham1: with recursive CTEs you can no longer have the termination guarantee with SQL
2023-06-21 11:19:54 -0400 < gwatt> well, you can always limit the results, so that does guarantee halting. But in the absence of that, recursive CTEs let you go forever
2023-06-21 11:19:56 -0400 < amirouche> cow_2001: a good native code compiler
2023-06-21 11:21:53 -0400 < amirouche> mdhughes: I need to test a crawler, and I need a target... Can I use https://mdhughes.tech/?
2023-06-21 11:23:06 -0400 < mdhughes> Probably fine. Like, don't let it be massively recursive or anything. I'm not sure how quickly Jetpack will take it as an attack, tho!
2023-06-21 11:23:31 -0400 < amirouche> we will soon know more about Jetpack!
2023-06-21 11:23:55 -0400 < mdhughes> There's some really big files, too. That might be trouble.
2023-06-21 11:28:55 -0400 < amirouche> :O
2023-06-21 11:36:40 -0400 < amirouche> btw the user agent is curl
2023-06-21 11:44:11 -0400 < jcowan> Some of the finiteness of SQL has to do with the finiteness of tables.  If you had an infinite table named "divisions" with attributes "dividend", "divisor", "quotient", then "SELECT dividend, divisor FROM divisions WHERE quotient = 6" would return an infinite number of rows.
2023-06-21 12:09:23 -0400 < mdhughes> Unless the dividend is profit, and division is corp organizational unit.
2023-06-21 12:10:08 -0400 < mdhughes> You might ask, "why is the field quotient", but I've seen some *shit* in SQL databases. Nothing shocks me anymore.
2023-06-21 13:00:39 -0400 < jcowan> My point is that the finite size of a table is not actually a SQL restriction.
2023-06-21 18:30:11 -0400 < mdhughes> True, it can be generated in a view or stored procedure that looks like a table.
2023-06-21 18:32:38 -0400 < mdhughes> Tho you're going to run into problems when you reach MAXINT rows in almost every SQL DB, even if you're computing values instead of using storage.
2023-06-21 18:47:30 -0400 < Zipheir> "We should be able to handle infinite pieces of music." "But Paul, no one could ever listen to an infinite piece." "Still..." (From a discussion between Paul Hudak and other people working on Haskell's Euterpea music library)
2023-06-21 19:25:01 -0400 < jcowan> Quite so. (Why is "Euterpea" spelled so oddly?)
2023-06-21 19:46:13 -0400 < mdhughes> You can file that in the Library of Babel: https://libraryofbabel.info/bookmark.cgi?haskell (middle of the page)
2023-06-21 20:23:57 -0400 < Zipheir> jcowan: No idea. I'm not sure how it's pronunced, either. https://www.euterpea.com/
2023-06-21 20:24:02 -0400 < Zipheir> *pronounced
2023-06-21 20:35:38 -0400 < pony> you ter pee a
2023-06-21 20:35:43 -0400 < pony> im pretty sure
2023-06-21 20:55:44 -0400 < Zipheir> Yeah, that's what I've been saying.
2023-06-21 23:21:43 -0400 < acdw> euterpe is the muse of music I believe? or is that calliope
2023-06-21 23:23:17 -0400 < acdw> yeah she's the muse of music. now idk why the a is on there
2023-06-21 23:24:00 -0400 < acdw> calliope is epic poetry
2023-06-21 23:40:29 -0400 < Zipheir> Functional programmers have yet to tackle that.
--- Day changed Thu Jun 22 2023
--- Log closed Thu Jun 22 00:38:48 2023
--- Log opened Thu Jun 22 00:39:03 2023
2023-06-22 00:39:03 -0400 -!- Irssi: #scheme: Total of 206 nicks [0 ops, 0 halfops, 0 voices, 206 normal]
2023-06-22 00:39:04 -0400 -!- Irssi: Join to #scheme was synced in 7 secs
2023-06-22 01:57:30 -0400 -!- mode/#scheme [+o Zipheir] by ChanServ
2023-06-22 01:57:55 -0400 -!- mode/#scheme [+b *!*abralek@24.132.74.*] by Zipheir
2023-06-22 01:57:55 -0400 -!- abralek_ was kicked from #scheme by Zipheir [Excess JOIN/QUIT. Please fix your bouncer.]
2023-06-22 01:58:05 -0400 < acdw> hehe
2023-06-22 01:58:29 -0400 -!- mode/#scheme [-b *!*ec@gateway/tor-sasl/ec] by Zipheir
2023-06-22 01:58:46 -0400 -!- mode/#scheme [-o Zipheir] by ChanServ
2023-06-22 02:05:38 -0400  * amirouche waves
2023-06-22 02:11:04 -0400 < Zipheir> Hi amirouche.
2023-06-22 02:45:30 -0400 < amirouche> Current SRFI in draft status: SRFI-234: Topological sorting, SRFI-241: unreadable data, SRFI-242: The CFG Language
2023-06-22 02:45:35 -0400 < amirouche> https://srfi.schemers.org/?statuses=draft
2023-06-22 05:33:17 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-22 06:20:04 -0400 -!- karlosz_ is now known as karlosz
2023-06-22 12:05:16 -0400 < lockywolf> How can I do SQL with Chibi-Scheme?
2023-06-22 12:11:46 -0400 < Zipheir> Unless there is a Snow package, you get to wrap it yourself.
2023-06-22 12:19:08 -0400 < Zipheir> Given chibi's reasonable FFI, it probably wouldn't be too hard to make a SQLite library.
--- Log closed Thu Jun 22 12:40:31 2023
--- Log opened Thu Jun 22 12:48:59 2023
2023-06-22 13:56:00 -0400 < amirouche> there is a good racket project that implements combinators for sql
2023-06-22 14:17:57 -0400 < amirouche> https://deta.defn.io/
2023-06-22 14:18:00 -0400 < amirouche> deta: Functional Database Mapping
2023-06-22 14:18:12 -0400 < amirouche> This library automatically maps database tables to Racket structs and lets you perform CRUD operations and arbitrary queries on them. Sort of like an ORM.
2023-06-22 14:19:24 -0400 < amirouche> A) How to interact with SQL database with chibi?
2023-06-22 14:19:35 -0400 < Zipheir> So much for "functional". It appears to be heavily imperative.
2023-06-22 14:19:37 -0400 < amirouche> B) How to produce SQL code with chibi?
2023-06-22 14:20:47 -0400 < amirouche> I like the query combinators of deta
2023-06-22 14:21:12 -0400 < amirouche> Tho, there is a problem in the example I am looking at
2023-06-22 14:22:38 -0400 < amirouche> http://ix.io/4yQw
2023-06-22 14:22:49 -0400 < amirouche> It seems to me the select should come first, or last
2023-06-22 14:22:50 -0400 < Zipheir> Yes, the querying language looks good. All the insert! stuff is disappointing, though. And what is 'void' in Racket?
2023-06-22 14:23:29 -0400 < amirouche> same I wonder what is void.
2023-06-22 14:23:37 -0400 < sham1> Probably (values)
2023-06-22 14:23:54 -0400 < sham1> Or something like it
2023-06-22 14:24:06 -0400 < sham1> Anyway, using mutation internally should be fine
2023-06-22 14:25:29 -0400 < Zipheir> I mean, the promise of a "functional mapping" for databases was interesting.
2023-06-22 14:27:06 -0400 < amirouche> that is exactly how business work: promise.
2023-06-22 14:27:13 -0400 < Zipheir> But, given that it's supposed to be a layer on top of SQL, there's probably no avoiding some explicit mutation.
2023-06-22 14:27:16 -0400 < amirouche> I mean, mostly, but you need to bring proofs.
2023-06-22 14:27:22 -0400 < amirouche> And I am not sarcastic.
2023-06-22 14:28:37 -0400 < sham1> I feel that as long as mutation is not observable (and internal) then it's fine
2023-06-22 14:29:07 -0400 < Zipheir> amirouche: That is just one meaning of 'promise' in English. Another, which I meant to use, is the sense of "expectation of future benefit".
2023-06-22 14:29:18 -0400 -!- torresjrjr_ is now known as torresjrjr
2023-06-22 14:29:25 -0400 < Zipheir> amirouche: For example, Will Byrd did a talk called "The Promise of Relational Programming".
2023-06-22 14:30:06 -0400 < Zipheir> sham1: That's really the only option when working with mutation-based machines..
2023-06-22 14:31:24 -0400 < amirouche> I will look up the talk by Byrd.
2023-06-22 14:31:46 -0400 < Zipheir> I don't remember the talk, I just thought it was a good title. :)
2023-06-22 14:32:36 -0400 < amirouche> I used 'promise' in the sense of "expectation of future benefit" E.g. cloud will reduce costs of making money with software.
2023-06-22 14:33:36 -0400 < Zipheir> Yes.
2023-06-22 15:06:44 -0400 < amirouche> Zipheir: do you remember everything you read?
2023-06-22 15:51:06 -0400 < Zipheir> amirouche: I don't have that kind of memory. I do find that I remember what I read better than I remember what I watch.
2023-06-22 21:52:31 -0400 < lockywolf> amirouche: I keep what I read in a org-mode file.
--- Day changed Fri Jun 23 2023
2023-06-23 00:02:00 -0400 -!- Netsplit *.net <-> *.split quits: energizer, fluffyballoon, retropikzel, yosafbridge, zyd, evhan, mns, dan_berg_pub, klovett, jakzale,  (+19 more, use /NETSPLIT to show all of them)
2023-06-23 00:02:42 -0400 -!- Netsplit over, joins: klovett, zyd, croc, jcowan, buhman_, Bionicbabelfish, rubin55, robin, retropikzel, aeth (+19 more)
2023-06-23 00:02:42 -0400 -!- evhan_ is now known as evhan
2023-06-23 00:02:45 -0400 -!- csepp_ is now known as csepp
2023-06-23 00:02:49 -0400 -!- dan_berg_pub_ is now known as dan_berg_pub
2023-06-23 00:02:57 -0400 -!- retropikzel_ is now known as retropikzel
2023-06-23 00:03:08 -0400 -!- casaca_ is now known as casaca
2023-06-23 00:03:28 -0400 -!- akarle_ is now known as akarle
2023-06-23 00:03:51 -0400 -!- ifreund_ is now known as ifreund
2023-06-23 00:08:04 -0400 -!- Netsplit *.net <-> *.split quits: Bionicbabelfish, robin, klovett, croc, buhman_, dirtcastle, m5zs7k, mns, aeth, jcowan,  (+5 more, use /NETSPLIT to show all of them)
2023-06-23 00:08:29 -0400 -!- Netsplit over, joins: klovett, croc, jcowan, buhman_, Bionicbabelfish, robin, aeth, mns, elflng, m5zs7k (+5 more)
2023-06-23 00:08:42 -0400 -!- Netsplit *.net <-> *.split quits: gabot, _________, dstein64, xelxebar, dbohdan, saorge, phileasfogg, jurassic, Oxyd, vxe420,  (+10 more, use /NETSPLIT to show all of them)
2023-06-23 00:09:14 -0400 -!- Netsplit over, joins: gabot, wheeler, acdw, fgudin, thatcher, adhoc, saorge, dbohdan, even4void, dstein64 (+10 more)
2023-06-23 00:10:20 -0400 -!- Netsplit *.net <-> *.split quits: dpk, ski, Gliese852, lazr, gahr, enzuru, buffet, rendar, dnm, eMBee,  (+11 more, use /NETSPLIT to show all of them)
2023-06-23 00:10:46 -0400 -!- Netsplit over, joins: teiresias, bsima, Ekho, eMBee, ns12, gahr
2023-06-23 00:10:52 -0400 -!- Netsplit over, joins: rendar, dpk, ski, buffet, yewscio_g, rickbutton_, lazr, dnm, DragonMaus, micro (+4 more)
2023-06-23 00:11:21 -0400 -!- Netsplit over, joins: AndrewYu
2023-06-23 00:11:54 -0400 -!- Netsplit *.net <-> *.split quits: Everything, ggoes, mason, johnjaye, unpx, cinerion, cognemo, choas, Balooga_, sarna,  (+7 more, use /NETSPLIT to show all of them)
2023-06-23 00:13:37 -0400 -!- Netsplit over, joins: johnjaye, avocadoist, sarna, ggoes, theruran, fadein, Balooga_, GreaseMonkey, mason, gwatt (+7 more)
2023-06-23 01:44:01 -0400 < edgar-rft> rudybot: If I had a hammer, I'd hammer in the morning, I'd hammer in the evening, all over this land!
2023-06-23 01:44:03 -0400 < rudybot> edgar-rft: heh. I could also hit my thumb with a hammer or switch to vi
2023-06-23 07:16:21 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-23 10:01:46 -0400 < acdw> i'd hammer out DANGER
2023-06-23 10:01:52 -0400 < acdw> rudybot: i'd hammer out WARNING
2023-06-23 10:01:53 -0400 < rudybot> acdw: So if you already have your keyboard in and suddenly you get a warning BUS x.y.z is trying some fishy shit, you know to put the hammer to it.
2023-06-23 13:43:13 -0400 < acdw> yes
2023-06-23 22:35:25 -0400 < edgar-rft> rudybot: de do do do, de da da da, Is all I want to say to you!
2023-06-23 22:35:27 -0400 < rudybot> edgar-rft: de do do do, de da da da, is all I want to say to you
2023-06-23 22:35:37 -0400 < acdw> do de do do do
2023-06-23 22:36:17 -0400 < edgar-rft> Don't think me unkind, words are hard to find :-)
2023-06-23 22:38:55 -0400 < edgar-rft> rudybot: you already knew that song?
2023-06-23 22:38:55 -0400 < rudybot> edgar-rft: i knew the second song by the sound but not by name.
2023-06-23 22:41:39 -0400 < acdw> rudybot: you're a song
2023-06-23 22:41:39 -0400 < rudybot> acdw: it's kinda like when constestants get on The Voice and want to sing a Whitney Houston song. 'Can you please not.. we know exactly what her voice pattern sounds like and you're not going to even come anywhere close to replicating it, can you sing happy birthday or something.'
2023-06-23 22:41:51 -0400 < acdw> honestly good point
2023-06-23 22:46:05 -0400 < edgar-rft> lert's all start singing scheme songs
2023-06-23 22:47:05 -0400 < acdw> oh the year was 1968 (how I wish I were in Boston now)
2023-06-23 22:48:25 -0400 < acdw> I have no idea on where to go from thsre
2023-06-23 22:54:04 -0400 < edgar-rft> great song :-)
2023-06-23 22:54:28 -0400 < acdw> ,,RIGHT
2023-06-23 22:54:43 -0400 < acdw> I was told we'd cruise the seas for American gols
2023-06-23 22:54:55 -0400 < acdw> we'd fire no gunsz shed no teeeeaaaartrrssss
2023-06-23 22:55:42 -0400 < Zipheir> treats?
2023-06-23 23:00:12 -0400 < acdw> tears**
2023-06-23 23:13:05 -0400 < flatwhatson> Yo ho ho, with parentheses we ride,
2023-06-23 23:13:06 -0400 < flatwhatson> In the Sea of Code, Scheme is our guide.
2023-06-23 23:13:06 -0400 < flatwhatson> Dancing with recursions, looping 'round the byte,
2023-06-23 23:13:06 -0400 < flatwhatson> Under the glow of the pale debugger's light.
2023-06-23 23:13:30 -0400 < flatwhatson>  - Scheme Shanty by ChatGPT
2023-06-23 23:22:32 -0400 < acdw> lol yarrr
2023-06-23 23:27:51 -0400 < Zipheir> The wonderful thing about Scheme is: / Scheme is a wonderful thing. / Complex procedural ideas / Are expressed via simple strings.
2023-06-23 23:28:15 -0400 < Zipheir> Its clear semantics, and lack of pedantics / Help make programs run, run, RUN!
2023-06-23 23:28:34 -0400 < Zipheir> But the most wonderful thing about Scheme is: / Programming in it is fun / Programming in it is FUN!
2023-06-23 23:29:00 -0400 < Zipheir> --John Ramsdell, based on Tigger's Song, quoted by the Great Quux
--- Day changed Sat Jun 24 2023
2023-06-24 00:56:08 -0400 < edgar-rft> looks as we've finally found out what #scheme is good for :-)
2023-06-24 01:38:47 -0400 < aeth> edgar-rft: for getting rich quick
2023-06-24 02:56:03 -0400 < sham1> Getting rich guix
2023-06-24 02:58:14 -0400 < edgar-rft> wrong answer - that's not a song
2023-06-24 03:03:16 -0400 < lockywolf> Do people here understand C++ expression templates? I am looking at them, and it seems that this pattern could have been implemented in Scheme much easier with a sufficiently smart syntax-rules macro.
2023-06-24 04:45:50 -0400 < mdhughes> New Schemers theme song, by Primus: https://www.youtube.com/watch?v=oF4DXdRWzY0  "Schemin' all the time"
2023-06-24 04:46:30 -0400 < dave0> mdhughes: omg
2023-06-24 04:48:18 -0400 < mdhughes> Shockingly not a lot of songs about Scheme. "Seduce & Scheme" from some TV show, a bad ska/punk band, some Indian rap I couldn't understand his scheme.
2023-06-24 04:48:48 -0400 < dave0> i'm omg'ing because it's primus my favorite :-)
2023-06-24 04:51:43 -0400 < shawnw> Primus sucks!
2023-06-24 04:57:56 -0400 < mdhughes> They're not my favorite thing, butt-rock of the late '90s, but I don't mind some big brown beaver. You go with the band that sings about Scheme, not the one you wanted.
2023-06-24 05:20:41 -0400 < dave0> shawnw: they do!
2023-06-24 05:24:16 -0400 < mdhughes> There's also The Kill Screens: https://music.apple.com/us/album/scheme/447957828?i=447957874  "To you my Scheme is busted"
2023-06-24 05:29:32 -0400 < amirouche> Happy scheming and/or week-end!
2023-06-24 05:30:24 -0400 < amirouche> first time I listen to a scheme song
2023-06-24 07:38:24 -0400 < lockywolf> It's as if templates are a lot like Scheme macros, but... weird.
2023-06-24 08:06:28 -0400 < sham1> Well in many ways they are analogous
2023-06-24 08:07:34 -0400 < sham1> If I had to guess, they have to be like that to allow for all the metaprogramming they allow for, which is why things like SFINAE are a thing. Of course unlike with Scheme macros, the template system is a thing which has organically evolved these capabilities over time
2023-06-24 08:07:56 -0400 < sham1> Of course not to say that Scheme macros themselves haven't also had their fair share of organic growth, but still
2023-06-24 15:15:15 -0400 < tomhg> Whats SFINAE?
2023-06-24 15:15:54 -0400 < sham1> Substitution Failure Is Not An Error
2023-06-24 15:16:26 -0400 < sham1> Basically a thing in C++ where an invalid substitution for template parameters isn't an error
2023-06-24 15:16:46 -0400 < tomhg> instead it just core-dumps?
2023-06-24 15:16:55 -0400 < tomhg> Not a C++ fam here
2023-06-24 15:17:14 -0400 < sham1> It's a compile-time thing
2023-06-24 15:17:16 -0400 < Zipheir> Would that be similar to a Scheme macro accepting "ill-shaped" S-exps?
2023-06-24 15:17:22 -0400 < sham1> Yeah
2023-06-24 15:17:28 -0400 < Zipheir> Sounds risky.
2023-06-24 15:18:07 -0400 < sham1> A way I'd think of it is like the idea that a macro not conforming to any given arm of syntax-rules doesn't mean that it's an error
2023-06-24 15:18:34 -0400 < sham1> Like if I have two arms on a syntax-case/syntax-rules, a macro invocation doesn't need to satisfy both of them to be valid
2023-06-24 15:19:27 -0400 < Zipheir> Both?
2023-06-24 15:19:31 -0400 < sham1> Yeah
2023-06-24 15:19:49 -0400 < Zipheir> Aren't cases supposed to be mutually exclusive?
2023-06-24 15:20:08 -0400 < sham1> I suppose the wikipedia article is able to explain better than I am: https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error
2023-06-24 15:20:16 -0400 < Zipheir> Maybe I should just read about it.
2023-06-24 15:20:34 -0400  * tomhg nods and thought about it. If the essences are applied to our IDE-support programs, they wouldn't be of concern.
2023-06-24 15:22:27 -0400 < tomhg> That is; Declaring a unused macro vs. declaring a used macro which is used improperly.
2023-06-24 15:22:44 -0400 < tomhg> *an
2023-06-24 15:22:56 -0400 < Zipheir> I'll have to read more about C++ template to make sense of it, I think. My Scheme analogy wasn't very good, since we don't have macro-based overloading (yet).
2023-06-24 15:34:11 -0400 < jcowan> Well, we have overloading based on shape: you just have to write them in a single macro definition, but it should be possible to have a mechanism to assemble a syntax-rules-style macro out of pieces.
2023-06-24 15:34:41 -0400 < Zipheir> Hmm.
2023-06-24 15:34:54 -0400 < jcowan> They would have to be mutually exclusive patterns.
2023-06-24 15:36:51 -0400 < Zipheir> Not related, but a good point: "Wholemeal programming is good for you: it helps prevent a disease called indexitis." --Richard Bird
2023-06-24 15:39:02 -0400 < Zipheir> (The context is programming with matrices; "wholemeal" refers to dealing with "the matrix as a complete entity in itself". Classic functional programming, in other words.)
2023-06-24 15:58:24 -0400 < tomhg> I'm still busy grasping the previous task so I won't save this; I concluded to myself that it is about ordering the expansions which can be determined (at compile time after grasping the effected files) in my head. Anyhow; If I finally completed my initial task I come here back again.
2023-06-24 15:58:37 -0400 < tomhg> Thanks, #scheme.
2023-06-24 16:08:12 -0400 < cow_2001> https://mastodon.scot/@simon_brooke/110595079800740141
2023-06-24 16:08:26 -0400 < acdw> is there a web formatted version of r7rs somewhere?
2023-06-24 16:08:50 -0400 < cow_2001> acdw: ooh! second!
2023-06-24 16:09:05 -0400 < acdw> I left my ereader at home
2023-06-24 16:09:05 -0400 < Zipheir> You mean an HTML version? No, that's been TODO for a while. There's a rough copy somewhere that amirouche made from the LaTeX
2023-06-24 16:09:12 -0400 < acdw> ah yeah
2023-06-24 16:09:13 -0400 < cow_2001> acdw: is that it? https://scheme.rs/
2023-06-24 16:09:21 -0400 < acdw> also sorry now I remember that I e asked this befoee
2023-06-24 16:09:48 -0400 < acdw> https://uploads.hmm.st/acdw/L2BcxX2nReku/zb2rhZPJhN1dnFV5Gd6GeTp8X6kGYRU2rBu2pSUJQ2Q9YFsr2.jpg
2023-06-24 16:09:58 -0400 < acdw> apparently they changed the theme m?
2023-06-24 16:10:14 -0400 < Zipheir> Yes. It used to be slick.
2023-06-24 16:10:21 -0400 < cow_2001> it is unreadable now :(
2023-06-24 16:10:28 -0400 < acdw> oof lol
2023-06-24 16:10:32 -0400 < Zipheir> Are you visually impaired?
2023-06-24 16:10:44 -0400 < acdw> not me
2023-06-24 16:11:04 -0400 < cow_2001> it is dark on dark
2023-06-24 16:11:14 -0400 < acdw> I'll have to take on a weekend project for htmlizing it
2023-06-24 16:11:19 -0400 < acdw> when I have the time.....
2023-06-24 16:11:25 -0400 < Zipheir> Weird. It's rendering as default black-on-white for me.
2023-06-24 16:11:27 -0400 < cow_2001> not visually impaired but it takes a lot of effort
2023-06-24 16:12:21 -0400 < Zipheir> Yeah, that screenshot looks awful.
2023-06-24 16:12:57 -0400 < acdw> idk if it's bc I'm on mobile or what
2023-06-24 16:13:30 -0400 < acdw> whoa when I flip my phone sideways it's fine
2023-06-24 16:13:36 -0400 < acdw> css weekend
2023-06-24 16:13:41 -0400 < acdw> weirdness**
2023-06-24 16:14:20 -0400 < Zipheir> amirouche should just dump all of that css.
2023-06-24 16:15:03 -0400 < cow_2001> https://0x0.st/HQBY.jpg
2023-06-24 16:15:38 -0400 < Zipheir> Yuck. It must be the mobile version.
2023-06-24 16:16:19 -0400 < cow_2001> when i flip the desktop site switch it stays the same colour scheme
2023-06-24 16:16:29 -0400 < cow_2001> need a bug report
2023-06-24 16:17:15 -0400 < cow_2001> if only i could find the bug report bit in that site's text………
2023-06-24 16:21:03 -0400 < acdw> the repo is a dead kink
2023-06-24 16:21:06 -0400 < acdw> link**
2023-06-24 16:21:36 -0400 < Zipheir> No surprise there.
2023-06-24 16:28:47 -0400 < acdw> iof
2023-06-24 16:28:51 -0400 < acdw> oof even
2023-06-24 22:39:46 -0400 < lockywolf> Unrelated to Scheme, but I bet this chat might be a good place to ask. Does anyone know a method of measuring brain tiredness?
2023-06-24 22:40:30 -0400 < lockywolf> I understand that it is a loosely defined concept, but it clearly exists.
--- Day changed Sun Jun 25 2023
2023-06-25 03:59:54 -0400 < acdw> I'm not sure what you mean.
2023-06-25 09:13:52 -0400 < cow_2001> half of the first 100 primes that end with 2 are odd and half are even.
2023-06-25 09:16:27 -0400 < cow_2001> https://broken.graphics/@alinanorakari/110597053032715847
2023-06-25 09:16:30 -0400 < edgar-rft> ...and even the odds end with 2
2023-06-25 09:17:18 -0400 < cow_2001> chatgpt has no concepts of numbers theory
2023-06-25 10:00:56 -0400 < mdhughes> It is literally trained on the ravings of people online. So of course it writes like an authoritative idiot.
2023-06-25 10:59:30 -0400 < jcowan> mdhughes: It is the world's best bullshit artist.
2023-06-25 11:17:05 -0400 < wasamasa> pretty much
2023-06-25 11:17:16 -0400 < wasamasa> but people like them for some reason
2023-06-25 12:13:41 -0400 < Zipheir> Except for the professional bullshit artists, who have something to fear.
2023-06-25 13:52:38 -0400 -!- AndrewYu is now known as Andrew
2023-06-25 14:53:17 -0400 -!- mirai_ is now known as mirai
2023-06-25 16:14:21 -0400 < cow_2001> i really need to return to the books
2023-06-25 16:14:24 -0400 < cow_2001> hit the books
2023-06-25 16:14:29 -0400 < cow_2001> as they say
2023-06-25 16:14:41 -0400 < cow_2001> been doing stupid work on my stupid script
2023-06-25 16:14:51 -0400 < cow_2001> now it works, but
2023-06-25 18:31:48 -0400 < lechner> Hi, is there an algorithm handbook where I look for the Scheme solution to this problem, please? "Remove all elements mentioned in one list from another (multiple times, if needed) but also provide a list of elements for which no match was found."  It's not for classwork, but for       https://lists.gnu.org/archive/html/guix-devel/2023-06/msg00082.html    Thanks!
2023-06-25 18:38:08 -0400 < Zipheir> I've never seen a description of that particular function, but it's not hard to write. It's a "cross" of 'remove' from SRFI 1 and 'member'. You can fuse the two into a single traversal, and it might speed things up to "dictionarize" the list.
2023-06-25 18:38:13 -0400 < edgar-rft> I don't understand the "multiple times if needed" case after all matching elements have already been removed.
2023-06-25 18:38:45 -0400 < Zipheir> i.e. remove *all* of an element, not just the first?
2023-06-25 18:39:33 -0400 < edgar-rft> *all* elements already covers that case
2023-06-25 18:39:53 -0400 < mirai> lset-difference?
2023-06-25 18:40:05 -0400 < Zipheir> I think that "all" refers to the elements in the to-remove list.
2023-06-25 18:40:45 -0400 < Zipheir> So (remove-all '(1 2 3 1 4) '(1 2)) should yield '(3 4).
2023-06-25 18:41:23 -0400 < edgar-rft> it's not *our* task to ridde what lechner might mean
2023-06-25 18:41:52 -0400 < Zipheir> No, lechner will have to give an example.
2023-06-25 18:44:05 -0400 < Zipheir> lechner: From what you've written, I think you can just use 'partition'.
2023-06-25 18:47:11 -0400 < lechner> edgar-rft / you are right! i contemplated the redundancy and made the addition only because one respected fellow found that particular point impossible to implement (see "every instance")      https://issues.guix.gnu.org/64106#4
2023-06-25 18:47:28 -0400 < lechner> of course, nothing is impossible for the hackers on this list!
2023-06-25 18:49:59 -0400 < Zipheir> I have no idea how that post relates to the question.
2023-06-25 18:52:00 -0400 < lechner> Zipheir / it relates to modifying a list of Guix services (which are similar to what a systemd user might call them) but I think I can adapt any suggestions from this forum for the related question to remove    the numbers     (1, 2, 20, 40)    from      (1, 2, 2, 2 ,3, 4, 5, 5)     ideally, we would like to see     (20, 40)    and    (3, 4, 5, 5)
2023-06-25 18:52:40 -0400 < Zipheir> Commas?!
2023-06-25 18:52:55 -0400 < lechner> sorry!
2023-06-25 18:53:16 -0400 < Zipheir> So you want the symmetric difference on both lists?
2023-06-25 18:53:46 -0400 < lechner> for a scatterbrain like my that term sounds sophisticated and intimidating at the same time
2023-06-25 18:54:21 -0400 < Zipheir> i.e. if S and T are the (multi)sets of elements in the lists, you want S \ T and T \ S.
2023-06-25 18:55:34 -0400 < Zipheir> Or, in Scheme terms, you want (remove (lambda (x) (memv x list1)) list2) and (remove (lambda (x) (memv x list2)) list1)  Right?
2023-06-25 18:56:27 -0400 < Zipheir> lechner: ^
2023-06-25 18:58:37 -0400 < Zipheir> If so, that above is a reasonable O(n)-time implementation. I'm not sure you can do much better.
2023-06-25 18:59:32 -0400 < Zipheir> Sorry, no, it's quadratic because of memv. But it's still probably the best you can do. List-sets are slow.
2023-06-25 19:08:03 -0400  * edgar-rft emits some unsymetrically different blabbering
2023-06-25 19:09:05 -0400 < Zipheir> Ignore the "symmetric" part. That didn't make much sense.
2023-06-25 19:11:26 -0400 < Zipheir> lechner: Look at the lset functions from SRFI 1, too. They're also quadratic-time, but you might find something else you can use.
2023-06-25 19:19:44 -0400 < lechner> Zipheir / yes, i think the list1/list2 code you showed is exactly what i required.
2023-06-25 19:20:02 -0400 < lechner> mirai / what do you think, please?
2023-06-25 19:21:41 -0400 < lechner> Zipheir / the lists are tiny btw
2023-06-25 19:22:33 -0400 < mirai> (lset-difference eq? '(1 2 20 40) '(1 2 2 2 3 4 5 5)) gives me '(20 40)
2023-06-25 19:22:42 -0400 < lechner> yeah, i was just looking at that
2023-06-25 19:22:57 -0400 < lechner> those are the errors bjc wants
2023-06-25 19:23:33 -0400 < lechner> and lset the other way is the other set, no?
2023-06-25 19:23:38 -0400 < lechner> lset-difference
2023-06-25 19:23:39 -0400 < mirai> you can play around with the lset-… procedures (and pencil & paper for some Set arithmetic)
2023-06-25 19:24:05 -0400 < mirai> these are from SRFI-1
2023-06-25 19:25:12 -0400 < mirai> re lset the other way, correct
2023-06-25 19:27:04 -0400 < lechner> there are some peculiarities about the errors may want but this is still much better than what we have now       (lset-difference eq? '(1 2 2 40 20 20) '(1 2 2 2 3 4 5 5))
2023-06-25 19:27:14 -0400 < lechner> gives  (40 20 20)
2023-06-25 19:27:38 -0400 < mirai> > Elements that are repeated multiple times in the list1 parameter will occur multiple times in the result.
2023-06-25 19:28:28 -0400 < lechner> actually, brian may care more about the duplicated 2 that does not appear in the error list, but we can't make everyone happy
2023-06-25 19:29:25 -0400 < mirai> well, you could do a sort+delete-duplicates first but things start to become inefficient
2023-06-25 19:29:51 -0400 < lechner> yeah, i am not worries. folks will jump on it.  do you want to work on it and get the glory?
2023-06-25 19:30:07 -0400 < lechner> or i can post a patch here in a few minutes
2023-06-25 19:31:02 -0400 < Zipheir> If the lists are tiny, lset-difference is fine.
2023-06-25 19:31:23 -0400 < lechner> it is in the fold2 logic david mentions here    https://issues.guix.gnu.org/64106#0
2023-06-25 19:31:26 -0400 < mirai> eh, I'm not too versed in the (efficiency) topic :)
2023-06-25 19:31:49 -0400 < lechner> yeah, but you are our services guru
2023-06-25 19:31:56 -0400 < lechner> go-to guy
2023-06-25 19:35:24 -0400 < lechner> what is fold2, anyway?
2023-06-25 19:36:07 -0400 < Zipheir> Never heard of it.
2023-06-25 19:36:53 -0400 < lechner> https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/services.scm#n345
2023-06-25 19:38:18 -0400 < Zipheir> It looks like a right or left fold where the folded procedure takes an extra argument. But where does that argument come from?
2023-06-25 19:38:31 -0400 < Zipheir> I suppose it could be a fold for lists of pairs.
2023-06-25 19:38:34 -0400 < lechner> here it is    https://git.savannah.gnu.org/cgit/guix.git/tree/guix/combinators.scm#n38
2023-06-25 19:39:07 -0400 < Zipheir> Oh, it's a two-value fold.
2023-06-25 19:40:19 -0400 < Zipheir> Specifically a left fold.
2023-06-25 19:43:52 -0400 < lechner> the fold2 goes away with lset-difference, i think
2023-06-25 19:45:21 -0400 < lechner> are "service" and "clauses" lvalues here?      https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/services.scm#n344
2023-06-25 19:47:19 -0400 < lechner> the logic here is too convoluted because different operations besides "delete" can be applied
2023-06-25 19:48:31 -0400 < Zipheir> In standard Scheme, the only "lvalue" is the first argument of set!. There may be macro stuff going on, but it doesn't look like mutative code.
2023-06-25 19:50:04 -0400 < Zipheir> I guess you could say the vector argument of vector-set! is an lvalue, but Matthias Felleisen may get mad at you.
2023-06-25 19:51:26 -0400 < lechner> yeah, i probably would not call that an lvalue, but what does this do?     (let ((service clauses ( ... stuff ...))))
2023-06-25 19:51:49 -0400 < lechner> its part of a loop
2023-06-25 19:51:54 -0400 < Zipheir> That's invalid syntax in standard Scheme.
2023-06-25 19:52:49 -0400 < Zipheir> Perhaps that's a Guile extension equivalent to (let-values (((service clauses) ...)) ...)
2023-06-25 19:53:25 -0400 < Zipheir> lechner: In any case, it's obviously binding the names 'service' and 'clauses' to some values.
2023-06-25 19:53:29 -0400 < lechner> i don't think so. i think is part of the matching. the "service" is always supposed to be there
2023-06-25 19:53:56 -0400 < lechner> that statement referred to your post just above
2023-06-25 19:54:08 -0400 < Zipheir> No, I don't think it's part of the matching.
2023-06-25 19:54:24 -0400 < Zipheir> I think my interpretation is correct, since we determined that fold2 returns two values.
2023-06-25 19:55:11 -0400 < Zipheir> lechner: Indeed, that's SRFI 71 extended let syntax: https://srfi.schemers.org/srfi-71/srfi-71.html
2023-06-25 19:55:24 -0400 < Zipheir> I knew it looked vaguely familiar.
2023-06-25 21:50:42 -0400 < lechner> Zipheir / mirai / thanks!
2023-06-25 21:51:42 -0400 < lechner> Hi, is there a Scheme function that can count occurrences in a list based on an operator between two, such as equality?
2023-06-25 22:18:52 -0400 < Zipheir> lechner: You mean, given an element and a comparison, count how many times that element occurs?
2023-06-25 22:19:49 -0400 < Zipheir> If so, that's a slight variation on 'count' from SRFI 1.
2023-06-25 22:21:32 -0400 < Zipheir> lechner: In general, I recommend looking through SRFI 1 first whenever you need a certain list procedure.
2023-06-25 22:22:34 -0400 < lechner> Zipheir / okay, thanks! and sorry about the noise here
2023-06-25 22:22:48 -0400 < lechner> Hi, is there a way to do this in Guile?    https://stackoverflow.com/questions/18255571/in-racket-or-scheme-is-there-any-way-to-convert-an-ellipsis-syntax-object-to-a
2023-06-25 22:22:49 -0400 < rudybot> https://teensy.info/XvudjQeERR
2023-06-25 22:28:54 -0400 < jcowan> Zipheir: I understood that to mean "How many distinct elements are there in a list, given a function to specify distinctness?"  The simplest approach is probably to stuff them in a set with a specified equality function and then to see the size of the set.
2023-06-25 22:29:40 -0400 < lechner> yeah maybe. the idea was to group error messages
2023-06-25 22:36:32 -0400 < jcowan> Using the set approach won't work then, because it throws away all but one of the equal-in-the-sense-of-the-predicate messages.
2023-06-25 22:41:18 -0400 < jcowan> A hash table will do the trick: if an element is not in the hash table, wrap it in a list; if it is, cons it to the list and update the entry with the result of cons
2023-06-25 23:45:09 -0400 < Zipheir> Ah, I misunderstood.
--- Day changed Mon Jun 26 2023
2023-06-26 04:29:00 -0400 < dpk> lechner: portable implementation https://gitlab.com/dpk/presrfis/-/blob/master/syntax-case-extensions.md#syntax-list-stx-procedure
2023-06-26 04:46:15 -0400 < sham1> TODO: Should [stx-constant?] return #t on quoted forms?
2023-06-26 04:46:17 -0400 < sham1> Yes
2023-06-26 04:46:57 -0400 < sham1> That's the point of quote and having the forms evaluated from quote being constant
2023-06-26 04:47:30 -0400 < sham1> The current stx-constant? could be renamed stx-self-evaluating?
2023-06-26 04:48:16 -0400 < sham1> Same would arguably also apply with quasiquote
2023-06-26 08:02:24 -0400 < rudybot> la la la
2023-06-26 08:34:50 -0400 -!- civodul`` is now known as civodul
2023-06-26 10:09:14 -0400 < cow_2001> any way of writing scheme directly for the browser?
2023-06-26 10:09:39 -0400 < cow_2001> like, <script src="some-scheme-script.scm">
2023-06-26 10:10:10 -0400 < cow_2001> maybe some existing interpreter
2023-06-26 10:13:22 -0400 < cow_2001> https://lips.js.org/
2023-06-26 10:15:16 -0400 < cow_2001> weird (print "blah") procedure
2023-06-26 10:18:08 -0400 < cow_2001> do you approve?
2023-06-26 10:21:44 -0400 < sham1> That can be polyfilled
2023-06-26 10:24:26 -0400 < cow_2001> a polyfill is a shim for a browser api
2023-06-26 10:24:33 -0400 < cow_2001> that is Suomi for me
2023-06-26 10:24:50 -0400 < cow_2001> https://en.m.wikipedia.org/wiki/Polyfill_(programming)
2023-06-26 10:25:20 -0400 < cow_2001> i see
2023-06-26 10:25:41 -0400 < cow_2001> sham1: what do you mean?
2023-06-26 10:25:59 -0400 < sham1> The thing you just wikipedia'd
2023-06-26 10:26:11 -0400 < cow_2001> they have weird x.y attribute access notation
2023-06-26 10:26:59 -0400 < cow_2001> sham1: is print a polyfill? is that what you mean? i am sorry. i don't know much about these things.
2023-06-26 10:27:42 -0400 < sham1> You can have a script that looks for script-tags with the type of text/scheme (for example) and have those executed by a scheme implementation
2023-06-26 10:28:26 -0400 < cow_2001> ah
2023-06-26 10:28:40 -0400 < sham1> Although for now it'd be text/x-scheme because Scheme sources doesn't have an official MIME type
2023-06-26 10:29:05 -0400 < cow_2001> and that will be https://lips.js.org, right?
2023-06-26 10:29:28 -0400 < sham1> For example
2023-06-26 10:29:28 -0400 < cow_2001> the x-scheme type looker and executer
2023-06-26 10:29:44 -0400 < cow_2001> i see
2023-06-26 10:30:09 -0400 < cow_2001> i don't like these javascriptisms they let in into lips
2023-06-26 10:30:34 -0400 < cow_2001> if you write a scheme write a scheme
2023-06-26 10:30:54 -0400 < cow_2001> scheme has no notion of dot notation
2023-06-26 10:31:06 -0400 < sham1> (a.b)
2023-06-26 10:31:38 -0400 < cow_2001> maybe you could write an object creating macro that would define dots names for all attributes
2023-06-26 10:32:48 -0400 < cow_2001> wait, are you saying scheme does have dot notation?
2023-06-26 10:35:29 -0400 < sham1> If you look at r7rs-small and its "Formal syntax and semantics", especially the lexical syntax, you'll find that an identifier can have a "special subsequent" character, one of which is "."
2023-06-26 10:37:46 -0400 < cow_2001> oh, but that has no semantic meaning
2023-06-26 10:37:56 -0400 < cow_2001> it is just part of the symbol
2023-06-26 10:42:35 -0400 < sham1> Well nothing says you can't have the implementation treating it specially. LIPS for example does, although there the dot is separate from the field being accessed
2023-06-26 10:42:46 -0400 < sham1> So that's a bit of a break from the normal lexical syntax
2023-06-26 10:45:59 -0400 < cow_2001> hmm
2023-06-26 10:46:13 -0400 < cow_2001> biwascheme has no bigint
2023-06-26 10:46:38 -0400 < cow_2001> tried a (fac 1000) and got infinity
2023-06-26 10:49:26 -0400 < lechner> Hi, are match and match-syntax essential the same thing, except that one inlines?
2023-06-26 11:01:02 -0400 < rgherdt> cow_2001: in case you didn't read it yet, there are some infos regarding scheme -> js here: https://call-with.cc/post/state-of-scheme-to-javascript
2023-06-26 11:01:49 -0400 < rgherdt> sofar I only experimented a bit with the gambit-js backend, and documented it here: https://codeberg.org/rgherdt/gambit-js-by-example
2023-06-26 11:03:40 -0400 < Zipheir> lechner: match-syntax isn't standard Scheme, so you may have to explain what it does.
2023-06-26 11:17:56 -0400 < lechner> Hi, does this really build an alist?      https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/services.scm#n301
2023-06-26 11:18:26 -0400 < lechner> doesn't an alist need single dots?
2023-06-26 11:21:02 -0400 < Zipheir> lechner, what is the dot syntax for?
2023-06-26 11:22:09 -0400 < sham1> ((a . b) (c . d) ...) I reckon
2023-06-26 11:22:29 -0400 < Zipheir> (I meant, what does the dot mean.)
2023-06-26 11:22:35 -0400 < lechner> . is the same as cons, right?
2023-06-26 11:22:41 -0400 < lechner> except infix
2023-06-26 11:22:46 -0400 < Zipheir> Yes.
2023-06-26 11:22:54 -0400 < mdhughes> Biwa is very very VERY slow & memory-intensive. Fine for a small interactive form or something, not for a SPA.
2023-06-26 11:23:47 -0400 < Zipheir> lechner: So you don't need a dot to build an alist. *However*, that macro makes "list" alists, not "cons" alists.
2023-06-26 11:24:08 -0400 < Zipheir> lechner: You get ((a b) (c d) ...) instead of ((a . b) (c . d) ...).
2023-06-26 11:24:59 -0400 < mdhughes> Spock wasn't working last I tried, but ami got it working? I've tested Gambit JS, seems to produce decent performing JS.
2023-06-26 11:25:16 -0400 < lechner> are these elements of the format (kind proc . loc)  ? How may I extract kind, please? This does not work. I get    error: (define clause-kind (clause) (match clause ((kind _ _) kind))): source expression failed to match any pattern           http://paste.debian.net/1284165
2023-06-26 11:25:40 -0400 < Zipheir> lechner: Please follow up on one question before asking another.
2023-06-26 11:25:41 -0400 < dpk> wait until the Guile people have everything working on WASM
2023-06-26 11:26:16 -0400 < dpk> (looking at the performance numbers they've got i think it's not out of the question that WASM might replace the regular Guile back-end at some point)
2023-06-26 11:26:28 -0400 < lechner> Zipheir / sorry i got carried away and confused
2023-06-26 11:27:01 -0400 < lechner> Zipheir / you are asking me what the dot is for, or what I think the dot should be for?
2023-06-26 11:27:49 -0400 < Zipheir> lechner: I was saying that the dot isn't magic. I was also saying that that macro makes 'list' alists.
2023-06-26 11:28:09 -0400 < lechner> isn't the whole point of alists that they are "improper"?
2023-06-26 11:28:52 -0400 < lechner> i guess not   http://web.mit.edu/scheme/current/doc/mit-scheme-ref/Association-Lists.html
2023-06-26 11:29:09 -0400 < Zipheir> Even standard ("cons") alists aren't always improper. ((a b c) (d e f)) is a "cons" alist: ((a . (b c)) (d . (e f)).
2023-06-26 11:29:53 -0400 < Zipheir> lechner: You just need to be aware whether an alist is a list of car/cdr associations or a list of car/cadr associations. It's rather annoying, honestly.
2023-06-26 11:29:59 -0400 < Zipheir> *aware of
2023-06-26 11:30:13 -0400 < Zipheir> Apparently Guile likes car/cadr, I guess.
2023-06-26 11:30:23 -0400 < lechner> is the key, meaning the car of each element supposed to be unique?
2023-06-26 11:31:00 -0400 < lechner> i don't even need match. it's just car
2023-06-26 11:31:11 -0400 < sham1> If you're using an alist as an associative container, it doesn't need to be
2023-06-26 11:31:38 -0400 < sham1> Because when you're looking stuff up from there, you stop on the first key match and use that
2023-06-26 11:32:20 -0400 < lechner> i see
2023-06-26 11:32:28 -0400 < Zipheir> lechner: There's no guarantee of uniqueness. You'll have to maintain that when building the list.
2023-06-26 11:32:43 -0400 < Zipheir> (Generally, that's inefficient.)
2023-06-26 11:33:39 -0400 < lechner> so an alist can just be a list of lists, right? in my case each element has triplets even though some docs say alists are lists of pairs
2023-06-26 11:34:00 -0400 < Zipheir> Yes, it can just be a list of lists. In that case, the "value" is a list.
2023-06-26 11:34:18 -0400 < Zipheir> lechner: Remember, in Scheme, all lists are pairs.
2023-06-26 11:34:56 -0400 < Zipheir> "Scheme does not properly have a list type, just as C does not have a string type. Rather, Scheme has a binary-tuple type, from which one can build binary trees. There is an interpretation of Scheme values that allows one to treat these trees as lists." --SRFI 1
2023-06-26 11:35:50 -0400 < mdhughes> LIPS seems interesting, but "." procedure/macro is ugly (no relation), as is "&()" for objects.
2023-06-26 11:36:36 -0400 < lechner> Zipheir / sorry to bother you with all those questions. i am obviously in over my head and should go back to scheme (or lisp) school
2023-06-26 11:36:46 -0400 < lechner> i had a missing parenthesis
2023-06-26 11:36:52 -0400 < lechner> that really should be my name
2023-06-26 11:37:00 -0400 < Zipheir> lechner: The match pattern (key val1 val2 ...) should work for those alists.
2023-06-26 11:37:11 -0400 < lechner> it does!
2023-06-26 11:38:29 -0400 < lechner> using guile, i have transformed some of the ugliest shell scripts to elegant and concise (!) programs, but the data structures in scheme trip me up sometimes
2023-06-26 11:39:32 -0400 < Zipheir> The idioms are certainly different from shell scripting.
2023-06-26 11:42:48 -0400 < Zipheir> Some scripts can be radically improved by switching to Scheme, but others will be the same thing, wrapped in parens.
2023-06-26 11:47:11 -0400 < Zipheir> In particular, anything involving system calls won't be very elegant in Scheme.
2023-06-26 11:52:25 -0400 < sham1> I've been thinking about some way of making process spawning elegant and somewhat scheme-esque
2023-06-26 11:54:17 -0400 < jcowan> sham1: You should look at the prior art, namely scsh.
2023-06-26 11:55:10 -0400 < sham1> Sure, although I'd contest that slightly since scsh is made for a shell-like workflow, which isn't necessarily the thing you want from a subprocess thing
2023-06-26 11:55:45 -0400 < sham1> But I'll certainly look at it alongside other ways various systems have approached this problem in the past
2023-06-26 11:56:07 -0400 < sham1> Schemes, other lisps and even outside of the lisp family
2023-06-26 11:56:49 -0400 < sham1> But one thing is certain: any kind of fork-exec like way of doing this is straight up out
2023-06-26 11:57:44 -0400 < sham1> That way of doing things is terrible even when used from C and it'd be even worse in a scheme. Not to mention that it's not portable, like at all
2023-06-26 11:59:36 -0400 < Zipheir> Fork is brilliant, or, at least, it was in the early 70s. It doesn't fit Scheme very well.
2023-06-26 12:00:17 -0400 < gwatt> There's posix spawn, which is probably better but also has approximately a million parameters
2023-06-26 12:00:54 -0400 < sham1> Doesn't really fit anything that isn't a PDP-11 without sufficient RAM to have multiple programs in main memory at the same time
2023-06-26 12:01:09 -0400 < Zipheir> sham1: The big problem is that OS processes have no meaning in Scheme.
2023-06-26 12:01:47 -0400 < sham1> Well any idea of a OS process is an implementation concern
2023-06-26 12:01:58 -0400 < sham1> Like in other languages like CL, python and so on
2023-06-26 12:02:13 -0400 < Zipheir> That's a general problem, then.
2023-06-26 12:02:56 -0400 < Zipheir> Language semantics generally ignore the OS, so there's no in-language meaning for spawn forms.
2023-06-26 12:03:21 -0400 < sham1> Hell, even C doesn't really know about processes. It's only really because the POSIX and Windows API are defined in C that there's even any kind of a way to do anything like that
2023-06-26 12:05:06 -0400 < gwatt> I'd imagine most schemes have ways of spawning processes, but it's just not standardized
2023-06-26 12:10:03 -0400 < sham1> Probably
2023-06-26 12:29:15 -0400 < lechner> i think fork & exec are tough in any language
2023-06-26 12:31:20 -0400 < lechner> guile may have spawn    https://www.gnu.org/software/guile/manual/html_node/Processes.html#index-spawn
2023-06-26 12:34:24 -0400 < lechner> does anyone here use scsh?
2023-06-26 12:38:30 -0400 < wasamasa> always thought of it as one of those projects few people actually touch
2023-06-26 13:11:10 -0400 < sham1> I finally got around to writing the port filename thing. It's obviously a very rough sketch still, but I do think that it would still be useful: https://codeberg.org/sham1/pre-srfi/src/branch/main/port-filename.md
2023-06-26 13:15:22 -0400 < Zipheir> sham1: Looks good.
2023-06-26 13:17:45 -0400 < sham1> It's such a small thing that I wouldn't expect it to be controversial
2023-06-26 13:18:25 -0400 < Zipheir> The only question I see is whether it should be part of a more general "port properties" SRFI.
2023-06-26 13:18:31 -0400 < sham1> And of course a portable and technically compliant version would just be (define (port-file-name port) #f)
2023-06-26 13:18:35 -0400 < sham1> Hm
2023-06-26 13:19:27 -0400 < sham1> With attaching props to ports, I'm torn. On one hand it'd be nice, but I also don't know how the semantics would be. For example, are they mutable? Can a user attach their own props?
2023-06-26 13:19:46 -0400 < sham1> What properties would there be
2023-06-26 13:20:09 -0400 < Zipheir> There are other protocol-dependent things you might want to ask a port for, like encodings, positions, buffering modes, etc.
2023-06-26 13:20:30 -0400 < Zipheir> URIs? I don't know.
2023-06-26 13:22:33 -0400 < Zipheir> And "custom ports may have custom properties". :)
2023-06-26 13:22:53 -0400 < Zipheir> "My friends, always remember that future events such as these will affect you in the future."
2023-06-26 13:25:22 -0400 < mdhughes> lechner: I've used scsh in the long past, and got it working again recently but haven't used it for anything serious.
2023-06-26 13:26:15 -0400 < mdhughes> It's fine. But when I'm doing something that needs shell/file scripting, I either use some utility functions I wrote in Chez Scheme, or just use zsh, or Python (meh, but it has a *lot* of tools for this).
2023-06-26 13:26:21 -0400 < jcowan> sham1: Note that SRFI 181 already allows custom ports to have an id.  It may make sense for port-filename to return this id, as SRFI 181 has no mechanism to do so.
2023-06-26 13:26:54 -0400 < Zipheir> (That fantastic piece of redundancy is from Plan 9 https://www.youtube.com/watch?v=sqLOrKMk3Wk)
2023-06-26 13:27:09 -0400  * jcowan chuckles
2023-06-26 13:27:23 -0400 < mdhughes> My build script would probably be a little easier in scsh, except that I need Chez's compiler in it anyway.
2023-06-26 13:29:00 -0400 < jcowan> I have a pre-SRFI for converting between bytevectors and Scheme objects as specified by a schema object which corresponds roughly to a C array or struct declaration.
2023-06-26 13:30:29 -0400 < Zipheir> Sounds scary.
2023-06-26 13:31:32 -0400 < jcowan> Most cases are simple. The schema (array f64 4) converts between a double[4] array and an f64vector of length 4, for example.
2023-06-26 13:34:33 -0400 < sham1> I can see that kind of a thing being useful for example with doing stuff with protobuf
2023-06-26 13:48:33 -0400 < jcowan> Just so.  The case that troubles me is unions.  I don't see how you specify which of the arms of the union to apply.  When unpacking, you can just unpack them all and return a list, but when packing, then what?
2023-06-26 13:50:41 -0400 < sham1> Tag them?
2023-06-26 13:50:52 -0400 < gwatt> or use distinct record types?
2023-06-26 13:50:54 -0400 < ecraven> well, you have to provide *one* of the union values, right?
2023-06-26 13:50:55 -0400 < sham1> Like, let me as the user specify the arm
2023-06-26 13:51:17 -0400 < ecraven> if you provide an ambiguous value, that could be multiple, then that's an error
2023-06-26 13:51:36 -0400 < ecraven> so you just shouldn't make a (union uint16 uint32 uint64)
2023-06-26 13:52:04 -0400 < mdhughes> You probably do need named fields for that, so you can specify.
2023-06-26 13:53:14 -0400 < mdhughes> A good example is https://wiki.libsdl.org/SDL2/SDL_Event
2023-06-26 13:53:39 -0400 < mdhughes> Which is just a *mess* to deal with, so I do all my work with it in C and return a nicer thing to Scheme.
2023-06-26 13:54:13 -0400 < sham1> Yeah, in real life uses of unions you can't just avoid "ambiguous" scheme values
2023-06-26 13:54:54 -0400 < ecraven> I mean, you can't just pass in an ambiguous value *unless* you explicitly specify some sort of tag
2023-06-26 13:55:09 -0400 < ecraven> alternatively, you always have to specify the tag, less fun, but more consistent
2023-06-26 13:59:16 -0400 < sham1> IMO unions should always be unfun
2023-06-26 13:59:51 -0400 < sham1> Also having named union "branches" is useful also for introspection
2023-06-26 13:59:55 -0400 < sham1> Same for structures
2023-06-26 14:00:16 -0400 < ecraven> I agree about unions. aren't structures just records?
2023-06-26 14:01:19 -0400 < sham1> Well if we want things like C semantics, we need to take into account whatever alignment requirements there would be. Although that comes with the territory
2023-06-26 14:01:32 -0400 < mdhughes> And endianness.
2023-06-26 14:01:41 -0400 < sham1> No. Bad mdhughes
2023-06-26 14:01:51 -0400  * sham1 throws the Byte order fallacy
2023-06-26 14:02:02 -0400 < mdhughes> But really. We're back in a world where there's both kinds of eggs!
2023-06-26 14:11:50 -0400 < jcowan> The trouble is that with a complex type, a union of structs which contain unions, for example, you'd need a complex type tag and it's a big mess
2023-06-26 14:12:44 -0400 < jcowan> My take on alignment is that you have to specify it in the schema, which has a type (pad n) which provides for n bytes of padding on the C side and nothing on the Scheme side.
2023-06-26 14:13:21 -0400 < jcowan> Otherwise the Scheme code has to know how the C compiler does padding.
2023-06-26 14:18:32 -0400 < jcowan> Each of the int and float types can be native, -le, or -be.
2023-06-26 14:18:34 -0400 < ecraven> jcowan: any ideas how to deal with things like the C "int" type, which can be many sizes?
2023-06-26 14:22:56 -0400 < sham1> You need to know your ABI to begin with, for example for FFI purposes
2023-06-26 14:22:58 -0400 < gwatt> ecraven: presumably you'd specify which int size you want: uint64 int32, etc
2023-06-26 14:23:04 -0400 < sham1> Also that
2023-06-26 14:23:11 -0400 < ecraven> gwatt: well, that would depend on which system I'm running on...
2023-06-26 14:24:15 -0400 < sham1> I'd honestly just mirror what C does with structs and unions and have something like (union (tag1 uint64) (tag2 uint32) (tag3 uint16)), mutatis mutandis with structs
2023-06-26 14:24:19 -0400 < ecraven> sham1: indeed, but what if I want to conform to *multiple* ABIs.. would I have to write the entire expression multiple times?
2023-06-26 14:24:56 -0400 < gwatt> depends on how (in)copmatible the different ABIs are.
2023-06-26 14:25:27 -0400 < sham1> Well you'd need some kind of a descriptor to know what is what
2023-06-26 14:26:54 -0400 < gwatt> if it's a question of integer sizes, ideally everything should have specific sizes in the interface. but "int", "long", "size_t", etc will be defined by the platforms and you'll have to know what they are for that system.
2023-06-26 14:27:35 -0400 < sham1> And for example how wide a void * is, or a function pointer
2023-06-26 14:27:39 -0400 < ecraven> is there some sort of built-in "cond" or "if", that can be used for situations like this?
2023-06-26 14:27:51 -0400 < sham1> cond-expand *maybe*
2023-06-26 14:29:49 -0400 < jcowan> ecraven: Yes, you'd need multiple schemas, but since schemas are just S-expressions you could write code to generate them.
2023-06-26 14:30:17 -0400 < ecraven> so there's no "built-in" way to deal with this?
2023-06-26 14:30:26 -0400 < ecraven> just asking because it's something that has hit me with chez's ffi before
2023-06-26 14:30:34 -0400 < ecraven> not saying it *can* be solved in a good way, just asking ;)
2023-06-26 14:30:35 -0400 < jcowan> Currently I have no plans to support pointers, because it is unclear how to map them to the Scheme side.
2023-06-26 14:30:57 -0400 < jcowan> In practice the only bad case is long, which may be s32 or s64
2023-06-26 14:33:50 -0400 < gwatt> ecraven: since you mentioned chez scheme, it does have "cond-expand" which might be what you want
2023-06-26 14:34:09 -0400 < jcowan> sham1: You don't actually need tags for struct elements: ordering is sufficient, mapping a struct to a (heterogeneous) list.
2023-06-26 14:34:15 -0400 < gwatt> erm, meta-cond is the name I think
2023-06-26 14:34:41 -0400 < sham1> jcowan: right. I'm also thinking in terms of introspection. It's nice to have names
2023-06-26 14:34:56 -0400 < ecraven> make it plists! with :keyword symbols :D
2023-06-26 14:35:41 -0400 < jcowan> Kind of a waste of space.  There is a schema type (label sym type) which allows you to put a label in a schema, but it has no meaning to the packer/unpacker
2023-06-26 14:35:46 -0400 < sham1> Don't you mean #:keywords
2023-06-26 14:36:01 -0400 < ecraven> sham1: I like :foo better, but I'm in the minority there
2023-06-26 14:36:17 -0400 < jcowan> The trouble is that :foo is an ordinary symbol.
2023-06-26 14:36:20 -0400 < sham1> I like :foo as well. It's just that we can't have it
2023-06-26 14:36:22 -0400 < sham1> Yeah
2023-06-26 14:36:25 -0400 < ecraven> jcowan: there could be a procedure that creates an alist or whatever from a schema + a parsed list, right?
2023-06-26 14:36:34 -0400 < jcowan> Yes
2023-06-26 14:36:41 -0400 < ecraven> sham1: well... we *could* have it, it's just.. complicated ;)
2023-06-26 14:37:08 -0400 < sham1> I'm *not* gonna support the kind of hack CL has for Scheme
2023-06-26 14:37:21 -0400 < jcowan> What hack is that?
2023-06-26 14:37:43 -0400 < sham1> Keywords in CL are just symbols in the special KEYWORD package in the Lisp image
2023-06-26 14:37:59 -0400 < ecraven> well, defining that each symbol that starts with a : is a keyword, is that a hack?
2023-06-26 14:38:28 -0400 < sham1> Well not really. It's just that I for one would like for keywords to be a disjoint type from symbols
2023-06-26 14:38:43 -0400 < sham1> And as said, you can't have :foo because that's already a symbol
2023-06-26 14:38:46 -0400 < jcowan> I've always thought they should be in the package whose name is ""
2023-06-26 14:38:50 -0400 < ecraven> they could well be, even if they follow that syntax. it would just break existing programs
2023-06-26 14:39:54 -0400 < sham1> For reference with CL behaviour: http://clhs.lisp.se/Body/11_abc.htm
2023-06-26 14:42:44 -0400 < sham1> I was once looking at how CL implementations implement symbol interning (and to see if any of them GC symbols, which they don't seem to do) and I fell down the rabbithole looking at this stuff.
2023-06-26 14:46:20 -0400 < jcowan> Perhaps this is the right thing: unions are declared (union type ...) and then when packing or unpacking you specify a list of nonnegative integers which are applied to each union in the linear order in which they appear.  So (unpack (struct s64 (union s64 f64)) some-bytevec '(0)) will pull an s64 out of bytes 0-3 and then another one out of bytes 4-7, but if the argument is '(1) you get an s64 and an f64.
2023-06-26 14:47:29 -0400 < jcowan> Alternatively use symbols rather than integers.
2023-06-26 14:48:05 -0400 < sham1> I personally vote for symbols. Non-negative integers is IMO too much like assembly
2023-06-26 14:48:29 -0400 < sham1> Also generally don't like magic symbols
2023-06-26 14:48:35 -0400 < jcowan> Okay, reasonable.
2023-06-26 14:48:35 -0400 < sham1> Err, magic numbers
2023-06-26 14:48:47 -0400 < jcowan> They aren't really magic, they are ordinals.
2023-06-26 14:51:05 -0400 < sham1> Well the ordinals in this case would be magic numbers. While with a symbol you get an actual name, how easily would you actually remember what the arm of the union actually is. Like okay, you can check, but still. Names are better. That's why we have symbols after all
2023-06-26 15:25:29 -0400 < jcowan> I agree.
2023-06-26 15:29:19 -0400 < lechner> Zipheir / Thanks for your help yesterday and today. Credit was given here     https://issues.guix.gnu.org/64106#5
2023-06-26 15:34:14 -0400 < Zipheir> lechner: That's very kind. Thanks.
2023-06-26 16:02:42 -0400 < jcowan> sham1: Okay, the spec is https://github.com/johnwcowan/r7rs-work/blob/master/StructuresCowan.md
2023-06-26 17:02:08 -0400 < amirouche> Generally seems like picky person
2023-06-26 17:10:38 -0400 -!- __________ is now known as _________
2023-06-26 17:17:00 -0400 < jcowan> dpk: ping about read-line*
2023-06-26 17:32:57 -0400 < dpk> jcowan: hi, can’t stay long, what about it?
2023-06-26 17:33:34 -0400 < jcowan> I think it should be called read-textual-record, because it may include more than one line.  "Textual" so as not to suggest that it is for reading Scheme records.
2023-06-26 17:35:50 -0400 < dpk> yeah i don’t really care what it’s called, as long as it’s there
2023-06-26 17:36:36 -0400 < dpk> i do think it was a mistake to make a polymorphic version which reads either strings or bytevectors
2023-06-26 17:37:38 -0400 < dpk> so there should be maybe read-string-record and read-bytevector-record
2023-06-26 17:38:08 -0400 < dpk> also it should use actual KMP and not the half arsed algorithm i used
2023-06-26 17:38:58 -0400 < dpk> (Chibi doesn’t have SRFI 13 else i’d have used the primitives it provides, hint hint)
2023-06-26 19:12:51 -0400 -!- m5zs7k_ is now known as m5zs7k
2023-06-26 23:16:58 -0400 -!- ec_ is now known as ec
--- Day changed Tue Jun 27 2023
2023-06-27 03:19:56 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-27 03:26:14 -0400 -!- civodul` is now known as civodul
2023-06-27 04:11:16 -0400 -!- civodul`` is now known as civodul
2023-06-27 13:04:14 -0400 -!- karlosz_ is now known as karlosz
2023-06-27 14:59:12 -0400 -!- mirai_ is now known as mirai
2023-06-27 15:41:14 -0400 < acdw> schemers!
2023-06-27 15:46:09 -0400 < sham1> people!
2023-06-27 18:10:51 -0400 < amirouche> coders!
2023-06-27 18:11:47 -0400 < edgar-rft> Charles Ponzi!
2023-06-27 18:11:48 -0400 < amirouche> schemers too!
2023-06-27 18:33:03 -0400 < jcowan> Scheme 2!
2023-06-27 19:20:57 -0400 -!- daviid` is now known as daviid
2023-06-27 20:14:18 -0400  * edgar-rft proposes separate function and variable namespaces for R8RS
--- Day changed Wed Jun 28 2023
2023-06-28 00:34:34 -0400 < mdhughes> schemers?
2023-06-28 00:35:04 -0400 < mdhughes> Shouldn't have so much mutation on your identifiers, anyway.
2023-06-28 12:09:09 -0400 -!- mirai_ is now known as mirai
2023-06-28 16:00:43 -0400 -!- mason is now known as ChibaPet
2023-06-28 16:01:45 -0400 -!- ChibaPet is now known as mason
2023-06-28 22:40:06 -0400 -!- Netsplit *.net <-> *.split quits: fluffyballoon, zyd, hrberg, mns, sm2n, jakzale, ifreund, listentolist, wklew, jurassic,  (+12 more, use /NETSPLIT to show all of them)
2023-06-28 22:40:17 -0400 -!- Netsplit over, joins: hrberg
2023-06-28 22:48:54 -0400 -!- Techcable_ is now known as Techcable
2023-06-28 22:52:30 -0400 < lockywolf> function and variable namespaces should be different depending on a variable value, as should be lexical scoping. setting a variable before a file is evaluated should be done in the second line like this: ; -*- lexical-scoping: #t ; lisp2-namespaces: #t -*-
2023-06-28 22:52:51 -0400 < lockywolf> sorry, forgot one semicolon
--- Day changed Thu Jun 29 2023
2023-06-29 00:21:30 -0400 < cow_2001> what do you do when you have a bunch of nested maps?
2023-06-29 00:22:49 -0400 < cow_2001> it looks disorienting
2023-06-29 00:22:59 -0400 < flatwhatson> let*
2023-06-29 00:23:17 -0400 < flatwhatson> name each step
2023-06-29 00:24:52 -0400 < cow_2001> sorry. i don't understand
2023-06-29 00:29:36 -0400 < aeth> the MAP is not the territory :-p
2023-06-29 00:29:40 -0400 < aeth> you can rearrange things however you want
2023-06-29 00:29:59 -0400 < aeth> e.g. turn (f (g (h ...))) into (let* ((... (h ...) ...
2023-06-29 00:30:11 -0400 < aeth> or create named functions of each step
2023-06-29 00:31:59 -0400 < aeth> or maybe play around with fancier FP things that let you change the order things go in
2023-06-29 00:35:58 -0400 < cow_2001> naming a map sounds like a good idea
2023-06-29 00:41:52 -0400 < flatwhatson> cow_2001: any complex multi-step operation can be improved by turning it into a let* where you name the result of each step
2023-06-29 00:42:49 -0400 < flatwhatson> (map a (map b (map c ...))) can become (let* ((ls (map c ...)) (ls (map b ls)) (ls (map a ls))) ls)
2023-06-29 00:45:11 -0400 < flatwhatson> if you're nesting maps inside the lambda of another map, pull them out as helper functions
2023-06-29 00:45:31 -0400 < flatwhatson> basically any code complexity problem is fixed by factoring & naming things appropriately
2023-06-29 00:52:35 -0400 < aeth> oh, right, good point... using the same name repeatedly in a let* is a good trick for when you can't think of names
2023-06-29 00:52:58 -0400 < aeth> I'm glad someone else has done that before, not just me
2023-06-29 00:53:59 -0400 < cow_2001> you can also use compose for that
2023-06-29 00:54:29 -0400 < cow_2001> ((compose a b c) x) is (a (b (c x)))
2023-06-29 00:56:02 -0400 < cow_2001> with cut it is pretty nice
2023-06-29 00:56:05 -0400 < aeth> what you'd want is to define, say, a map-compose
2023-06-29 00:56:11 -0400 < aeth> or compose-map
2023-06-29 00:56:21 -0400 < aeth> I guess it's the latter
2023-06-29 00:57:34 -0400 < flatwhatson> sure, in this case (map (compose a b c) ls) is equivalent, but that's beside the point
2023-06-29 00:58:16 -0400 < aeth> so it's map-compose after all :-p
2023-06-29 00:58:18 -0400 < cow_2001> my problem is maps inside maps, not consecutive maps
2023-06-29 00:58:36 -0400 < flatwhatson> my answer remains the same, and covered that case already :P
2023-06-29 01:00:04 -0400 < flatwhatson> maps inside the proc of other maps can be pulled out as separate functions
2023-06-29 01:00:24 -0400 < flatwhatson> in some cases it might be cleaner to do it as a recursion instead
2023-06-29 01:00:56 -0400 < flatwhatson> eg. i prefer to traverse a grid with a single (let loop ((x 0) (y 0)) ...
2023-06-29 02:37:21 -0400 < mdhughes> A map is 1:1, so you can always compose the functions, not re-map every time, it'll be a lot more efficient.
2023-06-29 02:39:06 -0400 < flatwhatson> i chose a poor example to illustrate the point
2023-06-29 02:41:17 -0400 -!- rgherdt_ is now known as rgherdt
2023-06-29 05:43:12 -0400 -!- greaser|q is now known as GreaseMonkey
2023-06-29 05:48:28 -0400 -!- mdhughes_ is now known as mdhughes
2023-06-29 08:24:49 -0400 < jcowan> mdhughes: Up to a point, Minister.  If the function you are mapping is not pure, you may get unexpected effects if you try to compose it.
2023-06-29 08:41:25 -0400 < mdhughes> If it's not pure, it's going to be defeated by map's undefined evaluation order anyway.
2023-06-29 08:42:49 -0400 < mdhughes> fold, sure, you're tempted to store data outside and do mutable shenanigans, and need to think harder about composing.
2023-06-29 12:01:40 -0400 < Zipheir> Some mutative procedures can be 'map'ped, no problem. You can use 'map' to write length using set! and a counter, for instance.
2023-06-29 12:03:36 -0400 < Zipheir> Of course, for-each is the Right Thing for such designs, but it is an example in which the order of application doesn't matter.
2023-06-29 12:05:51 -0400 < Zipheir> "With sufficient thrust, pigs fly just fine. However, this is not necessarily a good idea. It is hard to be sure where they are going to land, and it could be dangerous sitting under them as they fly overhead." --Ross Callon, RFC 1925
2023-06-29 12:06:15 -0400 -!- theruran_ is now known as theruran
2023-06-29 12:08:05 -0400 < wasamasa> there is a similar quote in the emacs byte-code optimizer
2023-06-29 12:08:26 -0400 < wasamasa> ;; "No matter how hard you try, you can't make a racehorse out of a pig. You can, however, make a faster pig."
2023-06-29 12:17:21 -0400 < Zipheir> That's a pretty good epithet for Emacs itself.
2023-06-29 12:30:42 -0400 < wasamasa> yeah, there is some optimization potential in emacs, no need to resign and think it cannot be made faster
2023-06-29 12:30:58 -0400 < wasamasa> but to prototype a faster solution, scheme is a lot more nicer to use
--- Day changed Fri Jun 30 2023
2023-06-30 00:08:23 -0400 -!- Netsplit *.net <-> *.split quits: motersen, adanwan, madagest, mirai, ec
2023-06-30 00:09:28 -0400 -!- Netsplit over, joins: motersen, ec
2023-06-30 00:09:43 -0400 -!- Netsplit over, joins: adanwan
2023-06-30 07:48:44 -0400 < cow_2001> i need to budger people with questions about cormen's algorithms
2023-06-30 07:49:22 -0400 < cow_2001> i've went ahead too far without knowing how to do basic stuff
2023-06-30 08:09:13 -0400 < dpk> if you test your macros, should you test that the expansion is the code you expect, or that the behaviour of the expanded code is correct?
2023-06-30 08:09:29 -0400 < dpk> Scheme currently makes it quite tricky to do the former
2023-06-30 08:11:18 -0400 < dpk> but the latter has obvious problems of testing more than one thing, in that you’re not just testing that the expansion is correct but also whether all procedures and indeed other macros invoked in the expansion do what they’re supposed to
2023-06-30 08:25:58 -0400 < dpk> at present, in R6RS and by extension probably in R7RS Large, you can test for the correct expansion of a syntax-rules or syntax-case macro by defining the transformer procedure first under a special name as a variable, then binding it under a separate name to a syntactic keyword
2023-06-30 08:26:18 -0400 < dpk> nobody does this
2023-06-30 08:26:30 -0400 < dpk> it might also be the only sensible way to do it, though
2023-06-30 08:28:13 -0400 < dpk> you then need to know how to determine if the expansion is actually equivalent to your expected test case result, testing that the right things are free-identifier=? and bound-identifier=? to each other
2023-06-30 08:29:25 -0400 < dpk> there's no really easy way to do this at present
2023-06-30 08:38:41 -0400 < Oxyd> I'd say the expansion result is an implementation detail and you should check the behaviour of the expanded code instead. You can also check the behaviour of whatever helper procedures and macros it uses separately, so if those get broken you know about it.
2023-06-30 10:04:03 -0400 < sham1> Yeah. You don't check that the code of a procedure is a certain why, so why would you check for macros either
2023-06-30 15:13:14 -0400 < zzz> hi. i'm learning scheme and setting up my environment. i looking for a language server
2023-06-30 15:25:53 -0400 < rgherdt> zzz: which implementation are you using? You could give scheme-lsp-server a try: https://codeberg.org/rgherdt/scheme-lsp-server
2023-06-30 15:26:21 -0400 < rgherdt> it's quite new though, and can still have some bugs
2023-06-30 15:26:46 -0400 < jcowan> rgherdt: Chicken has an LSP server.
2023-06-30 15:27:03 -0400 < rgherdt> jcowan: I know, I wrote it :)
2023-06-30 15:27:10 -0400 < rgherdt> it also supports guile and gambit
2023-06-30 15:27:14 -0400 < jcowan> Oh, so you did
2023-06-30 15:27:36 -0400 < rgherdt> someone is also working on one for r6rs scheme, currently supporting chez: https://github.com/ufo5260987423/scheme-langserver
2023-06-30 15:30:49 -0400 < zzz> starting with chez. now i just need to have scope highlighting until i get used to so many parens
2023-06-30 15:34:41 -0400 < rgherdt> for highlighting you dont need a language server, just an extension supporting the syntax.
2023-06-30 15:35:34 -0400 < rgherdt> which editor/IDE are you using?
2023-06-30 15:50:19 -0400 < Zipheir> I'd suggest not leaning on highlighting to understand scope. Just go with it for a while.
2023-06-30 15:55:48 -0400 < Ren[m]> <zzz> "starting with chez. now i just..." <- paredit, rainbow-delimiters-mode, highlight-parentheses or drracket default highlighting
2023-06-30 15:59:25 -0400 < zzz> Ren[m]: thanks
2023-06-30 16:19:19 -0400 < Zipheir> Who knew Scheme had to be so complicated.
2023-06-30 16:19:55 -0400 < zzz> rgherdt: vim/neovim
2023-06-30 16:20:41 -0400 < gwatt> % in vim will take you to the matching parenthesis/bracket/brace
2023-06-30 16:22:29 -0400 < zzz> gwatt: i'm aware. i even wrote a script to auto highlight matching parens. my trouble is with quickly visually parsing it. i have no trouble conceptually understanding scope
2023-06-30 16:22:44 -0400 < zzz> Zipheir: ^
2023-06-30 16:24:56 -0400 < Zipheir> zzz: I mean that you'll get fast at parsing S-expression nests with a little practice.
2023-06-30 16:25:25 -0400 < zzz> oh ok. i'll take your word for it.
2023-06-30 16:26:05 -0400 < zzz> thanks
2023-06-30 16:27:24 -0400 < Zipheir> It's an impressive piece of Elisp, but I've always thought paredit was a vastly complicated solution to a minor problem (forgetting parens). It's over 3000 lines.
2023-06-30 16:28:04 -0400 -!- ced1 is now known as cedb
2023-06-30 16:29:03 -0400 < rgherdt> reminds me of this: http://www.loper-os.org/wp-content/parphobia.png
2023-06-30 16:29:49 -0400 < Zipheir> rgherdt: Hah.
2023-06-30 16:30:00 -0400 < gwatt> zzz: How well does neovim do scheme indentation? standard vim is not great about it.
2023-06-30 16:30:20 -0400 < Zipheir> rgherdt: What's accurate about that is that, for the Lisper, most of the parens are invisible.
2023-06-30 16:31:13 -0400 < Zipheir> I don't think any editor provides an intelligent way to indent macros.
2023-06-30 16:31:38 -0400 < Zipheir> i.e. a way to define how (form ...) should be indented.
2023-06-30 16:31:45 -0400 < leah2> for emacs its easy to configure
2023-06-30 16:32:19 -0400 < leah2> globally at least :p
2023-06-30 16:32:28 -0400 < Zipheir> IME it can be done, but not very elegantly or quickly.
2023-06-30 16:32:48 -0400 < Zipheir> Right, it also has to be set globally. :-/
2023-06-30 16:33:06 -0400 < leah2> it's one line per macro, quick enough for me
2023-06-30 16:33:27 -0400 < zzz> rgherdt: in that example it's the variable width font that gives me anxiety, most of all
2023-06-30 16:33:57 -0400 < Zipheir> leah2: That's not too bad.
2023-06-30 16:34:12 -0400 < leah2> (put 'while 'scheme-indent-function 1)
2023-06-30 16:34:44 -0400 < Zipheir> leah2: But when you have a form that is not indented in a conventional way (think of 'do'), it gets trickier.
2023-06-30 16:35:28 -0400 < leah2> that is 2 here...
2023-06-30 16:35:44 -0400 < leah2> let is a bit tricky with named let
2023-06-30 16:38:12 -0400 < Zipheir> Which is why I eventually decided that getting nice results with smart Scheme indenters was more work than I wanted to do. vi's autoindent does 90% of what I need, so I'm willing to use the dumb solution.
2023-06-30 16:39:02 -0400 < Zipheir> But YMMV, of course.
2023-06-30 16:39:13 -0400 < leah2> i use emacs anyway so :p
2023-06-30 16:39:18 -0400 < leah2> i can just tweak it when it's wrong
2023-06-30 16:39:35 -0400 < Zipheir> Does Emacs have something like vi autoindent?
2023-06-30 16:39:50 -0400 < rgherdt> Zipheir: to get the indentation of 'do', one can configure it like this: (put 'do 'scheme-indent-function 2)
2023-06-30 16:40:18 -0400 < Zipheir> What does 2 mean?
2023-06-30 16:40:41 -0400 < Zipheir> ^^ I guess autoindent in Emacs is just using C-j instead of Return.
2023-06-30 16:41:37 -0400 < zzz> gwatt: i'm still unsure of what "good indentation" is in scheme
2023-06-30 16:41:38 -0400 < dpk> the 2 means do takes two non-body arguments before the body
2023-06-30 16:42:08 -0400 < Zipheir> dpk: Thanks.
2023-06-30 16:42:38 -0400 < rgherdt> exactly
2023-06-30 16:43:55 -0400 < zzz> is there a way to "inspect" a function and see how many (and which) arguments it takes?
2023-06-30 16:44:39 -0400 < leah2> not portably
2023-06-30 16:44:40 -0400 < Zipheir> zzz: Procedurally?
2023-06-30 16:44:53 -0400 < zzz> well, in the repl at least
2023-06-30 16:45:20 -0400 < Zipheir> Scheme procedures don't take a fixed number of arguments, in generaly.
2023-06-30 16:45:22 -0400 < Zipheir> *general
2023-06-30 16:45:53 -0400 < Zipheir> An implementation could tag a fixed-arg procedure with its arity, but I don't know of any that do.
2023-06-30 16:46:02 -0400 < leah2> iirc gauche and guile do
2023-06-30 16:46:18 -0400 < Zipheir> Oops, sorry.
2023-06-30 16:46:46 -0400 < Zipheir> leah2: Do they allow you to access that information?
2023-06-30 16:46:50 -0400 < leah2> yes
2023-06-30 16:47:09 -0400 < leah2> racket too
2023-06-30 16:47:45 -0400 < leah2> chicken with an egg
2023-06-30 16:48:04 -0400 < Zipheir> Do you get #f if it's a variadic procedure?
2023-06-30 16:48:12 -0400 < leah2> you get a special value
2023-06-30 16:48:17 -0400 < Zipheir> (I'm having trouble finding this in the docs.)
2023-06-30 16:48:25 -0400 < Zipheir> Ah.
2023-06-30 16:48:34 -0400 < leah2> the keyword is arity
2023-06-30 16:49:12 -0400 < gwatt> zzz: since you've mentioned chez specifically earlier, chez scheme does have "procedure-arity-mask" which returns a bitmask representing how many arguments a procedure takes. negative arities accept infinite arguments
2023-06-30 16:49:21 -0400 < Zipheir> leah2: Thanks.
2023-06-30 16:49:41 -0400 < leah2> cute value for 2-complement universes ;)
2023-06-30 16:50:08 -0400 < Zipheir> Racket has a very sophisticated interface for this.
2023-06-30 16:50:17 -0400 < zzz> gwatt: that's great, thanks
2023-06-30 16:50:25 -0400 < Zipheir> https://docs.racket-lang.org/reference/procedures.html#%28part._.Keywords_and_.Arity%29
2023-06-30 16:51:32 -0400 < Zipheir> In particular, they have an arity-at-least value which indicates a procedure takes at least n arguments.
2023-06-30 16:51:42 -0400 < zzz> gwatt: hmmm... i'm getting -8 for fold-right
2023-06-30 16:51:49 -0400 < Zipheir> So they support "dotted tail" procedures. Impressive.
2023-06-30 16:52:16 -0400 < gwatt> zzz: yep, folds accept at minimum 3 arguments
2023-06-30 16:52:47 -0400 < Zipheir> No at-least indicator in Chez, it seems.
2023-06-30 16:53:14 -0400 < zzz> that's unexpected
2023-06-30 16:53:29 -0400 < zzz> i have some reading to do
2023-06-30 16:56:19 -0400 < Zipheir> zzz: If you're using Chez, then the place to look up standard procedures is https://www.r6rs.org/
2023-06-30 16:56:40 -0400 < zzz> nice
2023-06-30 16:56:51 -0400 < Zipheir> By 'look up', I unfortunately mean "scroll through the index". There's no search.
2023-06-30 16:57:49 -0400  * zzz shrugs
2023-06-30 21:46:44 -0400 -!- mode/#scheme [+o Zipheir] by ChanServ
2023-06-30 21:46:56 -0400 -!- mode/#scheme [-b *!*abralek@24.132.74.*] by Zipheir
2023-06-30 21:47:06 -0400 -!- mode/#scheme [-o Zipheir] by ChanServ
2023-06-30 22:47:41 -0400 < mdhughes> I keep meaning to scrape all the library functions & forms into a text file, so I can just grep it.
